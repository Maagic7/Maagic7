TYPE "m7_udtDateInfo"
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


  STRUCT 	
   Year : INT ;	//Year [yyyy] '2020'
   Month : INT ;	//Month [1..12]
   Day : INT ;	//Day [1..31]
   DayOfWeek : INT ;	//Day of week [1..7]
   DayOfYear : INT ;	//Day of Year [1..366]
   Week : INT ;	//Week No.; calendar week [1..53]
   IsLeapYear : BOOL ;	//Year is a leap year / Schaltjahr
   Week53Exist : BOOL ;	//Year is a year with week 53
  END_STRUCT ;	
END_TYPE

TYPE "m7_udtSericeInfo_Drive"
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


  STRUCT 	
   STARTS : DINT ;	//Anzahl der Starts
   RUN_H : DINT ;	//Betriebsstundenzaehler Stunden
   RUN_SEC : INT ;	//Betriebsstundenzaehler Sekunden
   SERVICE_H : INT ;	//Betriebsstunden seit letztem Service
   SERVICE_SEC : INT ;	//Betriebsstunden (Sekuden) seit letztem Service
   SERVICE_STARTS : DINT ;	//Starts seit letztem Service
   LAST_SERVICE_DATE : DATE ;	//Datum des letzten Services
   USER_ID : INT ;	//User-Kennung des Serviceverantwortlichen
   USER_NAME : STRING  [8 ];	//User-Name
   DSP_SERVICE_H : INT ;	//Anzeige nächster Service in Stunden
   DSP_SERVICE_STARTS : DINT ;	//Anzeige nächster Service nach Starts
   FLAG_SERVICE : BOOL ;	//Flag: Service ist fällig
   FLAG_SERVICE_WARN : BOOL ;	//Flag: Warnung Service demnächst
   RESET : BYTE ;	//RESET: (Wartung druchgeführt)
  END_STRUCT ;	
END_TYPE

TYPE "m7_udtServiceCFG_Drive"
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


  STRUCT 	
   STD : INT  := 1000;	//Wartungsintervall Betriebsstunden
   STARTS : DINT ;	//Wartungsintervall Starts
   STD_DSP_MSG : INT  := 50;	//Wartungsintervall Stunden vorher melden
   STARTS_DSP_MSG : INT  := 100;	//Wartungsintervall Starts vorher melden
   STD_AKTIV : BOOL  := TRUE;	//Wartungsintervall nach Betriebsstunden aktiv
   STARTS_AKTIV : BOOL ;	//Wartungsintervall nach Starts aktiv
   FLAG2 : BOOL ;	
   FLAG3 : BOOL ;	
  END_STRUCT ;	
END_TYPE

TYPE "m7_udtServiceInfo_YK"
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


  STRUCT 	
   SCHALTUNGEN : DINT ;	//Anzahl der Schaltungen
   SERVICE_SCHALTUNGEN : DINT ;	//Schaltungen seit letztem Service
   LAST_SERVICE_DATE : DATE ;	//Datum des letzten Services
   LAST_SERVICE_USER : INT ;	//Userkennung des Serviceverantwortlichen
  END_STRUCT ;	
END_TYPE

TYPE "m7_udt_ServiceCFG_YK"
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


  STRUCT 	
   SCHALTUNGEN : DINT ;	//Anzahl der Schaltungen bis zu Wartung/Tausch
   SCHALTUNGEN_DSP_MSG : DINT  := L#1000;	//Wartungsintervall Schaltungen vorher melden
   FLAG0 : BOOL ;	
   FLAG1 : BOOL ;	
  END_STRUCT ;	
END_TYPE

TYPE "m7_udt_IEC_TimerInstance"
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


  STRUCT 	
   IN : BOOL ;	//TIMER INPUT: Signal
   PT : TIME ;	//TIMER INPUT: TIME
   Q : BOOL ;	//TIMER OUTPUT: Q
   ET : TIME ;	//TIMER OUTPUT: ET
   memSTATE : BYTE ;	//static: STATE
   memSTIME : TIME ;	//static: STIME
   memATIME : TIME ;	//static: ATIME
  END_STRUCT ;	
END_TYPE

TYPE "m7_udtCntDINT"
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


  STRUCT 	
   all : DINT ;	//Counter: overall (Gesamtzähler)
   hour : DINT ;	//Counter: hour
   day : DINT ;	//Counter: day
   week : DINT ;	//Counter: week
   month : DINT ;	//Counter: month
   year : DINT ;	//Counter: year
   user : DINT ;	//Counter: user (Zähler Benutzer z.B. Schichtzähler)
   DT_USER_RESET : DATE_AND_TIME ;	//Reset time of user counter (Zeit Benutzerzähler gelöscht)
  END_STRUCT ;	
END_TYPE

TYPE "m7_udtMinMaxStat_REAL"
// UDT291
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 1.0


  STRUCT 	
   all : REAL ;	//Schleppzeiger: overall (Gesamtzähler)
   hour : REAL ;	//Schleppzeiger: hour
   day : REAL ;	//Schleppzeiger: day
   week : REAL ;	//Schleppzeiger: week
   month : REAL ;	//Schleppzeiger: month
   year : REAL ;	//Schleppzeiger: year
   user : REAL ;	//Schleppzeiger: user (Zähler Benutzer z.B. Schichtzähler)
   DT_USER_RESET : DATE_AND_TIME ;	//Reset time of user value (Zeit Benutzerwert gelöscht)
   DT_all : DATE_AND_TIME ;	//time all min/max event occured
   DT_hour : DATE_AND_TIME ;	//time hour min/max event occured
   DT_day : DATE_AND_TIME ;	//time day min/max event occured
   DT_week : DATE_AND_TIME ;	//time weed min/max event occured
   DT_month : DATE_AND_TIME ;	//time month min/max event occured
   DT_year : DATE_AND_TIME ;	//time year min/max event occured
   DT_user : DATE_AND_TIME ;	//time user min/max event occured
  END_STRUCT ;	
END_TYPE

FUNCTION "m7b_ABS_DIFF_S7SysTime" : VOID
TITLE =ABS_DIFF_S7SysTime : Differenz zweier S7SystemZeiten 31Bit-Werte
//Da die S7 Systemzeit mittels SFC64 "TIME_TCK" nur 31 Bit 0..2147483647 ms
//aufweist gibt es einen Fehler, wenn Zeitdifferenzen über eine Timerüberlauf
//ermittelt werden. Um dies zu verhindern muss die Systemzeit auf 32Bit erweitert 
//werden.
//
//Der Aufruf dieses FC ist für AWL vorgesehn, als Unconditioned Call
//
//L  #SysTime1
//L  #SysTime2
//UC FC 256
//T  #TimeDiff
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 13/2013
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME       AENDERUNG
//--------------------------------------------------------------------------------
//15.01.2016   S.Maag     Fälschlich vorhandene IO-Paramter entfernt
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1

BEGIN
NETWORK
TITLE =die beiden Zeitwerte müssen bereits in den Akkus stehen

      SLD   1; // 1. Zeit in Akku 1 auf 32 Bit-Wert erweitern
      TAK   ; // Akkus tauschen
      SLD   1; // 2. Zeit auf 32 Bit-Wert erweitern
      -D    ; // Differenz bilden (=doppelte Differenz)
      SPPZ  pos; // If <0 THEN 
      NEGD  ; //             'Vorzeichen umkehren' 
pos:  SRD   1; // 32 Bit Korrektur wieder entferen TimeDiff nun in AKKU 1



END_FUNCTION

FUNCTION "m7a_INV_IEC_TIME" : VOID
TITLE =IEC Zeit invertieren, Rückwärtszählung
//IEC Zeit invertieren. Wird benötigt z.B. benötigt, wenn Ausschaltverzögerungen 
//über SFB5 programmiert werden und die Zeitanzeige dann rückwärts laufen soll. 
//SFB5 stellt nur einen vorwärts laufenden Timerwert zur Verfügung
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 1/2005
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  iecDauer : TIME ;	//Dauer
  iecTimer : TIME ;	//Zeitwert vom Timer
END_VAR
VAR_OUTPUT
  iecInvTime : TIME ;	
END_VAR
BEGIN
NETWORK
TITLE =

      L     #iecDauer; 
      L     #iecTimer; 
      -D    ; 
      L     L#0; 
      <D    ; 
      SPB   SAVE; 
      TAK   ; 
SAVE: T     #iecInvTime; 
NETWORK
TITLE =FC-ENO

      SET   ; 
      SAVE  ; 
      CLR   ; 

END_FUNCTION

FUNCTION "m7b_SchleppZeiger_INT" : VOID
TITLE =SchleppZeiger_INT: Schleppzeiger für Integer (drag indicator)
//Schleppzeiger für Integerwerte
//
//Der FC-ENO-Ausgang wird dann "1", wenn der Schleppzeiger einen neuen Wert 
//erhält, ansonsten ist der FC-ENO-Ausgang "0"
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 9/2004
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  iValue : INT ;	//aktueller Wert
  cfgMinMax : BOOL ;	//Konfig.: 0=Minimum Schleppzeiger 1=Maximum Schleppzeiger
  Init : BOOL ;	//Initialisierung, Schleppzeiger wird auf aktuellen Wert gesetzt
END_VAR
VAR_IN_OUT
  SchleppZeiger : INT ;	//Schleppzeiger-Wert
END_VAR
BEGIN
NETWORK
TITLE =

      U     #Init; 
      SPB   INIT; 

      U     #cfgMinMax; // Maximum Schleppzeiger
      SPB   MAX; 

      L     #SchleppZeiger; // Minimum Schleppzeiger
      L     #iValue; 
      <I    ; 
      SPB   END; 
      SPA   SAVE; 

INIT: L     #iValue; // Schleppzeicher initialisieren
      SPA   SAVE; 

MAX:  L     #SchleppZeiger; 
      L     #iValue; 
      >I    ; 
      SPB   END; 

SAVE: T     #SchleppZeiger; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
      BEA   ; 

END:  CLR   ; 
      SAVE  ; 

END_FUNCTION

FUNCTION_BLOCK "m7b_MultiTimer"
TITLE =Multi Timer
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 7/2012
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME       AENDERUNG
//--------------------------------------------------------------------------------
//03/12/2013   S.Maag      SFC64 TimeTick Zeitdifferenz korrigiert
//                         da 31Bit, Fehler bei Überlauf. Auf 32 Bit-Rechnung
//                         erweitert
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  IN : BOOL ;	//Singanl Input
  RESET : BOOL ;	//RESET
  timT1 : TIME ;	//Time first function
  timT2 : TIME ;	//Time second function
  cfgMODE : INT ;	//0:TON/TOF 1:Puls/Pause 2:Pause/Puls 3:Delayed/Impuls
END_VAR
VAR_OUTPUT
  Q : BOOL ;	
  DSP_T1 : TIME ;	
  DSP_T2 : TIME ;	
END_VAR
VAR
  HM_FP_IN : BOOL ;	
  HM_FN_IN : BOOL ;	
  Q1 : BOOL ;	
  Q2 : BOOL ;	
  HM_FP : BOOL ;	
  HM_FN : BOOL ;	
  tStartTime1 : TIME ;	
  tStartTime2 : TIME ;	
  Mode_old : INT ;	//0:TON-TOF 1:Puls-Pause 2:PausePuls 3:DelayedImpuls
END_VAR
VAR_TEMP
  aktSysTime : TIME ;	
  tTdiff1 : TIME ;	
  tTdiff2 : TIME ;	
  FP_IN : BOOL ;	
  FN_IN : BOOL ;	
  PP_INVERT : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =aktuelle Systemzeit auslesen

      CALL "TIME_TCK" (
           RET_VAL                  := #aktSysTime);
      NOP   0; 
NETWORK
TITLE =Zeitdifferenz zur gespeicherten Startzeit 1

      L     #aktSysTime; 
      L     #tStartTime1; 
      UC    "m7b_ABS_DIFF_S7SysTime"; 
      T     #tTdiff1; 
      T     #DSP_T1; 
NETWORK
TITLE =Zeitdifferenz zur gespeicherten Startzeit 2

      L     #aktSysTime; 
      L     #tStartTime2; 
      UC    "m7b_ABS_DIFF_S7SysTime"; 
      T     #tTdiff2; 
      T     #DSP_T2; 
NETWORK
TITLE =Positive Flanke Start

      U     #IN; 
      FP    #HM_FP_IN; 
      SPBNB _001; 
      L     #aktSysTime; 
      T     #tStartTime1; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
_001: U     BIE; 
      =     #FP_IN; 
NETWORK
TITLE =Negative Flanke Start

      U     #IN; 
      FN    #HM_FN_IN; 
      SPBNB _002; 
      L     #aktSysTime; 
      T     #tStartTime2; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
_002: U     BIE; 
      =     #FN_IN; 
NETWORK
TITLE =RESET & RESET bei Moduswechsel
//Bei Moduswechsel zuerst RESET ausführen
      L     #Mode_old; 
      L     #cfgMODE; 
      T     #Mode_old; 
      <>I   ; 
      SPB   CLR; 

      U     #RESET; 
      SPB   CLR; 

NETWORK
TITLE =

      L     #cfgMODE; // Modus
      SPL   CLR; // Sprungziel bei ungültigem Modus
      SPA   ONOF; // MODE 0: TON & TOF
      SPA   PSPA; // MODE 1: PULS-PAUSE ' PROG von PULS_PAUSE
      SPA   PAPS; // MODE 2: PAUSE-PULS ' und PAUS_PULS identisch
      SPA   DIMP; // MODE 3: DELAYED IMPULS

CLR:  SET   ; // RESET
      R     #Q; 
      R     #Q1; 
      R     #Q2; 

      L     #aktSysTime; 
      T     #tStartTime1; 
      T     #tStartTime2; 
      SPA   END; 


NETWORK
TITLE =TON & TOF
//======================================================================
//                   TON & TOF
//======================================================================
ONOF: NOP   0; 

NETWORK
TITLE =Ein- und Ausschaltverzögerung
//Zeit Startet bei Flanke am Eingang
//timT1: TON
//timT2: TOF
      U(    ; 
      U     #FP_IN; 
      S     #Q2; 
      UN    #IN; 
      R     #Q2; 
      U     #Q2; 
      )     ; 
      U(    ; 
      L     #tTdiff1; 
      L     #timT1; 
      >=D   ; 
      )     ; 
      S     #Q1; 
      UN    #IN; 
      U(    ; 
      L     #tTdiff2; 
      L     #timT2; 
      >=D   ; 
      )     ; 
      R     #Q1; 
      U     #Q1; 
      =     #Q; 
NETWORK
TITLE =

      SPA   END; 

NETWORK
TITLE =PULS - PAUSE bzw. PAUSE - PULS
//======================================================================
//        P U L S   -   P A U S E   bzw.  P A U S E  -  P U L S
//======================================================================

PSPA: SET   ; // PULS-PAUSE
      R     #PP_INVERT; // Ausgangssignal von Timer nicht invertieren
      SPA   ne13; 
PAPS: SET   ; // PAUSE-PULS
      S     #PP_INVERT; // Ausgangssignal von Timer muss invertiert werden
ne13: NOP   0; 
NETWORK
TITLE =

      U(    ; 
      U     #IN; 
      UN    #Q1; 
      UN    #Q2; 
      FP    #HM_FP; 
      SPBNB _003; 
      L     #aktSysTime; 
      T     #tStartTime1; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
_003: U     BIE; 
      )     ; 
      S     #Q1; 
      U(    ; 
      U(    ; 
      U     #Q1; 
      U(    ; 
      L     #tTdiff1; 
      L     #timT1; 
      >=D   ; 
      )     ; 
      SPBNB _004; 
      L     #aktSysTime; 
      T     #tStartTime2; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
_004: U     BIE; 
      )     ; 
      S     #Q2; 
      U     #Q2; 
      U(    ; 
      L     #tTdiff2; 
      L     #timT2; 
      >=D   ; 
      )     ; 
      R     #Q2; 
      U     #Q2; 
      )     ; 
      R     #Q1; 
      NOP   0; 
NETWORK
TITLE =Ausgang für PULS-PAUSE und PAUSE-PULS
//Ausgang invertieren mit Exclusiv Oder
//Ist PP_INVERT = FALSE, dann wird Q = Q1
//Ist PP_INVERT = TRUE, dann wird Q = NOT Q1, da True wenn beide unterschiedlich
      U     #Q1; 
      X     #PP_INVERT; 
      U     #IN; 
      =     #Q; 

NETWORK
TITLE =

      SPA   END; 


NETWORK
TITLE =Verzögerter Impuls (Delayed Impuls)
//======================================================================
//                 D E L A Y E D   I M P U L S
//======================================================================
DIMP: NOP   0; 

NETWORK
TITLE =

      U(    ; 
      U(    ; 
      U     #FP_IN; 
      S     #Q2; 
      UN    #IN; 
      R     #Q2; 
      U     #Q2; 
      )     ; 
      U(    ; 
      L     #tTdiff1; 
      L     #timT1; 
      >=D   ; 
      )     ; 
      SPBNB _005; 
      L     #aktSysTime; 
      T     #tStartTime2; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
_005: U     BIE; 
      )     ; 
      S     #Q1; 
      U(    ; 
      UN    #Q1; 
      U(    ; 
      L     #tTdiff2; 
      L     #timT2; 
      >=D   ; 
      )     ; 
      ON    #IN; 
      )     ; 
      R     #Q1; 
      U     #Q1; 
      =     #Q; 
NETWORK
TITLE =

END:  U     #Q; 
      SAVE  ; 
      CLR   ; 

END_FUNCTION_BLOCK

FUNCTION_BLOCK "TEST"
TITLE =
VERSION : 0.1


VAR
  test : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =

      U     M      0.0; 
      UN    M      0.0; 
      =     M      0.0; 
NETWORK
TITLE =

NETWORK
TITLE =

END_FUNCTION_BLOCK

FUNCTION "m7a_BitsToByte" : VOID
TITLE =BitsToByte: verbindet 8 Bits zu einem Byte
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 6/2007
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//12.08.2013   S.Maag    direkets Byteweises kopieren von den Eingängen
//                       funktioniert nur, wenn die Quellbits aufeinanderfolgend
//                       sind. (war bisher immer zufällig so, da KOP und 
//                       Übergabe per Lx.y, Im AWL funktioniert es nicht, da 
//                       direkte Merkeradressen übergeben werden)
//                       Bits müssen deshalb immer einzeln kopiert werden!
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  Bit0 : BOOL ;	
  Bit1 : BOOL ;	
  Bit2 : BOOL ;	
  Bit3 : BOOL ;	
  Bit4 : BOOL ;	
  Bit5 : BOOL ;	
  Bit6 : BOOL ;	
  Bit7 : BOOL ;	
END_VAR
VAR_OUTPUT
  TheByte : BYTE ;	
END_VAR
BEGIN
NETWORK
TITLE =
//alter CODE funktioniert nicht wenn AWL-Aufruf mit nicht zusammenhängenden Bits
//      L     P##Bit0
//      LAR1  
//      L     B [AR1,P#0.0]
//      T     #TheByte
//
      U     #Bit0; 
      =     L      0.0; 
      U     #Bit1; 
      =     L      0.1; 
      U     #Bit2; 
      =     L      0.2; 
      U     #Bit3; 
      =     L      0.3; 
      U     #Bit4; 
      =     L      0.4; 
      U     #Bit5; 
      =     L      0.5; 
      U     #Bit6; 
      =     L      0.6; 
      U     #Bit7; 
      =     L      0.7; 

      L     LB     0; 
      T     #TheByte; 

      SET   ; 
      SAVE  ; 
      CLR   ; 


END_FUNCTION

FUNCTION_BLOCK "Counter_DEMO"
TITLE =DEMO FB for Counter
VERSION : 0.1


VAR
  MSG_CNT_LimitUp : BOOL ;	
  MSG_CNT_LimitDwn : BOOL ;	
  CMD_CNT_RESET : BOOL ;	
  Signal_CNT_UP : BOOL ;	
  RTrig_CntUp : BOOL ;	
  MSG_Counter_Full : BOOL ;	
  memCounter_lo : DINT ;	
  memCounter_hi : DINT ;	
  symSignal : BOOL ;	
  symSig_LimUp : BOOL ;	
  symSig_LimDwn : BOOL ;	
  symSig_Reset : BOOL ;	
  symSig_RTrig : BOOL ;	
  SystemTimer_BasicTakt : BOOL ;	
  mem_symCounter : DINT ;	
  sigPausePuls : BOOL ;	
  sigPulsPause : BOOL ;	
  ppLimUp : BOOL ;	
  ppLimDwn : BOOL ;	
  memDriveSpeed : DINT ;	
  MSG_FullSpeed : BOOL ;	
  MSG_Stop : BOOL ;	
  CMD_Drive_FWD : BOOL ;	
  CMD_Drive_REV : BOOL ;	
  cmd_StopFromFWD : BOOL ;	
  cmd_StopFromREV : BOOL ;	
END_VAR
VAR_TEMP
  VKE0 : BOOL ;	
  xVOID : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =

      U     #VKE0; 
      R     #VKE0; 
NETWORK
TITLE =DEMO for 62-Bit counter
//======================================================================
//                      62 BIT COUNTER DEMO
//======================================================================


NETWORK
TITLE =
//Here you insert the HMI-Rest-Button
      U     #VKE0; 
      =     #CMD_CNT_RESET; 
NETWORK
TITLE =Lower Part of the Counter
//we use only positive values of the counter (0..2147483647), 31-Bit
      U     #Signal_CNT_UP; 
      FP    #RTrig_CntUp; 
      =     L      1.0; 
      BLD   103; 
      U     #VKE0; 
      =     L      1.1; 
      BLD   103; 
      U(    ; 
      O     #CMD_CNT_RESET; 
      O     #MSG_CNT_LimitUp; 
      )     ; 
      =     L      1.2; 
      BLD   103; 
      CALL FC   294 (
           xCntUp                   := L      1.0,
           xCntDwn                  := L      1.1,
           xRESET                   := L      1.2,
           dSetVal                  := L#0,
           dCntVal                  := L#1,
           dLimitDwn                := L#0,
           dLimitUp                 := L#2147483647,
           xLimUp                   := #MSG_CNT_LimitUp,
           xLimDwn                  := #xVOID,
           io_dCNT                  := #memCounter_lo);
      NOP   0; 
NETWORK
TITLE =Hi part: Counts the overflows of the lower counter
//The 62 Bit CounterValue is:
//memCounter_hi * 2147483648 + memCounter_lo
      U     #MSG_CNT_LimitUp; 
      =     L      1.0; 
      BLD   103; 
      U     #VKE0; 
      =     L      1.1; 
      BLD   103; 
      U     #CMD_CNT_RESET; 
      =     L      1.2; 
      BLD   103; 
      CALL FC   294 (
           xCntUp                   := L      1.0,
           xCntDwn                  := L      1.1,
           xRESET                   := L      1.2,
           dSetVal                  := L#0,
           dCntVal                  := L#1,
           dLimitDwn                := L#0,
           dLimitUp                 := L#2147483647,
           xLimUp                   := #MSG_Counter_Full,
           xLimDwn                  := #xVOID,
           io_dCNT                  := #memCounter_hi);
      NOP   0; 
NETWORK
TITLE =Symetrisches Taktsignal genereieren
//======================================================================
//  G E N E R E A T E   A   S Y M E T R I C   C L O C K   S I G N A L
//======================================================================


NETWORK
TITLE =

      U     #VKE0; 
      FP    #symSig_RTrig; 
      =     #SystemTimer_BasicTakt; 
NETWORK
TITLE =
//This creates a Signal what is for 10 counts Lo then for 10 counts Hi.
//If you count seconds this will be 10seconds Lo 10seconds Hi.
//
//dLimitUp sets the symetric time Hi/Lo of the signal
      U(    ; 
      U     #SystemTimer_BasicTakt; 
      UN    #symSignal; 
      =     L      1.0; 
      BLD   103; 
      U     #SystemTimer_BasicTakt; 
      U     #symSignal; 
      =     L      1.1; 
      BLD   103; 
      U     #symSig_Reset; 
      =     L      1.2; 
      BLD   103; 
      CALL FC   294 (
           xCntUp                   := L      1.0,
           xCntDwn                  := L      1.1,
           xRESET                   := L      1.2,
           dSetVal                  := L#0,
           dCntVal                  := L#1,
           dLimitDwn                := L#0,
           dLimitUp                 := L#10,
           xLimUp                   := #symSig_LimUp,
           xLimDwn                  := #symSig_LimDwn,
           io_dCNT                  := #mem_symCounter);
      U     BIE; 
      )     ; 
      U     #symSig_LimUp; 
      S     #symSignal; 
      U     #symSig_LimDwn; 
      R     #symSignal; 
      NOP   0; 
NETWORK
TITLE =
//======================================================================
//  G E N E R E A T E   A   P A U S E / P U L S E   S I G N A L
//======================================================================


NETWORK
TITLE =Generate an asymetric Pause/Puls singal
//dLimitUp  = Pause
//dLimitDwn = PULS
//
//If we need a PulsPause signal just invert the PausePuls
//in this case is
//dLimitUp  = PULS
//dLimitDwn = PAUSE
      U(    ; 
      U(    ; 
      U     #SystemTimer_BasicTakt; 
      UN    #sigPausePuls; 
      =     L      1.0; 
      BLD   103; 
      U     #SystemTimer_BasicTakt; 
      U     #sigPausePuls; 
      =     L      1.1; 
      BLD   103; 
      U(    ; 
      O     #ppLimUp; 
      O     #ppLimDwn; 
      )     ; 
      =     L      1.2; 
      BLD   103; 
      CALL FC   294 (
           xCntUp                   := L      1.0,
           xCntDwn                  := L      1.1,
           xRESET                   := L      1.2,
           dSetVal                  := L#0,
           dCntVal                  := L#1,
           dLimitDwn                := L#-10,
           dLimitUp                 := L#20,
           xLimUp                   := #ppLimUp,
           xLimDwn                  := #ppLimDwn,
           io_dCNT                  := #mem_symCounter);
      U     BIE; 
      )     ; 
      U     #ppLimUp; 
      S     #sigPausePuls; 
      U     #ppLimDwn; 
      R     #sigPausePuls; 
      U     #sigPausePuls; 
      )     ; 
      NOT   ; 
      =     #sigPulsPause; 
NETWORK
TITLE =Ramp generator for Drive speed
//======================================================================
//    A C C E L E R A T I O N / D E C E L E R A T I O N   R A M P 
//======================================================================


NETWORK
TITLE =Signal to finish ramp if there is no Start signal

      UN    #CMD_Drive_FWD; 
      UN    #CMD_Drive_REV; 
      U(    ; 
      L     #memDriveSpeed; 
      L     0; 
      >D    ; 
      )     ; 
      =     #cmd_StopFromFWD; 
NETWORK
TITLE =Signal to finish ramp if there is no Start signal

      UN    #CMD_Drive_FWD; 
      UN    #CMD_Drive_REV; 
      U(    ; 
      L     #memDriveSpeed; 
      L     0; 
      <D    ; 
      )     ; 
      =     #cmd_StopFromREV; 
NETWORK
TITLE =Acceleration deceleration ramp
//If we use a SystemTakt of 1sec, and a CountingValue = 10, a Limit of +/- 1000 
//(100.0%), we speed up/down 1% per second.
//
//For asymetric ramps we must use a Multiplexer to set dCntVal for acceleration
//and deceleration.
      U(    ; 
      O     #CMD_Drive_FWD; 
      O     #cmd_StopFromREV; 
      )     ; 
      U     #SystemTimer_BasicTakt; 
      =     L      1.0; 
      BLD   103; 
      U(    ; 
      O     #CMD_Drive_REV; 
      O     #cmd_StopFromFWD; 
      )     ; 
      U     #SystemTimer_BasicTakt; 
      =     L      1.1; 
      BLD   103; 
      U     #VKE0; 
      =     L      1.2; 
      BLD   103; 
      CALL FC   294 (
           xCntUp                   := L      1.0,
           xCntDwn                  := L      1.1,
           xRESET                   := L      1.2,
           dSetVal                  := L#0,
           dCntVal                  := L#10,
           dLimitDwn                := L#-1000,
           dLimitUp                 := L#1000,
           xLimUp                   := #MSG_FullSpeed,
           xLimDwn                  := #MSG_Stop,
           io_dCNT                  := #memDriveSpeed);
      NOP   0; 
END_FUNCTION_BLOCK

FUNCTION_BLOCK "Test_INT_FUNC"
TITLE =Beispiele für Aufruf der Integer-Funktionen 
VERSION : 0.1


VAR
  Value1 : INT ;	
  Value2 : INT ;	
  Result : INT ;	
  DSP_PAW : INT ;	
  OK : BOOL ;	
  SLP_MIN : INT ;	
  SLP_MAX : INT ;	
  SLP_COUNT : WORD ;	
END_VAR
VAR_TEMP
  MSG_LIMIT : BOOL ;	//Meldung Limit
  NEW_VALUE : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =Schleppzeiger kleinster Wert
//Der Minimum Schleppzeiger bleibt immer am kleinsten Wert stehen bis neu 
//initialisiert wird (Init=TURE)
//Am ENO-Ausgang liegt Siganl TRUE, wenn der Schleppzeiger einen neuen Wert 
//erhält. Hier zählt Z1 somit, wie oft der Schleppzeiger einen neuen Wert erhält
      U(    ; 
      U     M      0.0; 
      =     L      1.0; 
      BLD   103; 
      U     M    240.0; 
      =     L      1.1; 
      BLD   103; 
      CALL "m7b_SchleppZeiger_INT" (
           iValue                   := #Value1,
           cfgMinMax                := L      1.0,
           Init                     := L      1.1,
           SchleppZeiger            := #SLP_MIN);
      U     BIE; 
      )     ; 
      ZV    Z      1; 
      BLD   101; 
      U     M    240.0; 
      L     C#0; 
      S     Z      1; 
      NOP   0; 
      NOP   0; 
      LC    Z      1; 
      T     #SLP_COUNT; 
      NOP   0; 
NETWORK
TITLE =Schleppzeiger größter Wert
//Der Maximum Schleppzeiger bleibt immer am größten Wert stehen bis neu 
//initialisiert wird (Init=TURE)
//Am ENO-Ausgang liegt Siganl TRUE, wenn der Schleppzeiger einen neuen Wert 
//erhält.
//Hier wird bei einem neuen Wert fuer den Schleppzeicher somit nur NEW_VALUE=True 
//
      U     M      0.1; 
      =     L      1.0; 
      BLD   103; 
      U     M    240.0; 
      =     L      1.1; 
      BLD   103; 
      CALL "m7b_SchleppZeiger_INT" (
           iValue                   := #Value1,
           cfgMinMax                := L      1.0,
           Init                     := L      1.1,
           SchleppZeiger            := #SLP_MIN);
      U     BIE; 
      =     #NEW_VALUE; 
NETWORK
TITLE =

END_FUNCTION_BLOCK

FUNCTION_BLOCK "REGLER_TAKT"
TITLE =Aufrufmerker für Regler erzeugen
//Erezeugen der jeweils um 1 Zykluszeit versetzten Aufruftakte für die Regler
//200ms / 500ms / 1s / 2s in den Merkern 110.0 bis 111.7
//jeweils 4 versetzte Merker jeder Aufrufzeit
AUTHOR : 'S.Maag'
VERSION : 0.1


VAR_OUTPUT
  TaktByte1 : BYTE ;	//Taktbyte1: 200ms/500ms
  TaktByte2 : BYTE ;	//Taktbyte2: 1s/2s
  DSP_T_CYCLE : TIME ;	//Zykluszeit CPU
  DSP_TD_200ms : TIME ;	//Zeitdifferenz letzter 200ms Aufruf
  DSP_TD_500ms : TIME ;	//Zeitdifferenz letzter 500ms Aufruf
  DSP_TD_1s : TIME ;	//Zeitdifferenz letzter 1s Aufruf
  DSP_TD_2s : TIME ;	//Zeitdifferenz letzter 2s Aufruf
END_VAR
VAR
  HM_FP_200 : BOOL ;	
  HM_FP_500 : BOOL ;	
  HM_FP_1s : BOOL ;	
  HM_FP_2s : BOOL ;	
  HM_START_2s : BOOL ;	
  HM_1s_activ : BOOL ;	
  mem_T_200 : TIME ;	
  mem_T_500 : TIME ;	
  mem_T_1s : TIME ;	
  mem_T_2s : TIME ;	
  mem_T_CYCLE : TIME ;	
  T_200ms_1v4 : BOOL ;	
  T_200ms_2v4 : BOOL ;	
  T_200ms_3v4 : BOOL ;	
  T_200ms_4v4 : BOOL ;	
  T_500ms_1v4 : BOOL ;	
  T_500ms_2v4 : BOOL ;	
  T_500ms_3v4 : BOOL ;	
  T_500ms_4v4 : BOOL ;	
  T_1s_1v4 : BOOL ;	
  T_1s_2v4 : BOOL ;	
  T_1s_3v4 : BOOL ;	
  T_1s_4v4 : BOOL ;	
  T_2s_1v4 : BOOL ;	
  T_2s_2v4 : BOOL ;	
  T_2s_3v4 : BOOL ;	
  T_2s_4v4 : BOOL ;	
END_VAR
VAR_TEMP
  SysTime : TIME ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =TAKT Regler 200ms 4/4
//======================================================================
//                      TAKTE 200Ms
//======================================================================
      U     #T_200ms_3v4; 
      =     #T_200ms_4v4; 
NETWORK
TITLE =TAKT Regler 200ms 3/4

      U     #T_200ms_2v4; 
      S     #T_200ms_3v4; 
      U     #T_200ms_4v4; 
      R     #T_200ms_3v4; 
      NOP   0; 
NETWORK
TITLE =TAKT Regler 200ms 2/4

      U     #T_200ms_1v4; 
      S     #T_200ms_2v4; 
      U     #T_200ms_3v4; 
      R     #T_200ms_2v4; 
      NOP   0; 
NETWORK
TITLE =TAKT Regler 200ms 1/4

      U     M    100.1; 
      FP    #HM_FP_200; 
      S     #T_200ms_1v4; 
      U     #T_200ms_2v4; 
      R     #T_200ms_1v4; 
      NOP   0; 
NETWORK
TITLE =TAKT Regler 500ms 4/4
//======================================================================
//                      TAKTE 500Ms
//======================================================================
      U     #T_500ms_3v4; 
      =     #T_500ms_4v4; 
NETWORK
TITLE =TAKT Regler 500ms 3/4

      U     #T_500ms_2v4; 
      S     #T_500ms_3v4; 
      U     #T_500ms_4v4; 
      R     #T_500ms_3v4; 
      NOP   0; 
NETWORK
TITLE =TAKT Regler 500ms 2/4

      U     #T_500ms_1v4; 
      S     #T_500ms_2v4; 
      U     #T_500ms_3v4; 
      R     #T_500ms_2v4; 
      NOP   0; 
NETWORK
TITLE =TAKT Regler 500ms 1/4

      U     M    100.3; 
      FP    #HM_FP_500; 
      S     #T_500ms_1v4; 
      U     #T_500ms_2v4; 
      R     #T_500ms_1v4; 
      NOP   0; 
NETWORK
TITLE =TAKT Regler 1s 4/4
//======================================================================
//                      TAKTE 1s
//======================================================================
      U     #T_1s_3v4; 
      =     #T_1s_4v4; 
NETWORK
TITLE =TAKT Regler 1s 3/4

      U     #T_1s_2v4; 
      S     #T_1s_3v4; 
      U     #T_1s_4v4; 
      R     #T_1s_3v4; 
      NOP   0; 
NETWORK
TITLE =TAKT Regler 1s 2/4

      U     #T_1s_1v4; 
      S     #T_1s_2v4; 
      U     #T_1s_3v4; 
      R     #T_1s_2v4; 
      NOP   0; 
NETWORK
TITLE =TAKT Regler 1s 1/4

      U     M    100.5; 
      FP    #HM_FP_1s; 
      S     #T_1s_1v4; 
      U     #T_1s_2v4; 
      R     #T_1s_1v4; 
      NOP   0; 
NETWORK
TITLE =TAKT Regler 2s 3/4

      O     #T_1s_1v4; 
      O     #T_1s_2v4; 
      O     #T_1s_3v4; 
      O     #T_1s_4v4; 
      =     #HM_1s_activ; 
NETWORK
TITLE =TAKT Regler 2s 4/4
//======================================================================
//                      TAKTE 2s
//======================================================================
      U     #T_2s_3v4; 
      =     #T_2s_4v4; 
NETWORK
TITLE =TAKT Regler 2s 3/4

      U     #T_2s_2v4; 
      S     #T_2s_3v4; 
      U     #T_2s_4v4; 
      R     #T_2s_3v4; 
      NOP   0; 
NETWORK
TITLE =TAKT Regler 2s 2/4

      U     #T_2s_1v4; 
      S     #T_2s_2v4; 
      U     #T_2s_3v4; 
      R     #T_2s_2v4; 
      NOP   0; 
NETWORK
TITLE =HM Start Takt 2s
//Takt 2s versetzt zu den 1s Takten starten
      U     M    100.7; 
      FP    #HM_FP_2s; 
      S     #HM_START_2s; 
NETWORK
TITLE =TAKT Regler 2s 1/4
//2s Regeleraufrufe starten versetzt zu den 1s Aufrufen,
//deshalb Flanke des 2s Taktes in HM_START_2s merken und wenn
//keine 1s Takt mehr aktiv, dann 2s Takt starten
      U     #HM_START_2s; 
      UN    #HM_1s_activ; 
      S     #T_2s_1v4; 
      U     #T_2s_2v4; 
      R     #T_2s_1v4; 
      U     #T_2s_1v4; 
      R     #HM_START_2s; 
NETWORK
TITLE =Taktbyte 1
//ACHTUNG: indirektes kopieren der Daten von Multiinstanzen über Pointer
//ist nur mit Berücksichtigung des absoluten Instanz-Pointers möglich, da 
//die P#-Funktion von Step7 den Pointer nur relativ zu den Daten der aktuelen 
//Instanz ermittelt. Dieser relative Pointer muss zum Instanzpointer aus AR2 
//addiert werden.
      L     P##T_200ms_1v4; 
      UD    DW#16#FFFFFF; // Bereichskennung ausblenden, sonst Additionsfehler
      TAR2  ; // load akku with instance pointer
      +D    ; // add instance and relative data pointer
      LAR1  ; // load it into AR1
      L     B [AR1,P#0.0]; // load the 8 BOOL outputs as complete byte
      T     #TaktByte1; 

NETWORK
TITLE =Taktbyte 2
//ACHTUNG: indirektes kopieren der Daten von Multiinstanzen über Pointer
//ist nur mit Berücksichtigung des absoluten Instanz-Pointers möglich, da 
//die P#-Funktion von Step7 den Pointer nur relativ zu den Daten der aktuelen 
//Instanz ermittelt. Dieser relative Pointer muss zum Instanzpointer aus AR2 
//addiert werden.
      L     P##T_1s_1v4; 
      UD    DW#16#FFFFFF; // Bereichskennung ausblenden, sonst Additionsfehler
      TAR2  ; // load akku with instance pointer
      +D    ; // add instance and relative data pointer
      LAR1  ; // load it into AR1
      L     B [AR1,P#0.0]; // load the 8 BOOL outputs as complete byte
      T     #TaktByte2; 

NETWORK
TITLE =aktuelle Systemzeit


      CALL "TIME_TCK" (
           RET_VAL                  := #SysTime);
      NOP   0; 
NETWORK
TITLE =Tatsächlicher Zyklus 200ms Takt

      UN    #T_200ms_1v4; 
      SPB   ne19; 
      L     #mem_T_200; 
      L     #SysTime; 
      T     #mem_T_200; 
      UC    "m7b_ABS_DIFF_S7SysTime"; 
      T     #DSP_TD_200ms; 
ne19: NOP   0; 
NETWORK
TITLE =Tatsächlicher Zyklus 500ms Takt

      UN    #T_500ms_1v4; 
      SPB   ne20; 
      L     #mem_T_500; 
      L     #SysTime; 
      T     #mem_T_500; 
      UC    "m7b_ABS_DIFF_S7SysTime"; 
      T     #DSP_TD_500ms; 
ne20: NOP   0; 
NETWORK
TITLE =Tatsächlicher Zyklus 1s Takt

      UN    #T_1s_1v4; 
      SPB   ne21; 
      L     #mem_T_1s; 
      L     #SysTime; 
      T     #mem_T_1s; 
      UC    "m7b_ABS_DIFF_S7SysTime"; 
      T     #DSP_TD_1s; 
ne21: NOP   0; 
NETWORK
TITLE =Tatsächlicher Zyklus 2s Takt

      UN    #T_2s_1v4; 
      SPB   ne22; 
      L     #mem_T_2s; 
      L     #SysTime; 
      T     #mem_T_2s; 
      UC    "m7b_ABS_DIFF_S7SysTime"; 
      T     #DSP_TD_2s; 
ne22: NOP   0; 
NETWORK
TITLE =Zylkluszeit CPU

      L     #mem_T_CYCLE; 
      L     #SysTime; 
      T     #mem_T_CYCLE; 
      UC    "m7b_ABS_DIFF_S7SysTime"; 
      T     #DSP_T_CYCLE; 

NETWORK
TITLE =

      SET   ; 
      SAVE  ; 
      CLR   ; 

END_FUNCTION_BLOCK

FUNCTION "m7a_ABS_DIFF_DINT" : VOID
TITLE =Berechnet den Absolutwert der Differenz: ABS (Akku2 - Akku1)
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 4/2003
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1

BEGIN
NETWORK
TITLE =

      -D    ; // Differenz bilden
      SPP   NWE; // Wenn positiv dann ENDE
      NEGD  ; // Vorzeichen ändern
NWE:  NOP   0; 

END_FUNCTION

FUNCTION "m7a_MinMaxLimit_REAL" : VOID
TITLE =Min/Max Begrenzung REAL; Begrenzungsanzeige im BIE-Bit / FC-ENO
//Min- Max- Begrenzung für REAL mit Begrenzungsanzeige
//
//BIE bzw. FC-ENO : 0 = Wert war ok       : Begrenzung nicht aktiv
//                  1 = Wert war nicht ok.: Begrenzung aktiv
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 7/2004
//INTERNET: www.maagic7.de
//
//VERWENDUNG:
//Begrenzung eines Wertes auf den Min- Max- Bereich bei gleichzeitiger 
//Weiterverarbeitung des Begrenzungssignals am FC-ENO-Ausgang z.B. zur Warn- bzw.
//Störungsanzeige oder zur direkten Weiterverschaltung.
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  min : REAL ;	//minimal Wert
  max : REAL ;	//maximal Wert
END_VAR
VAR_IN_OUT
  VALUE : REAL ;	//Sollwert
END_VAR
BEGIN
NETWORK
TITLE =MIN <= VALUE <= MAX

      L     #VALUE; // Sollwert
      L     #min; // minimal Wert
      <R    ; 
      SPB   LIM; // Limitierung wenn VALUE < MIN
      TAK   ; // VALUE wieder in Akku 1
      L     #max; // Maximalwert
      >R    ; 
      SPB   LIM; // Limitierung wenn VALUE > MAX

      CLR   ; // VKE löschen, da keine Begrenzung erfolgte
      SAVE  ; // BIE-Bit = 0, da Wert im Bereich war; ="Keine Begrenzung"
      BEA   ; 

LIM:  T     #VALUE; // max.Wert als Sollwert ausgeben
      SET   ; 
      SAVE  ; // VKE->BIE (=1=): Anzeige FC-ENO Ausgang (=Begrenzung)
      CLR   ; 

END_FUNCTION

FUNCTION "m7a_MinMaxOK_REAL" : VOID
TITLE =Wert zwischen Min und Max? MIN <= VALUE <= MAX
//Prüft ob der IST-Wert zwischen MIN & MAX liegt
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 9/2004
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  VALUE : REAL ;	//Zu prüfender Wert
  MIN : REAL ;	//Zulässiger Minimalwert
  MAX : REAL ;	//Zulässiger Maximalwert
END_VAR
VAR_OUTPUT
  OK : BOOL ;	//Wert im Toleranzbereich
END_VAR
BEGIN
NETWORK
TITLE =

      L     #MIN; // minmal zulässiger Wert
      L     #VALUE; 
      >R    ; // falls MIN > VALUE
      SPB   NOK; // dann nicht ok
      L     #MAX; 
      >R    ; // falls VALUE > MAX
      SPB   NOK; // dann nicht ok
      =     #OK; // sonst ok
      SAVE  ; 
      BEA   ; 
NOK:  CLR   ; // Wert nicht ok
      =     #OK; 
      SAVE  ; 


END_FUNCTION

FUNCTION "m7b_HandAuto" : VOID
TITLE =Standardfunktion zur Betriebsartenumschaltung Hand/Auto
//Betriebsartenumschaltung Hand/Auto mit Impuls/Ereignis-Ausgang, für beide 
//Umschaltrichtungen. Die Ereignis-Ausgänge können dazu verwendet werden, um z.B. 
//bei Betriebsartenumschaltung die Schrittabläufe zu löschen. 
//Bei jeder Umschaltung wird am FC-ENO-Ausgang ein Impuls (1 Zyklus) ausgegeben.
//
//Es kann sowohl über die Hand- Auto- Tasteneingänge umgeschaltet werden, als auch
// 
//über den ModeSelect Eingang. Wied über die Tasteneingänge umgeschaltet, so wird 
//der dadruch gewählte Mode auf den ModeSelect_Eingang (I/O) zurückgeschrieben. 
//Somit wird gewährleistet, daß sowohl an einem OP über eine Auswahlliste 
//umgeschaltet werden kann als auch über Tastendruck.
//
//Wird eine Umschaltung mit dem ModeSelect Eingang nicht benötigt, können auf den 
//Hand- Auto- Tasteneingängen auch Schalter angeschlossen werden.
//
//Werden die Tasteneingänge nicht benötigt, dann mit logisch_0 beschalten
//
//VERWENDUNG: Umschaltung Hand/Auto
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 6/2004
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//12/2004    S.Maag     ModeSelect-Eingang für Umschaltung über OP eingefügt
//08/2005    S.Maag     Events bei Verwendung von Schaltern waren dauernd 1
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  S_HAND : BOOL ;	//Schalter/Taste Hand
  S_AUTO : BOOL ;	//Schalter/Taste Auto
END_VAR
VAR_OUTPUT
  HAND : BOOL ;	//Ausgang Betriebsart Hand
  AUTO : BOOL ;	//Ausgang Betriebsart Auto
  evt_HAND : BOOL ;	//Ereignis/Flanke auf Hand wurde umgeschaltet
  evt_AUTO : BOOL ;	//Ereignis/Flanke auf Automatik wurde umgeschaltet
  DSP_MODE : INT ;	//Anzeige Betriebsart 0=Hand, 1=Auto
END_VAR
VAR_IN_OUT
  S_SOFTWARE : INT ;	//Auswahl Betriebsart über Softwareschalter, z.B. von einem OP
  bTemp : BYTE ;	
END_VAR
VAR_TEMP
  lbAuto : BOOL ;	//Lokaler Speicher Automatik
  lbHand : BOOL ;	//Lokaler Speicher Hand
  lbFPAuto : BOOL ;	//Lokaler Speicher Flanke Auto (EventAuto)
  lbFPHand : BOOL ;	//Lokaler Speicher Flanke Hand (EventHand)
  lbLastModeAuto : BOOL ;	//Lokaler Speicher letzter Mode war Auto
  lbAktModeAuto : BOOL ;	//Lokaler Speicher aktueller Mode ist Auto
  lb6 : BOOL ;	//Lokaler Speicher 
  lb7 : BOOL ;	//Lokaler Speicher 
END_VAR
BEGIN
NETWORK
TITLE =Dauerhaften Zwischenspeicher in Lokaldatenbereich

      L     #bTemp; 
      T     LB     0; 
      NOP   0; 
NETWORK
TITLE =Aktuell gewählter Mode ist Auto

      L     #S_SOFTWARE; // Mode_Select Eingang, z.B. Auswahlfeld von OP
      L     1; 
      ==I   ; 
      =     #lbAktModeAuto; // 0=Hand, 1=Auto

NETWORK
TITLE =Betriebsartenwahl

      U     #S_HAND; // Eingang Hand, hat vorrang vor Auto
      SPB   HAND; 

      U     #lbLastModeAuto; // letzter gewählter Mode war Auto
      UN    #lbAktModeAuto; // aktuell gewählter Mode ist Hand
      SPB   HAND; // auf Hand umschalten

      U     #S_AUTO; // Eingang Taste Auto
      SPB   AUTO; 

      UN    #lbLastModeAuto; // letzter gewählter Mode war Hand
      U     #lbAktModeAuto; // aktuell gewählter Mode ist Auto
      SPB   AUTO; // auf Auto umschalten

      O     #lbHand; // wenn bereits eine Betriebsart
      O     #lbAuto; // ausgewählt, dann NWE, sonst HAND
      SPB   NE4; 

HAND: S     #lbHand; // Handmerker einschalten
      R     #lbAuto; // Automatikmerker ausschalten

      L     0; // Hand auf ModeSelect-Eingang schreiben 
      T     #S_SOFTWARE; 
      SPA   NE4; 

AUTO: R     #lbHand; // Handmerker ausschalten
      S     #lbAuto; // Automatikmerker einschalten

      L     1; // Auto auf ModeSelect-Eingang schreiben
      T     #S_SOFTWARE; 
NE4:  NOP   0; 
NETWORK
TITLE =letzte Betriebsart über ModeSelect, speichern
//wird für die Umschalteauswertung des ModeSelect-Eingangs benötigt
      L     1; 
      L     #S_SOFTWARE; 
      ==I   ; 
      =     #lbLastModeAuto; 
NETWORK
TITLE =Ereignis: Es wurde auf Automatik umgeschaltet

      U     #lbAuto; 
      FP    #lbFPAuto; 
      =     #evt_AUTO; 
NETWORK
TITLE =Ereignis: Es wurde auf Hand umgeschaltet

      U     #lbHand; 
      FP    #lbFPHand; 
      =     #evt_HAND; 
NETWORK
TITLE =Ausgang Betriebsart Auto

      U     #lbAuto; // lokale Speichervaribale für Auto
      =     #AUTO; // FC-Ausgang Auto
NETWORK
TITLE =Ausgang Betriebsart Hand

      U     #lbHand; // lokale Speichervaribale für Hand
      =     #HAND; // FC-Ausgang Hand
NETWORK
TITLE =Lokalen Speicher wieder in dauerhaften Zwischenspeicher 

      L     LB     0; 
      T     #bTemp; 
      NOP   0; 
NETWORK
TITLE =Anzeigeausgang Betriebsart

      L     1; 
      U     #lbAuto; 
      SPB   SAVE; 
      L     0; 
SAVE: T     #DSP_MODE; 
NETWORK
TITLE =FC-ENO Ausgang, bei jedem Umschaltvorgang 1 Impuls

      O     #evt_HAND; 
      O     #evt_AUTO; 
      SAVE  ; 
      CLR   ; 

END_FUNCTION

FUNCTION "m7b_HandAuto_VorOrt" : VOID
TITLE =Standardfunktion zur Betriebsartenumschaltung Hand/Auto
//Betriebsartenumschaltung Hand/Auto mit Impuls/Ereignis-Ausgang, für beide 
//Umschaltrichtungen. Die Ereignis-Ausgänge können dazu verwendet werden, um z.B. 
//bei Betriebsartenumschaltung die Schrittabläufe zu löschen. 
//Bei jeder Umschaltung wird am FC-ENO-Ausgang ein Impuls (1 Zyklus) ausgegeben.
//
//Es kann sowohl über die Hand- Auto- Tasteneingänge umgeschaltet werden, als auch
// 
//über den ModeSelect Eingang. Wird über die Tasteneingänge umgeschaltet, so wird 
//der dadruch gewählte Mode auf den ModeSelect_Eingang (I/O) zurückgeschrieben. 
//Somit wird gewährleistet, daß sowohl an einem OP über eine Auswahlliste 
//umgeschaltet werden kann als auch über Tastendruck.
//
//Wird eine Umschaltung mit dem ModeSelect Eingang nicht benötigt, können auf den 
//Hand- Auto- Tasteneingängen auch Schalter angeschlossen werden.
//
//Werden die Tasteneingänge nicht benötigt, dann mit logisch_0 beschalten
//
//VERWENDUNG: Umschaltung Hand/Auto
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 6/2004
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//12/2004    S.Maag     ModeSelect-Eingang für Umschaltung über OP eingefügt
//09/2005    S.Maag     Events bei Verwendung von Schaltern waren dauernd 1
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  S_HAND : BOOL ;	//Schalter/Taste Hand
  S_AUTO : BOOL ;	//Schalter/Taste Auto
  S_VorOrt : BOOL ;	//Schalter Vor-Ort-Steuerung
END_VAR
VAR_OUTPUT
  HAND : BOOL ;	//Ausgang Betriebsart Hand
  AUTO : BOOL ;	//Ausgang Betriebsart Auto
  evt_HAND : BOOL ;	//Ereignis/Flanke auf Hand wurde umgeschaltet
  evt_AUTO : BOOL ;	//Ereignis/Flanke auf Automatik wurde umgeschaltet
  DSP_MODE : INT ;	//Anzeige Betriebsart 0=Hand, 1=Auto
END_VAR
VAR_IN_OUT
  S_SOFTWARE : INT ;	//Auswahl Betriebsart über Softwareschalter, z.B. von einem OP
  bTemp : BYTE ;	
END_VAR
VAR_TEMP
  lbAuto : BOOL ;	//Lokaler Speicher Automatik
  lbHand : BOOL ;	//Lokaler Speicher Hand
  lbFPAuto : BOOL ;	//Lokaler Speicher Flanke Auto (EventAuto)
  lbFPHand : BOOL ;	//Lokaler Speicher Flanke Hand (EventHand)
  lbLastModeAuto : BOOL ;	//Lokaler Speicher letzter Mode war Auto
  lbAktModeAuto : BOOL ;	//Lokaler Speicher aktueller Mode ist Auto
  lb6 : BOOL ;	//Lokaler Speicher 
  lb7 : BOOL ;	//Lokaler Speicher
END_VAR
BEGIN
NETWORK
TITLE =Dauerhaften Zwischenspeicher in Lokaldatenbereich

      L     #bTemp; 
      T     LB     0; 
      NOP   0; 
NETWORK
TITLE =Aktuell gewählter Mode ist Auto

      L     #S_SOFTWARE; // Mode_Select Eingang, z.B. Auswahlfeld von OP
      L     1; 
      ==I   ; 
      =     #lbAktModeAuto; // 0=Hand, 1=Auto

NETWORK
TITLE =Betriebsartenwahl

      U     #S_VorOrt; // Schalter Vor-Ort-Bedienung
      UN    #lbHand; // Hand noch nicht aktiv
      SPB   VORT; // Umschalten auf Vor-Ort-Hand

      U     #S_VorOrt; // Vor-Ort-Bedienung hat Vorrang
      SPB   NE4; 

      U     #S_HAND; // Eingang Hand, hat Vorrang vor Auto
      UN    #lbHand; // Hand noch nicht aktiv
      SPB   HAND; 

      U     #lbLastModeAuto; // letzter gewählter Mode war Auto
      UN    #lbAktModeAuto; // aktuell gewählter Mode ist Hand
      SPB   HAND; // auf Hand umschalten

      U     #S_AUTO; // Eingang Taste Auto
      UN    #S_HAND; // Handschalter ist aus
      UN    #S_VorOrt; // Vor-Ort-Schalter ist aus
      UN    #lbAuto; // Auto noch nicht aktiv
      SPB   AUTO; 

      UN    #lbLastModeAuto; // letzter gewählter Mode war Hand
      U     #lbAktModeAuto; // aktuell gewählter Mode ist Auto
      SPB   AUTO; // auf Auto umschalten

      O     #lbHand; // wenn bereits eine Betriebsart
      O     #lbAuto; // ausgewählt, dann NWE, sonst HAND
      SPB   NE4; 

VORT: S     #lbHand; // Handmerker einschalten
      R     #lbAuto; // Automatikmerker ausschalten
      SPA   NE4; 

HAND: S     #lbHand; // Handmerker einschalten
      R     #lbAuto; // Automatikmerker ausschalten

      L     0; // Hand auf ModeSelect-Eingang schreiben 
      T     #S_SOFTWARE; 
      SPA   NE4; 

AUTO: R     #lbHand; // Handmerker ausschalten
      S     #lbAuto; // Automatikmerker einschalten

      L     1; // Auto auf ModeSelect-Eingang schreiben
      T     #S_SOFTWARE; 
NE4:  NOP   0; 
NETWORK
TITLE =letzte Betriebsart über ModeSelect, speichern
//Die Verknüpfung 
//
//UN #S_VorOrt 
//
//ist dafür verantwortlich daß nach Wegnahme des VorOrt-Bediensignals wieder nach 
//Automatik zurückggeschaltet wird, sofern Auto vor Anwahl der Vor-Ort-Bedienung 
//aktiv war. Dies geschieht dadurch, daß zwar der Softwareschalter in seinem 
//ursprünglichem Zustand bleibt, das Meldesignal #lbLastModeAuto jedoch LOW wird. 
//Dadurch wird bei Abschalten von S_VorOrt ein neuer Zustand des 
//Softwareschalters 
//erkannt und wieder nach Automatik geschaltet.
// 
      U(    ; 
      L     1; 
      L     #S_SOFTWARE; 
      ==I   ; 
      )     ; 
      UN    #S_VorOrt; 
      =     #lbLastModeAuto; 
NETWORK
TITLE =Ereignis: Es wurde auf Automatik umgeschaltet

      U     #lbAuto; 
      FP    #lbFPAuto; 
      =     #evt_AUTO; 
NETWORK
TITLE =Ereignis: Es wurde auf Hand umgeschaltet

      U     #lbHand; 
      FP    #lbFPHand; 
      =     #evt_HAND; 
NETWORK
TITLE =Ausgang Betriebsart Auto

      U     #lbAuto; // lokale Speichervaribale für Auto
      =     #AUTO; // FC-Ausgang Auto
NETWORK
TITLE =Ausgang Betriebsart Hand

      U     #lbHand; // lokale Speichervaribale für Hand
      =     #HAND; // FC-Ausgang Hand
NETWORK
TITLE =Lokalen Speicher wieder in dauerhaften Zwischenspeicher 

      L     LB     0; 
      T     #bTemp; 
      NOP   0; 
NETWORK
TITLE =Anzeigeausgang Betriebsart

      L     2; 
      U     #S_VorOrt; 
      SPB   SAVE; 
      L     1; 
      U     #lbAuto; 
      SPB   SAVE; 
      L     0; 
SAVE: T     #DSP_MODE; 
NETWORK
TITLE =FC-ENO Ausgang, bei jedem Umschaltvorgang 1 Impuls

      O     #evt_HAND; 
      O     #evt_AUTO; 
      SAVE  ; 
      CLR   ; 

END_FUNCTION

FUNCTION "m7b_MultiSwitchEx" : VOID
TITLE =cMultiSwitchEx, Multifunktions Schalter
//Multifunktioneller Schalter mit mehreren Schaltfunktionseingängen.
//Es kann wahlweise über AUS- und EIN- Taste oder über eine einzelne AUS/EIN 
//Taste sowie über einen Softwareschalter vom OP/PC geschaltet werden. Alle 
//Schaltfunktionen sind parallel anwendbar. Bei einer Schaltstellungsänderung 
//wird der Softwareschalter automatisch angepaßt.
//
//Verwendung: Schalten von unterschiedlichen Stellen mit unterschiedlichen 
//            Schaltfunktionen.
//
//S_AUS     : Taste ausschalten
//S_EIN     : Taste einschalten
//S_FLANKE  : Flankeneingang, Flanke eines Tasters für Stromstoßfunktion.
//            Die Flankenauswertung muß unbedingt außerhalb des FC erfolgen.
//            Wird die Funktion nicht benötigt, dann mit Logisch 0 beschalten.
//FRG_SOFT  : Freigabe für Softwareschalter. Hiermit kann der Softwareschalter 
//            z.B. bei Vor-Ort-Bedienung gesperrt werden.
//S_SOFTWARE: Schalterwert 0/1 von einem Softwareschalter, z.B. OP oder 
//            Visualisierung
//
//RETURN of UserAction ON/OFF with Processor StatusFlags A1 A0
//U >0
//= UserActionOn  // Switched ON by S_SOFTWARE (HMI UserAction)
//U <0
//= UserActionOff  // Switched OFF by S_SOFTWARE (HMI UserAction)
//
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 12/2004
//INTERNET: www.maagic7.de / www.maagic.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME      AENDERUNG
//--------------------------------------------------------------------------------
//07.07.2017   S.Maag    Abfrage auf UserAction ON/OFF hinzugefügt
//                       Nach Aufruf des FC kann über die Befehle
//                       U >0  // auf UserActionON (Ein über S_SOFTWARE)
//                       U <0  // auf UserActionOFF (Aus über S_SOFTWARE)
//                       abgefragt werden.
//
//02.09.2008   S.Maag    Istzustand des des Schalter auf Softwareschalter
//                       übertragen, wenn FRG Softwareschalter = FALSE
//                       Sprungmarke 'IST'   
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  S_AUS : BOOL ;	//Eingang für AUS-Taster
  S_EIN : BOOL ;	//Eingang für EIN-Taster
  S_FLANKE : BOOL ;	//Eingang Umschaltflanke, für Stromstoßfunktion
  FRG_SOFT : BOOL ;	//Freigabe für Softwareschalter
END_VAR
VAR_IN_OUT
  S_SOFTWARE : INT ;	//Softwareschalter
  Q : BOOL ;	//Schaltausgang
END_VAR
VAR_TEMP
  memSTW : DWORD ;	//Statuswort Bit0..7 in LB3, A0:=L3.6 A1:=L3.7
  SoftSwitchON : BOOL ;	//Softwareschalter ist auf EIN
  UserActionON : BOOL ;	
  UserActionOFF : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =Stellung des Softwareschalters prüfen

      L     #S_SOFTWARE; // Wert des Softwareschalters
      L     1; 
      ==I   ; 
      =     #SoftSwitchON; // Softwareschalter steht auf EIN

      CLR   ; 
      =     #UserActionON; 
      =     #UserActionOFF; 
NETWORK
TITLE =Auswertung der verschiedenen Schaltfunktionen

      U     #S_AUS; // Eingang für asschalten; hat immer Vorrang
      SPB   AUS; 

      U     #S_EIN; // Eingang für einschalten
      SPB   EIN; 

      U     #S_FLANKE; // Positive Flanke am Puls-Taster-Eingang
      SPB   INV; // Schaltzustand invertieren

      UN    #FRG_SOFT; // Wenn keine Freigabe für den Softwareschalter,
      SPB   IST; // dann Ende

      U     #Q; // Wenn Schaltausgang = AUS
      UN    #SoftSwitchON; // und Softwareschalter = EIN
      S     #UserActionOFF; 
      SPB   AUS; // dann wurde über Softwareschalter ausgeschaltet

      UN    #Q; // Wenn Schaltausgang = AUS
      U     #SoftSwitchON; // und Softwareschalter = EIN
      S     #UserActionON; 
      SPB   EIN; // dann wurde über Softwareschalter eingeschaltet
      SPA   NE2; 

INV:  UN    #Q; // INV: Ausgang invertieren
      SPB   EIN; // Wenn Q=0, dann einschalten
      SPA   AUS; // Wenn Q=1, dann ausschalten

EIN:  S     #Q; // Schaltausgang setzen
      L     1; // Softwareschalter auf 1
      SPA   SAVE; 

AUS:  R     #Q; // Schaltausgang löschen
      L     0; // Softwareschalter auf 0
      SPA   SAVE; 

IST:  L     1; // Wert Schalter EIN 
      U     #Q; // Schalter ist EIN
      SPB   SAVE; // speichern
      L     0; // Wert Schalter AUS

SAVE: T     #S_SOFTWARE; // Softwareschalter schreiben
NE2:  NOP   0; 
NETWORK
TITLE =UserAction => A1/A0; >0 : UserAction ON; <0 : UserActionOff
//UserAction nach Statuswort STW A0/A1; mit folgenden Befehlen nach Aufruf von
//MultiSwitchEx kann abgefragt werden, ob über den Softwareschalter 
//(= HMI UserAction) geschaltet wurde. 
//
//U >0
//= UserActionON  // User switched ON (SoftSwitcht)
//U <0
//= UserActionOff // User switched OFF
//
//U ==0   // hat keine Aussagekraft (spez. auf externe Schaltaktion) 
//
//Dies wird manchmal benötigt, um zwischen den externen Schalteingängen und 
//UserOperationen (=Bedienung des Softwareschalters zu unterscheiden
//
//S7 Statuswort STW Flags (32Bit)
//     LB 0..2                LB 3
//Bit: 31..9    8    7   6   5   4   3    2    1    0
//         0  BIE   A1  A0  OV  OS  OR  STA  VKE  /ER
//
//Bedeutung der StatusFlags
//A1  A0  
// 1   0    >0    :  U >0
// 0   1    <0    :  U <0
// 0   0   ==0    :  U ==0
//
      CLR   ; 
      L     STW; // Statuswort in Akku laden
      T     #memSTW; // STW => TEMP-STACK LB0

      U     #UserActionOFF; // UserActionOFF => A0; Abfrage U <0
      =     L      3.6; // = A0
      U     #UserActionON; // UserActionON => A1; Abfrage U >0
      =     L      3.7; // = A1

      L     #memSTW; 
      T     STW; 
NETWORK
TITLE =FC-ENO-Ausgang = Schaltausgang, für direkte FC-Verknüfpung

      U     #Q; // Schaltsignal
      SAVE  ; // auf FC-ENO-Ausgang geben
      CLR   ; 
END_FUNCTION

FUNCTION "m7b_TriStateSwitch2" : VOID
TITLE =cTriStateSwitch, 3-Stellungs-Schaltfunktion
//TriState Schaltfunktion
//Es kann wahlweise über OFF, SET_A und SET_B oder über einen einzelnen  
//Taster sowie über einen Softwareschalter vom OP/PC geschaltet werden. Alle 
//Schaltfunktionen sind parallel anwendbar. Bei einer Schaltstellungsänderung 
//wird der Softwareschalter automatisch angepaßt.
//Eine Flanke am Tasteingang S_PULS schaltet jeweils immer um einen Zustand weiter
//0-A-0-A
//
//Verwendung: Schalten von unterschiedlichen Stellen mit unterschiedlichen 
//            Schaltfunktionen.
//
//Hinweis   : die SET-Eingänge haben Vorrang vor S_PULS und Softwareschalter    
//[IN]
//OFF       : 1 an diesem Eingang Schaltet A und B aus - höchste Priotiätät
//SET_A     : Schaltet um auf den Zustand 1: A=1, B=0
//SET_B     : Schaltet um auf den Zustand 2: A=0, B=1
//S_PULS    : Tasteingang für Stromstoßfunktion
//            Wird die Funktion nicht benötigt, dann mit Logisch 0 beschalten.
//            Bei positiver Flanke an diesem Eingang wird jeweils um einen
//            Zustand weitergeschaltet. Schaltfunktion abhängig von cfg_S_PULS: 
//cfg_SPuls_NoStop: FALSE: 0-A-0-B-0
//                  TRUE:  0-A-B-0           
// 
//FRG_SOFT  : Freigabe für Softwareschalter. Hiermit kann der Softwareschalter 
//            z.B. bei Vor-Ort-Bedienung gesperrt werden. Es wird nur die 
//            Umschaltfunktion des Softwareschalters gesperrt. Die aktuelle
//            Schaltstellung wird weiterhin angezeigt.
//
//[IN_OUT]
//S_SOFT    : Softwareschalter im INT-Format
//bTmp      : Hilfbyte für Zustandsspeicherung
//
//S_SOFT    : Softwareschalter 0/1/2 eines Softwareschalter, 
//            z.B. von OP, Visualisierung
//            0 : A=0, B=0
//            1 : A=1, B=0
//            2 : A=0, B=1
//[OUT]
//A         : Ausgang Schaltzustand 1
//B         : Ausgang Schaltzustand 2
//
//FC_ENO    : Ausgang ist 1, wenn A oder B = 1 ist
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 02/2006
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME      AENDERUNG
//--------------------------------------------------------------------------------
//17.10.2014   S.Maag    Konfigurationseingang für Schaltfunktion cfg_SPuls_NoStop
//                       bei TRUE entfällt der Stop-Schritt nach jedem Tastendruck
//                       es wird direkt die andere Richtung geschaltet.
//                       => Bessere Eignung des Bausteins für 5/2 Impulsventile  
//
//03.12.2008   S.Maag    Zustände Q1+Q2 umbenannt nach A & B, da so auch die
//                       Ansteuerspulen von Ventilen benannt sind.
//
//19.09.2008   S.Maag    Istzustand des des Schalter auf Softwareschalter
//                       übertragen, wenn FRG Softwareschalter = FALSE
//                       Sprungmarke 'IST'   
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 2.0


VAR_INPUT
  OFF : BOOL ;	//Eingang für Ausschalter
  SET_A : BOOL ;	//Eingang für Zustand 1 einschalten
  SET_B : BOOL ;	//Eingang für Zustand 2 einschalten
  S_PULS : BOOL ;	//Eingang Taster für Stromstoßfunktion
  cfg_SPuls_NoStop : BOOL ;	//Config.: S_PULS: FALSE: 0-A-0-B-0; TRUE: A-B-A-...
  FRG_SOFT : BOOL ;	//Freigabe für Softwareschalter
END_VAR
VAR_OUTPUT
  A : BOOL ;	//State 1
  B : BOOL ;	//State 2
END_VAR
VAR_IN_OUT
  S_SOFT : INT ;	//Softwareschalter
  bTmp : BYTE ;	
END_VAR
VAR_TEMP
  lb_A : BOOL ;	//Lokaler Speicher: Ausgang B
  lb_B : BOOL ;	//Lokaler Speicher: Ausgang B
  lb_FP_TASTER : BOOL ;	//Lokaler Speicher: Flankenmerker Eingang Taster
  lb_LAST_STATE_B : BOOL ;	//Lokaler Speicher: letzter Ein-Zustand war B
  lb4 : BOOL ;	//Lokaler Speicher
  lb5 : BOOL ;	//Lokaler Speicher
  lb6 : BOOL ;	//Lokaler Speicher 
  lb7 : BOOL ;	//Lokaler Speicher
  SOFT_STATE_A : BOOL ;	//Softwareschalter ist auf Zustand A
  SOFT_STATE_B : BOOL ;	//Softwareschalter ist auf Zustand B
  FP_TASTER : BOOL ;	//Positive Flanke Eingangstaster
END_VAR
BEGIN
NETWORK
TITLE =Dauerhaften Zwischenspeicher in Lokaldatenbereich

      L     #bTmp; 
      T     LB     0; 
      NOP   0; 
NETWORK
TITLE =Flankenauswertung Taster

      U     #S_PULS; 
      FP    #lb_FP_TASTER; 
      =     #FP_TASTER; 

NETWORK
TITLE =Stellung des Softwareschalters ist A

      L     #S_SOFT; // Wert des Softwareschalters
      L     1; 
      ==I   ; 
      =     #SOFT_STATE_A; // Softwareschalter steht auf State 1

NETWORK
TITLE =Stellung des Softwareschalters ist B

      L     #S_SOFT; // Wert des Softwareschalters
      L     2; 
      ==I   ; 
      =     #SOFT_STATE_B; // Softwareschalter steht auf State 2

NETWORK
TITLE =Auswertung der verschiedenen Schaltfunktionen

      U     #OFF; // Eingang für ausschalten; hat immer Vorrang
      SPB   OFF; 

      U     #SET_A; // wenn beide Zustände gleichzeitig 
      U     #SET_B; // gesetzt werden sollen, dann aus
      SPB   OFF; 

      U     #SET_A; // Eingang Zustand 1 setzen
      SPB   S1; // Zustand 1

      U     #SET_B; // Eingang Zustand 2 setzen
      SPB   S2; // Zustand 2

      U     #FP_TASTER; // Positive Flanke Tasteingang
      U     #SOFT_STATE_A; // Zustand 1 aktiv
      UN    #cfg_SPuls_NoStop; // Konfiguration 'ohne 0-Stellung' (ohne Stop)
      SPB   OFF; // dann nächster Zustand OFF

      U     #FP_TASTER; // Positive Flanke Tasteingang
      U     #SOFT_STATE_B; // Zustand 2 aktiv
      UN    #cfg_SPuls_NoStop; // Konfiguration 'ohne 0-Stellung' (ohne Stop)
      SPB   OFF; // dann nächster Zustand OFF

      U     #FP_TASTER; // Positive Flanke Tasteingang
      U     #lb_LAST_STATE_B; // letzter aktiver Zustand war S2
      SPB   S1; // dann S1 aktivieren

      U     #FP_TASTER; // Positive Flanke Tasteingang
      UN    #lb_LAST_STATE_B; // letzter aktiver Zustand war S1
      SPB   S2; // dann S2 aktivieren

      UN    #FRG_SOFT; // Wenn keine Freigabe für den Softwareschalter,
      SPB   IST; // dann Istzustand in Softwareschalter schreiben

      UN    #lb_A; // Wenn Schaltausgang 1 AUS
      U     #SOFT_STATE_A; // und Softwareschalter Zustand 1 angewählt
      SPB   S1; // dann Zustand 1 aktivieren

      UN    #lb_B; // Wenn Schaltausgang 2 = AUS
      U     #SOFT_STATE_B; // und Softwareschalter Zustand 2 angewählt
      SPB   S2; // dann Zustand 2 aktivieren

      UN    #SOFT_STATE_A; // Softwareschalter Zustand 1 nicht angewählt
      UN    #SOFT_STATE_B; // Softwareschalter Zustand 2 nicht angewählt
      SPB   OFF; // dann OFF
      SPA   NE3; 

S1:   S     #lb_A; // Schaltausgang 1 setzen
      R     #lb_B; // Schaltausgang 2 löschen
      R     #lb_LAST_STATE_B; // letzter aktiver Zustand war S2 löschen
      L     1; // Softwareschalter auf 1
      SPA   SAVE; 

S2:   R     #lb_A; // Schaltausgang 1 löschen
      S     #lb_B; // Schaltausgang 2 setzen
      S     #lb_LAST_STATE_B; // letzter aktiver Zustand war S2 (merken)
      L     2; // Softwareschalter auf 2
      SPA   SAVE; 

OFF:  R     #lb_A; // Schaltausgang 1 löschen
      R     #lb_B; // Schaltausgang 2 löschen
      L     0; // Softwareschalter auf 0
      SPA   SAVE; 

IST:  L     1; 
      U     #lb_A; // Ausgang 1 ist aktiv: State 1
      SPB   SAVE; 
      L     2; 
      U     #lb_B; // Ausgang 2 ist aktiv: State 2
      SPB   SAVE; 
      L     0; 

SAVE: T     #S_SOFT; // Softwareschalter schreiben
NE3:  NOP   0; 
NETWORK
TITLE =FC-Ausgang A

      U     #lb_A; 
      =     #A; 
NETWORK
TITLE =FC-Ausgang B

      U     #lb_B; 
      =     #B; 
NETWORK
TITLE =FC-ENO-Ausgang = Schaltausgang, für direkte FC-Verknüfpung

      O     #lb_A; // Ausgang 1
      O     #lb_B; // Ausgang 2
      SAVE  ; // auf FC-ENO-Ausgang geben
      CLR   ; 

NETWORK
TITLE =Lokalen Speicher wieder in dauerhaften Zwischenspeicher 

      L     LB     0; 
      T     #bTmp; 
      NOP   0; 
END_FUNCTION

FUNCTION "m7b_TriStateSwitchEx2" : VOID
TITLE =cTriStateSwitchEx, erweiterte 3-Stellungs-Schaltfunktion
//erweiterte TriState Schaltfunktion: bessere Eignung zur Ansteuerung von Luft- 
//und Hydraulikzylinderm mit 3-Wege-Ventil, da zusätzliche Eingänge: Limit 
//(Endstellung) vorhanden sind. 
//
//Es kann wahlweise über OFF, SET_A und SET_B oder über einen einzelnen  
//Taster sowie über einen Softwareschalter vom OP/PC geschaltet werden. Alle 
//Schaltfunktionen sind parallel anwendbar. Bei einer Schaltstellungsänderung 
//wird der Softwareschalter automatisch angepaßt.
//Eine Flanke am Tasteingang S_PULS schaltet jeweils immer um einen Zustand weiter
//0-A-0-B
//
//Verwendung: Schalten von unterschiedlichen Stellen mit unterschiedlichen 
//            Schaltfunktionen. Z.B. Hydraulik- und Pneumatikzylinder
//
//Hinweis   : die SET-Eingänge haben Vorrang vor S_PULS und Softwareschalter      
// 
//[IN]     
//OFF       : 1 an diesem Eingang Schaltet A und B aus - höchste Priotiätät
//SET_A     : Schaltet um auf den Zustand 1: A=1, B=0
//SET_B     : Schaltet um auf den Zustand 2: A=0, B=1
//S_PULS    : Tasteingang für Stromstoßfunktion
//            Wird die Funktion nicht benötigt, dann mit Logisch 0 beschalten.
//            Bei positiver Flanke an diesem Eingang wird jeweils um einen
//            Zustand weitergeschaltet: 0 - A - 0 - B
//LIM_A     : Limit bzw. Endstellung für Zustand 1 erreicht (=> ausschalten)
//LIM_B     : Limit bzw. Endstellung für Zustand 2 erreicht (=> ausschalten) 
//cfg_SPuls_NoStop : FALSE: 0-A-0-B-0
//                   TRUE:  0-A-B-A...  
//FRG_SOFT  : Freigabe für Softwareschalter. Hiermit kann der Softwareschalter 
//            z.B. bei Vor-Ort-Bedienung gesperrt werden. Es wird nur die 
//            Umschaltfunktion des Softwareschalters gesperrt. Die aktuelle
//            Schaltstellung wird weiterhin angezeigt.
//
//[IN_OUT]
//S_SOFT    : Softwareschalter im INT-Format
//bTmp      : Hilfbyte für Zustandsspeicherung
//
//S_SOFT    : Softwareschalter 0/1/2 eines Softwareschalter, 
//            z.B. von OP, Visualisierung
//            0 : A=0, B=0
//            1 : A=1, B=0
//            2 : A=0, B=1
//[OUT]
//A         : Ausgang Schaltzustand 1
//B         : Ausgang Schaltzustand 2
//
//FC_ENO    : Ausgang ist 1, wenn A oder B = 1 ist
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 02/2006
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME      AENDERUNG
//--------------------------------------------------------------------------------
//17.10.2014   S.Maag    Konfigurationseingang LIM_ON für Aktivierung der 
//                       Eingänge LIM_A und LIM_B entfällt. Funktion wird besser
//                       über Verschaltung mit FALSE von LIM_A LIM_B erreicht-
//
//                       Dafür cfg_SPuls_NoStop eingeführt
//                       bei TRUE entfällt der Stop-Schritt nach jedem Tastendruck
//                       es wird direkt die andere Richtung geschaltet.
//                       => Bessere Eignung des Bausteins für 5/2 Impulsventile   
//
//03.12.2008   S.Maag    Zustände Q1+Q2 umbenannt nach A & B, da so auch die
//                       Spulen an Ventilen benannt sind.
//
//19.09.2008   S.Maag    Istzustand des des Schalter auf Softwareschalter
//                       übertragen, wenn FRG Softwareschalter = FALSE
//                       Sprungmarke 'IST'   
// 
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 2.0


VAR_INPUT
  OFF : BOOL ;	//Eingang für Ausschalter
  SET_A : BOOL ;	//Eingang für Zustand 1 einschalten
  SET_B : BOOL ;	//Eingang für Zustand 2 einschalten
  S_PULS : BOOL ;	//Eingang Taster für Stromstoßfunktion
  LIM_A : BOOL ;	//Limit für Zustand 1 erreicht
  LIM_B : BOOL ;	//Limit für Zustand 2 erreicht
  cfg_PULS_NoStop : BOOL ;	//Config.: S_PULS: FALSE: 0-A-0-B-0; TRUE: A-B-A-...
  FRG_SOFT : BOOL ;	//Freigabe für Softwareschalter
END_VAR
VAR_OUTPUT
  A : BOOL ;	//State 1
  B : BOOL ;	//State 2
END_VAR
VAR_IN_OUT
  S_SOFT : INT ;	//Softwareschalter
  bTmp : BYTE ;	
END_VAR
VAR_TEMP
  lb_A : BOOL ;	//Lokaler Speicher: Ausgang A
  lb_B : BOOL ;	//Lokaler Speicher: Ausgang B
  lb_FP_TASTER : BOOL ;	//Lokaler Speicher: Flankenmerker Eingang Taster
  lb_LAST_STATE_B : BOOL ;	//Lokaler Speicher: letzter Ein-Zustand war B
  lb4 : BOOL ;	//Lokaler Speicher
  lb5 : BOOL ;	//Lokaler Speicher
  lb6 : BOOL ;	//Lokaler Speicher 
  lb7 : BOOL ;	//Lokaler Speicher
  SOFT_STATE_A : BOOL ;	//Softwareschalter ist auf Zustand A
  SOFT_STATE_B : BOOL ;	//Softwareschalter ist auf Zustand B
  FP_TASTER : BOOL ;	//Positive Flanke Eingangstaster
END_VAR
BEGIN
NETWORK
TITLE =Dauerhaften Zwischenspeicher in Lokaldatenbereich

      L     #bTmp; 
      T     LB     0; 
      NOP   0; 
NETWORK
TITLE =Flankenauswertung Taster

      U     #S_PULS; // Eingang Taster
      FP    #lb_FP_TASTER; // Flankenauswertung
      =     #FP_TASTER; // Flanke (Impuls)

NETWORK
TITLE =Stellung des Softwareschalters ist 1

      L     #S_SOFT; // Wert des Softwareschalters
      L     1; 
      ==I   ; 
      =     #SOFT_STATE_A; // Softwareschalter steht auf State 1

NETWORK
TITLE =Stellung des Softwareschalters ist 2

      L     #S_SOFT; // Wert des Softwareschalters
      L     2; 
      ==I   ; 
      =     #SOFT_STATE_B; // Softwareschalter steht auf State 2

NETWORK
TITLE =Auswertung der verschiedenen Schaltfunktionen

// vorrangige Auschaltbedingungen
      U     #OFF; // Eingang für asschalten; hat immer Vorrang
      SPB   OFF; 

      U     #SET_A; // wenn beide Zustände gleichzeitig 
      U     #SET_B; // gesetzt werden sollen, dann aus
      SPB   OFF; 

      U     #lb_A; // Zustand 1 aktiv
      U     #LIM_A; // Limit bzw. Endstellung für Zustand 1
      SPB   OFF; // dann OFF

      U     #lb_B; // Zustand 2 aktiv
      U     #LIM_B; // Limit bzw. Endstellung für Zustand 2
      SPB   OFF; // dann OFF

// direkte SET-Eingänge für Zustände
      U     #SET_A; // Eingang Zustand 1 setzen
      SPB   S1; // Zustand 1

      U     #SET_B; // Eingang Zustand 2 setzen
      SPB   S2; // Zustand 2

// Taster
      U     #FP_TASTER; // Positive Flanke Tasteingang
      U     #SOFT_STATE_A; // Zustand 1 aktiv
      UN    #cfg_PULS_NoStop; // Konfiguration 'ohne 0-Stellung' (ohne Stop)
      SPB   OFF; // dann nächster Zustand OFF

      U     #FP_TASTER; // Positive Flanke Tasteingang
      U     #SOFT_STATE_B; // Zustand 2 aktiv
      UN    #cfg_PULS_NoStop; // Konfiguration 'ohne 0-Stellung' (ohne Stop)
      SPB   OFF; // dann nächster Zustand OFF

      O     #lb_LAST_STATE_B; // letzter aktiver Zustand war S2
      O     #LIM_B; // Wenn Zustand 2 in Endstellung ist
      U     #FP_TASTER; // Positive Flanke Tasteingang
      UN    #LIM_A; 
      SPB   S1; // dann S1 aktivieren

      ON    #lb_LAST_STATE_B; // letzter aktiver Zustand war S1
      O     #LIM_A; // Wenn Zustand 1 in Endstellung ist
      U     #FP_TASTER; // Positive Flanke Tasteingang
      UN    #LIM_B; 
      SPB   S2; // dann S2 aktivieren

// SoftwareSchalter
      UN    #FRG_SOFT; // Wenn keine Freigabe für den Softwareschalter,
      SPB   IST; // dann Istzustand in Softwareschalter schreiben

      UN    #lb_A; // Wenn Schaltausgang 1 AUS
      U     #SOFT_STATE_A; // und Softwareschalter Zustand 1 angewählt
      SPB   S1; // dann Zustand 1 aktivieren

      UN    #lb_B; // Wenn Schaltausgang 2 = AUS
      U     #SOFT_STATE_B; // und Softwareschalter Zustand 2 angewählt
      SPB   S2; // dann Zustand 2 aktivieren

      UN    #SOFT_STATE_A; // Softwareschalter Zustand 1 nicht angewählt
      UN    #SOFT_STATE_B; // Softwareschalter Zustand 2 nicht angewählt
      SPB   OFF; // dann OFF
      SPA   NE3; 

S1:   U     #LIM_A; // Limit bzw. Endstellung Zustand 1
      SPB   OFF; // OFF
      S     #lb_A; // Schaltausgang 1 setzen
      R     #lb_B; // Schaltausgang 2 löschen
      R     #lb_LAST_STATE_B; // letzter aktiver Zustand war S2 löschen
      L     1; // Softwareschalter auf 1
      SPA   SAVE; 

S2:   U     #LIM_B; // Limit bzw. Endstellung Zustand 2
      SPB   OFF; // OFF
      R     #lb_A; // Schaltausgang 1 löschen
      S     #lb_B; // Schaltausgang 2 setzen
      S     #lb_LAST_STATE_B; // letzter aktiver Zustand war S2 (merken)
      L     2; // Softwareschalter auf 2
      SPA   SAVE; 

OFF:  R     #lb_A; // Schaltausgang 1 löschen
      R     #lb_B; // Schaltausgang 2 löschen
      L     0; // Softwareschalter auf 0
      SPA   SAVE; 

IST:  L     1; 
      U     #lb_A; // Ausgang 1 ist aktiv: State 1
      SPB   SAVE; 
      L     2; 
      U     #lb_B; // Ausgang 2 ist aktiv: State 2
      SPB   SAVE; 
      L     0; 

SAVE: T     #S_SOFT; // Softwareschalter schreiben
NE3:  NOP   0; 
NETWORK
TITLE =FC-Ausgang A

      U     #lb_A; 
      =     #A; 
NETWORK
TITLE =FC-Ausgang B

      U     #lb_B; 
      =     #B; 
NETWORK
TITLE =FC-ENO-Ausgang = Schaltausgang, für direkte FC-Verknüfpung

      O     #lb_A; // Ausgang 1
      O     #lb_B; // Ausgang 2
      SAVE  ; // auf FC-ENO-Ausgang geben
      CLR   ; 
NETWORK
TITLE =Lokalen Speicher wieder in dauerhaften Zwischenspeicher 

      L     LB     0; 
      T     #bTmp; 
      NOP   0; 
END_FUNCTION

FUNCTION "m7b_PROG_SWITCH_8x" : VOID
TITLE =Programmunschaltung für 8 Programme
//Umschaltung zwischen 8 verschiedenen Programmen. Ausgabe des aktuellen 
//Programms als Nr. und Bit.
//
//[OUT]
//EVT_SWITCH : Dieser Ausgang wird bei Programmumschaltung einen Zyklus lang HIGH
//             Der FC-ENO-Ausgang enthält gleiches Signal
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2005
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  FRG : BOOL ;	//Umschaltfreigabe
  PROG : INT ;	//angewählte Programmnummer
END_VAR
VAR_OUTPUT
  P0 : BOOL ;	
  P1 : BOOL ;	
  P2 : BOOL ;	
  P3 : BOOL ;	
  P4 : BOOL ;	
  P5 : BOOL ;	
  P6 : BOOL ;	
  P7 : BOOL ;	
  EVT_SWITCH : BOOL ;	//Ereignisausgang Programmumschaltung
END_VAR
VAR_IN_OUT
  PrgAktiv : INT ;	//Aktive Programmnummer
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =

      L     #PROG; // gewähltes Programm
      L     #PrgAktiv; // aktives Programm
      ==I   ; // Wenn gleich,
      SPB   NO; // dann keine Umschaltung

      UN    #FRG; // keine Umschaltfreigabe
      SPB   NO; // dann keine Umschaltung

      SPA   SWTC; // Programmumschaltung bearbeiten

NO:   CLR   ; 
      SAVE  ; 
      =     #EVT_SWITCH; // Umschaltereignis
      SPA   BITS; // Programmausgangsbits bearbeiten

// Programmumschaltung
SWTC: L     #PROG; // gewähltes Programm
      T     #PrgAktiv; // als letztes Programm speichern
      SET   ; 
      SAVE  ; 
      =     #EVT_SWITCH; // Umschaltereignis

NETWORK
TITLE =Programmausgangsbits zuerst alle löschen 
//dies muß sein, da bei einem FC die Ausgänge bei jedem Aufruf immer eindeutig 
//zugewiesen werden müssen.
BITS: CLR   ; 
      =     #P0; 
      =     #P1; 
      =     #P2; 
      =     #P3; 
      =     #P4; 
      =     #P5; 
      =     #P6; 
      =     #P7; 

NETWORK
TITLE =Programmausgangsbits setzen

      SET   ; 
      L     #PrgAktiv; // Programmnummer
      SPL   AUS; // Sprungziel bei PRG > max
      SPA   P0; // Programm 0
      SPA   P1; // Programm 1
      SPA   P2; 
      SPA   P3; 
      SPA   P4; 
      SPA   P5; 
      SPA   P6; 
      SPA   P7; 

AUS:  CLR   ; // kein Programm aktiv
      BEA   ; 
P0:   S     #P0; // Programm 0
      BEA   ; 
P1:   S     #P1; // Programm 1
      BEA   ; 
P2:   S     #P2; // Programm 2
      BEA   ; 
P3:   S     #P3; // Programm 3
      BEA   ; 
P4:   S     #P4; // Programm 4
      BEA   ; 
P5:   S     #P5; // Programm 5
      BEA   ; 
P6:   S     #P6; // Programm 6
      BEA   ; 
P7:   S     #P7; // Programm 7


END_FUNCTION

FUNCTION "m7b_4xEINVERTEIL_BIT_OUT" : VOID
TITLE =4-fach Einschaltverteiler für große Lasten
//Dieser Baustein verhindert, daß Ausgänge für große Lasten gleichzeitig 
//geschaltet werden. Zu einem Zeitpunkt ist somit immer nur ein Einschaltvorgang 
//erlaubt, das senkt Stromspitzen. Die anderen evtl. anstehenden 
//Einschaltvorgänge werden nacheinander mit der Verzögerung der übergebenen Zeit 
//erledigt.
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 2/2004
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  IN1 : BOOL ;	
  IN2 : BOOL ;	
  IN3 : BOOL ;	
  IN4 : BOOL ;	
  Zeit : TIME ;	//Zeitbegrenzung für Gleichzeitige Zuschaltung: z.B. T#5s
END_VAR
VAR_OUTPUT
  OUT1 : BOOL ;	
  OUT2 : BOOL ;	
  OUT3 : BOOL ;	
  OUT4 : BOOL ;	
END_VAR
VAR_IN_OUT
  tTmpTime : TIME ;	//Temporärer HilfsSpeicher, hier werden Zeitwerte zwischengespeichert
  bTEMP : BYTE ;	//Temporärer HilfsSpeicher
END_VAR
VAR_TEMP
  lbOUT1 : BOOL ;	//Lokaler Speicher Ausgang 1
  lbOUT2 : BOOL ;	//Lokaler Speicher Ausgang 2
  lbOUT3 : BOOL ;	//Lokaler Speicher Ausgang 3
  lbOUT4 : BOOL ;	//Lokaler Speicher Ausgang 4
  res_B04 : BOOL ;	//ACHTUNG: ReserveBit, nicht löschen
  res_B05 : BOOL ;	//ACHTUNG: ReserveBit, nicht löschen
  res_B06 : BOOL ;	//ACHTUNG: ReserveBit, nicht löschen
  res_B07 : BOOL ;	//ACHTUNG: ReserveBit, nicht löschen
  aktSysTime : TIME ;	//aktuelle SystemZeit
  wait : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =statisches Hilfsbyte in Bitadressierbaren Lokalbereich kopieren

      L     #bTEMP; 
      T     LB     0; 
      NOP   0; 

NETWORK
TITLE =Zeit seit letztem Einschaltvorgang prüfen

      CALL "TIME_TCK" (
           RET_VAL                  := #aktSysTime);

      L     #aktSysTime; 
      L     #tTmpTime; 
      UC    "m7b_ABS_DIFF_S7SysTime"; // Absolute Differenz S7SytemTimer 31Bit
      L     #Zeit; 
      <D    ; 
      =     #wait; // Warten bis Einschaltverz. abgelaufen

NETWORK
TITLE =Einschalten

      U     #wait; // Wenn warten mit Einschalten, dann überspringen
      SPB   NE3; 

      U     #IN1; 
      UN    #lbOUT1; 
      S     #lbOUT1; 
      SPB   ZEIT; 

      U     #IN2; 
      UN    #lbOUT2; 
      S     #lbOUT2; 
      SPB   ZEIT; 

      U     #IN3; 
      UN    #lbOUT3; 
      S     #lbOUT3; 
      SPB   ZEIT; 

      U     #IN4; 
      UN    #lbOUT4; 
      S     #lbOUT4; 
      SPB   ZEIT; 

      SPA   NE3; 

ZEIT: CALL "TIME_TCK" (// Zeit beim letzten Einschaltvorgang speichern
           RET_VAL                  := #tTmpTime);

NE3:  NOP   0; 

NETWORK
TITLE =Ausschalten

      UN    #IN1; 
      R     #lbOUT1; 

      UN    #IN2; 
      R     #lbOUT2; 

      UN    #IN3; 
      R     #lbOUT3; 

      UN    #IN4; 
      R     #lbOUT4; 

NETWORK
TITLE =Ausgänge 1 bis 4 ausgeben

      U     #lbOUT1; 
      =     #OUT1; 

      U     #lbOUT2; 
      =     #OUT2; 

      U     #lbOUT3; 
      =     #OUT3; 

      U     #lbOUT4; 
      =     #OUT4; 

NETWORK
TITLE =Bits wieder in statisches HilfsByte zurückkopieren

      L     LB     0; 
      T     #bTEMP; 
      NOP   0; 

NETWORK
TITLE =Enable Ausgang des Bausteins
//Dies dient der Anzeige im SPS-Status. Der Baustein wird mit High-Signal 
//angezeigt, wenn Einschalten erlaubt, bei Wartezeit mit Low-Signal
      UN    #wait; 
      SAVE  ; 
      CLR   ; 

END_FUNCTION

FUNCTION "m7b_8xLastSchaltVert" : VOID
TITLE =8-fach Ein-/Ausschaltverteiler für große Lasten
//Dieser Baustein verhindert, daß Ausgänge für große Lasten gleichzeitig 
//geschaltet werden. Zu einem Zeitpunkt ist somit immer nur ein 
//Ein-/Ausschaltvorgang erlaubt, das senkt Stromspitzen. Die anderen evtl. 
//anstehenden Schaltvorgänge werden nacheinander mit der Verzögerung der 
//übergebenen Zeit erledigt. Ist die Funktion durch überbabe von T#0ms as 
//Verzögerungszeit abgeschaltet, so schalten die Ausgänge je einen SPS Zyklus 
//nacheinander durch.
//ACHTUNG: bei aktiver Funktion (T > 0ms) ist immer nur 1 Schaltvorgang zu einem 
//         Zeitpunkt erlaubt. D.h. nach einem Einschaltvorgang kann erst nach
//         abgelaufener Zeit auch wieder ein Ausschaltvorgang nach Ablauf von
//        (timOffDelay) erfolgen.
//
//[IN)
//IN1..8 : Anforderungen EIN
//timOnDelay : Zeitdifferenz Einschaltvorgänge
//timOffDelay: Zeitdifferenz Ausschaltvorgänge
//
//[OUT]
//OUT1..8 : Schaltkontakte für Lasten
//
//[INOUT]
//memTime : externer statischer Hilfsspeicher für Zeitwert
//memByte : externer statischer Hilfsspeicher für Bytewert
//
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 2/2004
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//02.08.2013   S.Maag      Von Einschaltverzögerung auf Ein-/Ausschaltverz.
//                         erweitert. Separate Zeit für Ein-/Aus-Verzögerung
//
//05.09.2013   S.Maag      Begrenzung für max. Anzahl eingeschalteter Geräte
//                         hinzugefügt. IN: iMaxOn
//
//03.12.2013   S.Maag      Zeitdifferenzberechnung der S7SystemZeit mit FC256
//                         wegen Überlauffehler durch 31Bit S7-SystemTimer
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 2.0


VAR_INPUT
  IN1 : BOOL ;	
  IN2 : BOOL ;	
  IN3 : BOOL ;	
  IN4 : BOOL ;	
  IN5 : BOOL ;	
  IN6 : BOOL ;	
  IN7 : BOOL ;	
  IN8 : BOOL ;	
  timOnDelay : TIME ;	//Zeitdifferenz für Zuschaltung: z.B. T#10s; Funktion AUS bei 0ms
  timOffDelay : TIME ;	//Zeitdifferenz für Abschaltung: z.B. T#5s; Funktion AUS bei 0ms
  iMaxON : INT ;	//Maximal erlaubte Anzahl Eingeschalteter Geräte
END_VAR
VAR_OUTPUT
  OUT1 : BOOL ;	
  OUT2 : BOOL ;	
  OUT3 : BOOL ;	
  OUT4 : BOOL ;	
  OUT5 : BOOL ;	
  OUT6 : BOOL ;	
  OUT7 : BOOL ;	
  OUT8 : BOOL ;	
END_VAR
VAR_IN_OUT
  memTime : TIME ;	//statischer HilfsSpeicher, hier werden Zeitwerte zwischengespeichert
  memByte : BYTE ;	//statischer HilfsSpeicher
END_VAR
VAR_TEMP
  lbOUT1 : BOOL ;	//Lokaler Speicher Ausgang 1
  lbOUT2 : BOOL ;	//Lokaler Speicher Ausgang 2
  lbOUT3 : BOOL ;	//Lokaler Speicher Ausgang 3
  lbOUT4 : BOOL ;	//Lokaler Speicher Ausgang 4
  lbOUT5 : BOOL ;	//Lokaler Speicher Ausgang 5
  lbOUT6 : BOOL ;	//Lokaler Speicher Ausgang 6
  lbOUT7 : BOOL ;	//Lokaler Speicher Ausgang 7
  lbOUT8 : BOOL ;	//Lokaler Speicher Ausgang 8
  aktSysTime : TIME ;	//aktuelle SystemZeit
  waitON : BOOL ;	
  waitOFF : BOOL ;	
  iBitCount : INT ;	
  MaxNoIsOn : BOOL ;	//Maximalanzahl an Geräten ist EIN
  MoreAreOn : BOOL ;	//Mehr als die maximale Zahl ist EIN
END_VAR
BEGIN
NETWORK
TITLE =statisches Hilfsbyte in Bitadressierbaren Lokalbereich kopieren

      L     #memByte; 
      T     LB     0; 
      NOP   0; 

NETWORK
TITLE =Anzahl HI-Bits, Anzahl eingeschalteter Geräte
//05.09.2013 S.Maag
//Anzahl freigegebener Geräte für Begrenzung der max. Anzahl
      L     0; 
      UN    #lbOUT1; 
      SPB   b2; 
      INC   1; 
b2:   UN    #lbOUT2; 
      SPB   b3; 
      INC   1; 
b3:   UN    #lbOUT3; 
      SPB   b4; 
      INC   1; 
b4:   UN    #lbOUT4; 
      SPB   b5; 
      INC   1; 
b5:   UN    #lbOUT5; 
      SPB   b6; 
      INC   1; 
b6:   UN    #lbOUT6; 
      SPB   b7; 
      INC   1; 
b7:   UN    #lbOUT7; 
      SPB   b8; 
      INC   1; 
b8:   UN    #lbOUT8; 
      SPB   b9; 
      INC   1; 
b9:   T     #iBitCount; 

NETWORK
TITLE =Maximale Anzahl oder mehr Geräte sind EIN
//05.09.2013 S.Maag
//max Anzahl freigegebener Geräte ist erreicht bzw. überschritten.
//Für Limittierung auf Max. Anzahl
      L     #iBitCount; 
      L     #iMaxON; 
      >=I   ; 
      =     #MaxNoIsOn; 
      >I    ; 
      =     #MoreAreOn; 
NETWORK
TITLE =Zeit seit letztem Schaltvorgang prüfen

      CALL "TIME_TCK" (
           RET_VAL                  := #aktSysTime);

      L     #aktSysTime; 
      L     #memTime; 
      UC    "m7b_ABS_DIFF_S7SysTime"; 
      L     #timOnDelay; 
      <D    ; 
      =     #waitON; // Warten bis Einschaltverz. abgelaufen

      TAK   ; // Differenz wieder in AKKU1 zurück
      L     #timOffDelay; 
      <D    ; 
      =     #waitOFF; 
NETWORK
TITLE =Einschalten
//Einschaltreihenfolge von 1..8
      O     #waitON; // Wenn warten mit Einschalten, dann überspringen
      O     #MaxNoIsOn; // maximale Anzahl bereits eingeschaltet
      SPB   NE3; 

      U     #IN1; 
      UN    #lbOUT1; 
      S     #lbOUT1; 
      SPB   TON; 

      U     #IN2; 
      UN    #lbOUT2; 
      S     #lbOUT2; 
      SPB   TON; 

      U     #IN3; 
      UN    #lbOUT3; 
      UN    #MaxNoIsOn; 
      S     #lbOUT3; 
      SPB   TON; 

      U     #IN4; 
      UN    #lbOUT4; 
      S     #lbOUT4; 
      SPB   TON; 

      U     #IN5; 
      UN    #lbOUT5; 
      S     #lbOUT5; 
      SPB   TON; 

      U     #IN6; 
      UN    #lbOUT6; 
      S     #lbOUT6; 
      SPB   TON; 

      U     #IN7; 
      UN    #lbOUT7; 
      S     #lbOUT7; 
      SPB   TON; 

      U     #IN8; 
      UN    #lbOUT8; 
      S     #lbOUT8; 
      SPB   TON; 

      SPA   NE3; 

TON:  CALL "TIME_TCK" (// Zeit beim letzten Einschaltvorgang speichern
           RET_VAL                  := #memTime);

NE3:  NOP   0; 

NETWORK
TITLE =Ausschalten
//Ausschaltreihenfolge: 8..1
      U     #waitOFF; // Wenn warten mit Einschalten, dann überspringen
      SPB   NE4; 

      ON    #IN8; 
      O     #MoreAreOn; 
      U     #lbOUT8; 
      R     #lbOUT8; 
      SPB   TOF; 

      ON    #IN7; 
      O     #MoreAreOn; 
      U     #lbOUT7; 
      R     #lbOUT7; 
      SPB   TOF; 

      ON    #IN6; 
      O     #MoreAreOn; 
      U     #lbOUT6; 
      R     #lbOUT6; 
      SPB   TOF; 

      ON    #IN5; 
      O     #MoreAreOn; 
      U     #lbOUT5; 
      R     #lbOUT5; 
      SPB   TOF; 

      ON    #IN4; 
      O     #MoreAreOn; 
      U     #lbOUT4; 
      R     #lbOUT4; 
      SPB   TOF; 

      ON    #IN3; 
      O     #MoreAreOn; 
      U     #lbOUT3; 
      R     #lbOUT3; 
      SPB   TOF; 

      ON    #IN2; 
      O     #MoreAreOn; 
      U     #lbOUT2; 
      R     #lbOUT2; 
      SPB   TOF; 

      ON    #IN1; 
      O     #MoreAreOn; 
      U     #lbOUT1; 
      R     #lbOUT1; 
      SPB   TOF; 
      SPA   NE4; 

TOF:  CALL "TIME_TCK" (// Zeit beim letzten Schaltvorgang speichern
           RET_VAL                  := #memTime);

NE4:  NOP   0; 

NETWORK
TITLE =Ausgänge 1 bis 8 ausgeben

      U     #lbOUT1; 
      =     #OUT1; 

      U     #lbOUT2; 
      =     #OUT2; 

      U     #lbOUT3; 
      =     #OUT3; 

      U     #lbOUT4; 
      =     #OUT4; 

      U     #lbOUT5; 
      =     #OUT5; 

      U     #lbOUT6; 
      =     #OUT6; 

      U     #lbOUT7; 
      =     #OUT7; 

      U     #lbOUT8; 
      =     #OUT8; 

NETWORK
TITLE =Bits wieder in statisches HilfsByte zurückkopieren

      L     LB     0; 
      T     #memByte; 
      NOP   0; 

NETWORK
TITLE =Enable Ausgang des Bausteins
//Dies dient der Anzeige im SPS-Status. Der Baustein wird mit High-Signal 
//angezeigt, wenn Einschalten erlaubt, bei Wartezeit mit Low-Signal
      UN    #waitON; 
      UN    #waitOFF; 
      SAVE  ; 
      CLR   ; 

END_FUNCTION

FUNCTION "m7b_BCD_TO_SEDECIMAL" : VOID
TITLE =4-Bit BCD zu Sedezimal, Codierer
//Codiert 4-Bit BCD zu Sedezimal, d.h. es wird immer nur einer von 10 möglichen 
//Ausgängen geschaltet. Dieser Ausgang wird über das 4-Bit BCD-Signal angewählt.
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 1/2005
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  BCD0 : BOOL ;	
  BCD1 : BOOL ;	
  BCD2 : BOOL ;	
  BCD3 : BOOL ;	
END_VAR
VAR_OUTPUT
  Q0 : BOOL ;	
  Q1 : BOOL ;	
  Q2 : BOOL ;	
  Q3 : BOOL ;	
  Q4 : BOOL ;	
  Q5 : BOOL ;	
  Q6 : BOOL ;	
  Q7 : BOOL ;	
  Q8 : BOOL ;	
  Q9 : BOOL ;	
END_VAR
VAR_TEMP
  BCD : BYTE ;	
END_VAR
BEGIN
NETWORK
TITLE =Ausgang Q0


      UN    #BCD3; 
      UN    #BCD2; 
      UN    #BCD1; 
      UN    #BCD0; 
      =     #Q0; 
NETWORK
TITLE =Ausgang Q1

      UN    #BCD3; 
      UN    #BCD2; 
      UN    #BCD1; 
      U     #BCD0; 
      =     #Q1; 
NETWORK
TITLE =Ausgang Q2

      UN    #BCD3; 
      UN    #BCD2; 
      U     #BCD1; 
      UN    #BCD0; 
      =     #Q2; 
NETWORK
TITLE =Ausgang Q3

      UN    #BCD3; 
      UN    #BCD2; 
      U     #BCD1; 
      U     #BCD0; 
      =     #Q3; 
NETWORK
TITLE =Ausgang Q4

      UN    #BCD3; 
      U     #BCD2; 
      UN    #BCD1; 
      UN    #BCD0; 
      =     #Q4; 
NETWORK
TITLE =Ausgang Q5

      UN    #BCD3; 
      U     #BCD2; 
      UN    #BCD1; 
      U     #BCD0; 
      =     #Q5; 
NETWORK
TITLE =Ausgang Q6

      UN    #BCD3; 
      U     #BCD2; 
      U     #BCD1; 
      UN    #BCD0; 
      =     #Q6; 
NETWORK
TITLE =Ausgang Q7

      UN    #BCD3; 
      U     #BCD2; 
      U     #BCD1; 
      U     #BCD0; 
      =     #Q7; 
NETWORK
TITLE =Ausgang Q8

      U     #BCD3; 
      UN    #BCD2; 
      UN    #BCD1; 
      UN    #BCD0; 
      =     #Q8; 
NETWORK
TITLE =Ausgang Q9

      U     #BCD3; 
      UN    #BCD2; 
      UN    #BCD1; 
      U     #BCD0; 
      =     #Q9; 
END_FUNCTION

FUNCTION "m7b_1of8_Bit_to_DEZ_MUX" : VOID
TITLE =1 aus 8 Bit zu dezimal Multiplexer
//Das erste aus 8 Bits wird als Dezimalwert ausgegeben.
//
//Verwendung: Eintragsnummern für Operator-Panel Textlisten aus Einzelsignalen 
//            erzeugen 
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 12/2004
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  IN1 : BOOL ;	
  IN2 : BOOL ;	
  IN3 : BOOL ;	
  IN4 : BOOL ;	
  IN5 : BOOL ;	
  IN6 : BOOL ;	
  IN7 : BOOL ;	
  IN8 : BOOL ;	
END_VAR
VAR_OUTPUT
  DEZ : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =

      U     #IN1; 
      SPB   D1; 
      U     #IN2; 
      SPB   D2; 
      U     #IN3; 
      SPB   D3; 
      U     #IN4; 
      SPB   D4; 
      U     #IN5; 
      SPB   D5; 
      U     #IN6; 
      SPB   D6; 
      U     #IN7; 
      SPB   D7; 
      U     #IN8; 
      SPB   D8; 

      L     0; 
      SPA   SAVE; 
D1:   L     1; 
      SPA   SAVE; 
D2:   L     2; 
      SPA   SAVE; 
D3:   L     3; 
      SPA   SAVE; 
D4:   L     4; 
      SPA   SAVE; 
D5:   L     5; 
      SPA   SAVE; 
D6:   L     6; 
      SPA   SAVE; 
D7:   L     7; 
      SPA   SAVE; 
D8:   L     8; 
SAVE: T     #DEZ; 
      SET   ; 
      SAVE  ; 
      CLR   ; 

END_FUNCTION

FUNCTION "m7b_DECIMAL_TO_SEDECIMAL" : VOID
TITLE =Dezimal 0..9 zu Sedezimal Codierer
//0..9 Dezimal zu Sedezimal Codierer, d.h. ein Dezimalwert von 0..9 wird
//zu einem Ausgangsbit 0..9
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 07/2012
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//23.07.2013   S.Maag     CLR SET vor S eingefügt
//                        GRUND: Bei Siemens CPU's ohne ASIC (interpretierte 
//                        CODE-Verarbeitung 313/214) ist eine VKE Mitnahme bei
//                        SPL nicht möglich. Dieses Verhalten ist aber so im 
//                        Step7 Handbuch in einem Absatz vermerkt. 
//                        Ein CLR vor weiterem CODE schafft Abhilfe. Dadurch   
//                        werden alle Statusbits gelöscht und weitere
//                        Verknüpfungen funktionieren wieder korrekt.
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  DEZ : INT ;	
END_VAR
VAR_OUTPUT
  Q0 : BOOL ;	
  Q1 : BOOL ;	
  Q2 : BOOL ;	
  Q3 : BOOL ;	
  Q4 : BOOL ;	
  Q5 : BOOL ;	
  Q6 : BOOL ;	
  Q7 : BOOL ;	
  Q8 : BOOL ;	
  Q9 : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =

      SET   ; 
      SAVE  ; 
      CLR   ; 

NETWORK
TITLE =Ausgänge löschen
//ACHTUNG!
//
//indirektes Adressieren der Ausgangsbits als Byte funktioniert bei 
//Codeinterpretierenden CPUs (Siemens 313/314) nicht, da die Ausgänge
//teilweise bei ungeraden Adressen beginnen, somit erhält man einen
//'Ausrichtungsfehler beim Schreiben'. (16 Bits auf einmal kopieren geht
//überhaupt nicht, da die Bytes nicht zusammenhängend im Speicher stehen.
//(Bei CPU's mit ASIC - z.B. VIPA SPEED7) gibt es diese Probleme nicht.
//
//      L     P##Q0                       // Pointer auf erstes Ausgangsbit
//      LAR1                              // in Adressregister laden
//      L     0
//      T     B [AR1,P#0.0]               // Ausgänge Q1..Q7 löschen
//
      CLR   ; 
      =     #Q0; // Q0 löschen
      =     #Q1; 
      =     #Q2; 
      =     #Q3; 
      =     #Q4; 
      =     #Q5; 
      =     #Q6; 
      =     #Q7; 
      =     #Q8; // Q8 löschen
      =     #Q9; // Q9 löschen

NETWORK
TITLE =Ausgang 0..9 je nach Dezimalzahl setzen
//23.07.2013 S.Maag 
//
//SET Befehl vor S Qx eingefügt, da kleine Siemens CPU's (313/314) ohne ASIC, den 
//STEP7 Code interpretiert abarbeiten. Bei diesen CPU's ist eine Mitnahme des 
//VKE bei Sprüngen teilweise nicht möglich. 
      L     #DEZ; // Schrittnummer
      SPL   CLR; // Sprungziel bei SNR>max
      SPA   Q0; // 0
      SPA   Q1; // 1
      SPA   Q2; 
      SPA   Q3; 
      SPA   Q4; 
      SPA   Q5; 
      SPA   Q6; 
      SPA   Q7; 
      SPA   Q8; 
      SPA   Q9; 

CLR:  CLR   ; // Dezimalwert größer als 9 => kein Ausgang
      BEA   ; 

Q0:   CLR   ; // CLR wegen unzulässiger VKE mitnahme bei 
      SET   ; // Siemens CPUs 313/314 (interpret. Code)
      S     #Q0; 
      BEA   ; 
Q1:   CLR   ; 
      SET   ; 
      S     #Q1; 
      BEA   ; 
Q2:   CLR   ; 
      SET   ; 
      S     #Q2; 
      BEA   ; 
Q3:   CLR   ; 
      SET   ; 
      S     #Q3; 
      BEA   ; 
Q4:   CLR   ; 
      SET   ; 
      S     #Q4; 
      BEA   ; 
Q5:   CLR   ; 
      SET   ; 
      S     #Q5; 
      BEA   ; 
Q6:   CLR   ; 
      SET   ; 
      S     #Q6; 
      BEA   ; 
Q7:   CLR   ; 
      SET   ; 
      S     #Q7; 
      BEA   ; 
Q8:   CLR   ; 
      SET   ; 
      S     #Q8; 
      BEA   ; 
Q9:   CLR   ; 
      SET   ; 
      S     #Q9; 
      BEA   ; 



END_FUNCTION

FUNCTION "m7b_2BottonControl_!!!" : VOID
TITLE =cTriStateSwitch, 3-Stellungs-Schaltfunktion
//TriState Schaltfunktion
//Es kann wahlweise über OFF, SET_S1 und SET_S2 oder über einen einzelnen  
//Taster sowie über einen Softwareschalter vom OP/PC geschaltet werden. Alle 
//Schaltfunktionen sind parallel anwendbar. Bei einer Schaltstellungsänderung 
//wird der Softwareschalter automatisch angepaßt.
//Eine Flanke am Tasteingang S_PULS schaltet jeweils immer um einen Zustand weiter
//0-Q1-0-Q2
//
//Verwendung: Schalten von unterschiedlichen Stellen mit unterschiedlichen 
//            Schaltfunktionen.
//
//Hinweis   : die SET-Eingänge haben Vorrang vor S_PULS und Softwareschalter    
//[IN]
//OFF       : 1 an diesem Eingang Schaltet Q1 und Q2 aus - höchste Priotiätät
//SET_S1    : Schaltet um auf den Zustand 1: Q1=1, Q2=0
//SET_S2    : Schaltet um auf den Zustand 2: Q1=0, Q2=1
//S_PULS    : Tasteingang für Stromstoßfunktion
//            Wird die Funktion nicht benötigt, dann mit Logisch 0 beschalten.
//            Bei positiver Flanke an diesem Eingang wird jeweils um einen
//            Zustand weitergeschaltet: 0 - Q1 - 0 - Q2
// 
//FRG_SOFT  : Freigabe für Softwareschalter. Hiermit kann der Softwareschalter 
//            z.B. bei Vor-Ort-Bedienung gesperrt werden. Es wird nur die 
//            Umschaltfunktion des Softwareschalters gesperrt. Die aktuelle
//            Schaltstellung wird weiterhin angezeigt.
//
//[IN_OUT]
//S_SOFT    : Softwareschalter im INT-Format
//bTmp      : Hilfbyte für Zustandsspeicherung
//
//S_SOFT    : Softwareschalter 0/1/2 eines Softwareschalter, 
//            z.B. von OP, Visualisierung
//            0 : Q1=0, Q2=0
//            1 : Q1=1, Q2=0
//            2 : Q1=0, Q2=1
//[OUT]
//Q1        : Ausgang Schaltzustand 1
//Q2        : Ausgang Schaltzustand 2
//
//FC_ENO    : Ausgang ist 1, wenn Q1 oder Q2 = 1 ist
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 02/2006
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME      AENDERUNG
//--------------------------------------------------------------------------------
//19.09.2008   S.Maag    Istzustand des des Schalter auf Softwareschalter
//                       übertragen, wenn FRG Softwareschalter = FALSE
//                       Sprungmarke 'IST'   
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  RESET : BOOL ;	//Eingang für Ausschalter
END_VAR
VAR_OUTPUT
  Q1 : BOOL ;	//State 1
  Q2 : BOOL ;	//State 2
END_VAR
VAR_IN_OUT
  S_SOFT : INT ;	//Softwareschalter
  bTmp : BYTE ;	
END_VAR
VAR_TEMP
  lb_Q1 : BOOL ;	//Lokaler Speicher: Ausgang Q1
  lb_Q2 : BOOL ;	//Lokaler Speicher: Ausgang Q2
  lb2 : BOOL ;	//Lokaler Speicher: Flankenmerker Eingang Taster
  lb_LAST_STATE_2 : BOOL ;	//Lokaler Speicher: letzter Ein-Zustand war S2
  lb4 : BOOL ;	//Lokaler Speicher
  lb5 : BOOL ;	//Lokaler Speicher
  lb6 : BOOL ;	//Lokaler Speicher 
  lb7 : BOOL ;	//Lokaler Speicher
  SOFT_STATE_1 : BOOL ;	//Softwareschalter ist auf Zustand 1
  SOFT_STATE_2 : BOOL ;	//Softwareschalter ist auf Zustand 2
  FP_TASTER : BOOL ;	//Positive Flanke Eingangstaster
END_VAR
BEGIN
NETWORK
TITLE =Dauerhaften Zwischenspeicher in Lokaldatenbereich

      L     #bTmp; 
      T     LB     0; 
      NOP   0; 
NETWORK
TITLE =Stellung des Softwareschalters ist 1

      L     #S_SOFT; // Wert des Softwareschalters
      L     1; 
      ==I   ; 
      =     #SOFT_STATE_1; // Softwareschalter steht auf State 1

NETWORK
TITLE =Stellung des Softwareschalters ist 2

      L     #S_SOFT; // Wert des Softwareschalters
      L     2; 
      >=I   ; 
      =     #SOFT_STATE_2; // Softwareschalter steht auf State 2

NETWORK
TITLE =Auswertung der verschiedenen Schaltfunktionen

      U     #RESET; // Eingang für asschalten; hat immer Vorrang
      SPB   OFF; 


      UN    #lb_Q1; // Wenn Schaltausgang 1 AUS
      U     #SOFT_STATE_1; // und Softwareschalter Zustand 1 angewählt
      SPB   S1; // dann Zustand 1 aktivieren

      UN    #lb_Q2; // Wenn Schaltausgang 2 = AUS
      U     #SOFT_STATE_2; // und Softwareschalter Zustand 2 angewählt
      SPB   S2; // dann Zustand 2 aktivieren

      UN    #SOFT_STATE_1; // Softwareschalter Zustand 1 nicht angewählt
      UN    #SOFT_STATE_2; // Softwareschalter Zustand 2 nicht angewählt
      SPB   OFF; // dann OFF
      SPA   NE3; 

S1:   S     #lb_Q1; // Schaltausgang 1 setzen
      R     #lb_Q2; // Schaltausgang 2 löschen
      R     #lb_LAST_STATE_2; // letzter aktiver Zustand war S2 löschen
      L     1; // Softwareschalter auf 1
      SPA   SAVE; 

S2:   R     #lb_Q1; // Schaltausgang 1 löschen
      S     #lb_Q2; // Schaltausgang 2 setzen
      S     #lb_LAST_STATE_2; // letzter aktiver Zustand war S2 (merken)
      L     2; // Softwareschalter auf 2
      SPA   SAVE; 

OFF:  R     #lb_Q1; // Schaltausgang 1 löschen
      R     #lb_Q2; // Schaltausgang 2 löschen
      L     0; // Softwareschalter auf 0
      SPA   SAVE; 

      L     1; 
      U     #lb_Q1; // Ausgang 1 ist aktiv: State 1
      SPB   SAVE; 
      L     2; 
      U     #lb_Q2; // Ausgang 2 ist aktiv: State 2
      SPB   SAVE; 
      L     0; 

SAVE: T     #S_SOFT; // Softwareschalter schreiben
NE3:  NOP   0; 
NETWORK
TITLE =FC-Ausgang Q1

      U     #lb_Q1; 
      =     #Q1; 
NETWORK
TITLE =FC-Ausgang Q2

      U     #lb_Q2; 
      =     #Q2; 
NETWORK
TITLE =FC-ENO-Ausgang = Schaltausgang, für direkte FC-Verknüfpung

      O     #lb_Q1; // Ausgang 1
      O     #lb_Q2; // Ausgang 2
      SAVE  ; // auf FC-ENO-Ausgang geben
      CLR   ; 

NETWORK
TITLE =Lokalen Speicher wieder in dauerhaften Zwischenspeicher 

      L     LB     0; 
      T     #bTmp; 
      NOP   0; 
END_FUNCTION

FUNCTION "m7b_udtCopyArray" : VOID
TITLE =kopiert einzelne UDT's von UDT-Arrays
//Kopiert UDT's aus Arrays, die Datenlänge des UDT wird automatisch ermittelt. 
//Anpassungen der Datenlänge nach Änderungen an den UDT's entfällt somit.
//
//Achtung Array bzw. Speichergrenzen werden nicht überprüft.
//Gegebenenfalls, Indexangaben vorher auf Korrektheit prüfen bzw. limittieren!
//Bei inkorrekten Indexangaben geht CPU in STOP.
//
//Verwendung: Verwaltung von Datensätzen wie Rezepturen, Betriebsdaten, 
//Positionsdaten usw. in der Steuerung. 
//
//Kopiert wird von/zu: DB, statischen Lokaldaten im Instanz-DB 
//(Multinnstanzfähig, ohne zus. Adresskorrektur, da Step7 bei Verwendung von 
//Instanzdaten bei UDT's automatisch als Quelle [#84] DB und Nr. mit korrekter 
//Adress angibt statt nur DI [#85])
//
//Nicht kopiert wrid von/zu lokalen Daten (TEMP), da vor- vorherige Lokaldaten 
//benötigt werden (S7 aber nur vorherige Lokaldaten unterstützt)
//
//[IN]
//srcUdtArray : Anypointer auf den ersten UDT im Quell-Array
//srcIndex    : Index des Quell-UDT im Array, beginnend bei 0
//destUdtArray: Anypointer auf den ersten UDT im Ziel-Array
//destIndex   : Index des Ziel-UDT im Array, beginnend mit 0
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2007
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME       AENDERUNG
//--------------------------------------------------------------------------------
//20.03.2017   S.Maag     Verwendung von AR2 entfernt und Abfrage auf
//                        Daten Speicherbereich #87 vorheriger Lokaldatenstack
//                        hinzugefügt, da Daten aus vorherigem Stack nicht
//                        kopiert werden können, da BLKMOVE neuen L-Stack anlegt
//--------------------------------------------------------------------------------
//
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  srcUdtArray : ANY ;	
  srcIndex : INT ;	
  destUdtArray : ANY ;	
  destIndex : INT ;	
END_VAR
VAR_OUTPUT
  BLKMOV_RetVal : INT ;	//Return Value der Blockmovefunktion
END_VAR
VAR_TEMP
  pSRC : ANY ;	//mit Indexdaten modifizierter Quellpointer für BlockMove-Funktion
  pDEST : ANY ;	//mit Indexdaten modifizierter Zielpointer für BlockMove-Funktion
  dwPart1 : DWORD ;	
  wPart2 : WORD ;	
  dwPart3_Address : DWORD ;	
  dwBitAddress : DWORD ;	
  bMemory : BYTE ;	//Speicherbereich
END_VAR
BEGIN
NETWORK
TITLE =
//ANY
//Byte 0: 10h für S7
//Byte 1: Datentyp
//Byte 2..3: Wiederholungsfaktor
//Byte 4..5: DB-Nr
//Byte 6: Speicherbereich
//Byte 7..9: Byte/Bit-Adresse
//
//Speicherbereiche
//#80  P : Perepherie
//#81  E : Eingänge
//#82  A : Ausgänge
//#83  M : Merker
//#84  DB : Datenbaustein
//#85  DI : Instanz-DB
//#86  L  : Lokaldaten (L-Stack)
//#87  V  : Verherige Lokaldaten


NETWORK
TITLE =ANY-Pointer Quelle für BlockMove bearbeiten
//Beim Wiederholungsfaktor wird automatisch von Byte ausgegeangen. 
//Für UDT's stimmt dies auch immer. Falls der Baustein allgemein zum kopieren von 
//Anypointerbasierten Daten verwendet werden soll, so muss dies beachtet bzw. 
//angepasst werden. 
//Den ANY-Pointer Quelle mit den Indexdaten modifizieren und als ANY-Pointer für 
//die BlockMove-Funktion speichern
      L     P##srcUdtArray; // Pointer auf den Quellpointer
      LAR1  ; // in Adressregister 1

      L     D [AR1,P#0.0]; // Part1
      T     #dwPart1; 
      L     W [AR1,P#4.0]; // Part2
      T     #wPart2; 
      L     D [AR1,P#6.0]; // Part3  (Address-Pointer)
      T     #dwPart3_Address; 
      SRD   24; // Shift 3 Byte = Speicherbereich
      T     #bMemory; 
      L     B#16#87; // Daten vom vorherigen Lockaldaten Stack (geht nicht!)
      ==I   ; 
      SPB   ERR; 


// Calculating the Address with Source ARRAY Index
      L     W [AR1,P#2.0]; // Wiederholungsfaktor
      L     #srcIndex; 
      *I    ; // Offset aus Index für Quellbereich
      SLD   3; // ins Pointerformat konvertieren
      L     #dwPart3_Address; // Ursprüngliche Quelladdresse
      UD    DW#16#FFFFFF; // oberes Byte fuer Speicherbereich ausblenden
      +D    ; // Quelladresspointer mit verrechnetem Index
      T     #dwBitAddress; 

      L     P##pSRC; // Pointer auf AnyPointer Quelle für BlockMove
      LAR1  ; // in Adressreguster 1

      L     #dwPart1; // Part 1 of ANY
      T     D [AR1,P#0.0]; // to pSRC [ANY] 

      L     #wPart2; // Part 2
      T     W [AR1,P#4.0]; // DB-Nr.

      L     #dwPart3_Address; // Part 3 Address
      UD    DW#16#FF000000; // Speicherbereich maskieren
      L     #dwBitAddress; // mit Array-Index modifizierte Adresse
      OD    ; // Speicherbereich_Adresse zusammenführen
      T     D [AR1,P#6.0]; 

NETWORK
TITLE =ANY-Pointer Ziel für BlockMove bearbeiten

      L     P##destUdtArray; // Pointer auf den Quellpointer
      LAR1  ; // in Adressregister 1

      L     D [AR1,P#0.0]; // Part1
      T     #dwPart1; 
      L     W [AR1,P#4.0]; // Part2
      T     #wPart2; 
      L     D [AR1,P#6.0]; // Part3  (Address-Pointer)
      T     #dwPart3_Address; 
      SRD   24; // Shift 3 Byte = Speicherbereich
      T     #bMemory; 
      L     B#16#87; // Daten vom vorherigen Lockaldaten Stack (geht nicht!)
      ==I   ; 
      SPB   ERR; 

// Calculating the Address with Destination ARRAY Index
      L     W [AR1,P#2.0]; // Wiederholungsfaktor
      L     #destIndex; 
      *I    ; // Offset aus Index für Quellbereich
      SLD   3; // ins Pointerformat konvertieren
      L     #dwPart3_Address; // Ursprüngliche Quelladdresse
      UD    DW#16#FFFFFF; // oberes Byte fuer Speicherbereich ausblenden
      +D    ; // Quelladresspointer mit verrechnetem Index
      T     #dwBitAddress; 

      L     P##pDEST; // Pointer auf AnyPointer Quelle für BlockMove
      LAR1  ; // in Adressreguster 1

      L     #dwPart1; // Part 1 of ANY
      T     D [AR1,P#0.0]; // to pDEST [ANY] 

      L     #wPart2; // Part 2
      T     W [AR1,P#4.0]; // DB-Nr.

      L     #dwPart3_Address; // Part 3 Address
      UD    DW#16#FF000000; // Speicherbereich maskieren
      L     #dwBitAddress; // mit Array-Index modifizierte Adresse
      OD    ; // Speicherbereich_Adresse zusammenführen
      T     D [AR1,P#6.0]; 

NETWORK
TITLE =kopieren der Daten mittels BlockMove

      CALL "BLKMOV" (
           SRCBLK                   := #pSRC,
           RET_VAL                  := #BLKMOV_RetVal,
           DSTBLK                   := #pDEST);
      NOP   0; 
NETWORK
TITLE = 

      SET   ; 
      SAVE  ; 
      BEA   ; 

NETWORK
TITLE =
//Daten vom vorherigen Lokaldatenstack können nicht kopiert werden, da 
//BLKMOVE neuen L-Stack öffnet und die Daten somit vom vor- vorherigen Stack 
//wären
ERR:  L     W#16#8888; // Daten vom vorheriger Lockaldatenstack
      T     #BLKMOV_RetVal; // können nicht kopiert werden, da BLKMOVE neuen Stack anlegt
      SET   ; 
      SAVE  ; 
      BE    ; 

END_FUNCTION

FUNCTION "m7b_MultiEventCounter" : VOID
TITLE =Multi-Ereigniszähler mit GesamtAnzahl im Ereignis 0
//Zähler für verschiedene Ereignisse. Es wird immer jeweils bei einem Zählvorgang 
//der entsprechende Ereigniszähler und der Gesamtzähler erhöht. Eine Überprüfung 
//auf die Gültigkeit des übergebenen DBs und richtige Länge wird nicht 
//druchgeführt.
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 5/2003
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  DBNr : INT ;	//Nr des Datenbausteins für Zählereignisse
  StartAdr : INT ;	//StartAdr. des ersten Eintrags
  EventNr : INT ;	//Nr des zu zählenden Ereignisses; Nr.0 = Gesamtzaehler
  Count : BOOL ;	//Befehl zählen
END_VAR
VAR_TEMP
  tmpDB : INT ;	
  tmpPtrOff : INT ;	
  AR1 : DWORD ;	
END_VAR
BEGIN
NETWORK
TITLE =Überprüfung auf Zählen!

      UN    #Count; 
      BEB   ; 
NETWORK
TITLE =ungültige EreignisNr - ENDE

      L     #EventNr; 
      L     1; 
      <I    ; 
      BEB   ; 
NETWORK
TITLE =DB öffnen und Pointer auf StartAdresse erzeugen

      TAR1  #AR1; // Adressregister 1 sichern

      L     #DBNr; 
      T     #tmpDB; 

      AUF   DB [#tmpDB]; 

      L     #StartAdr; // Startadresse ins Pointerformat
      SLD   3; 
      TAR1  ; // ins Adressregister 1

NETWORK
TITLE =GesamtZaehler bearbeiten


      L     DBD [AR1,P#0.0]; // Gesamtzählerstand aus DB lesen
      +     1; 
      T     DBD [AR1,P#0.0]; // neuen Gesamtzählerstand speichern

NETWORK
TITLE =Pointer Auf EreignisZähler-Daten erzeugen

      TAR1  ; // Pointer auf Startadresse in Akku 1 zurueck
      L     #EventNr; // EreignisNr
      SLD   5; // EreignisNr -> BitPointer (*16; DINT=32Bit)
      +D    ; // Pointer aus Ereignis zum StartPointer addieren
      LAR1  ; // Pointer auf EreignisZähler nach Adressregister 1

NETWORK
TITLE =EreignisZähler bearbeiten

      L     DBD [AR1,P#0.0]; // Ereigniszählerstand aus DB lesen
      +     1; 
      T     DBD [AR1,P#0.0]; // neuen Ereigniszählerstand speichern

NETWORK
TITLE =FC-ENO Ausgang

      LAR1  #AR1; // ursprüngliches Adressregister 1 herstellen
      SET   ; 
      SAVE  ; 
      CLR   ; 

END_FUNCTION

FUNCTION "m7b_udtCompareArray" : VOID
TITLE =udt Daten in Arrays vergleichen
//Vergleicht UDT's aus Arrays, die Datenlänge des UDT wird automatisch ermittelt. 
//Anpassungen der Datenlänge nach Änderungen an den UDT's entfällt somit.
//
//Achtung!
//   Array bzw. Speichergrenzen werden nicht überprüft.
//   Gegebenenfalls, Indexangaben vorher auf Korrektheit prüfen bzw. limittieren!
//   Bei inkorrekten Indexangaben geht CPU in STOP.
//  
//   Bei Verwendung von Strings in UDT's kann es vorkommen, dass zwischen dem
//   letzten Zeichen und reservierter Stringlänge noch tote Bytes mit    
//   undefinierten Werten liegen. Dann ergibt der Vergleich des UDT ungleich, ein 
//   Stringvergleich würde jedoch gleich ergeben.
//
//Verwendung: Verwaltung von Datensätzen wie Rezepturen, Betriebsdaten, 
//Positionsdaten usw. in der Steuerung. 
//
//[IN]
//srcUdtArray : Anypointer auf den ersten UDT im Quell-Array
//srcIndex    : Index des Quell-UDT im Array, beginnend bei 0
//cmpUdtArray : Anypointer auf den ersten UDT im Vergleichs-Array
//cmpIndex    : Index des Vergleichs-UDT im Array, beginnend mit 0
//
//[RET]
//ENO         : True if datas are equal
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2010
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE: AR2, Global- und Instanz DB muessen nicht gesichert werden, da diese  
//           bei Call Aufrufen automatisch vom System wieder hergestellt werden.
//          (Bei UC Aufrufen nicht!)
//
//Vergleichroutine basiert auf m7b_DB_COMPARE_ByRef FC218
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  srcUdtArray : ANY ;	
  srcIndex : INT ;	
  cmpUdtArray : ANY ;	
  cmpIndex : INT ;	
END_VAR
VAR_TEMP
  AR1 : DWORD ;	
  p_srcData : DWORD ;	
  p_cmpData : DWORD ;	
  srcRepeat : WORD ;	
  cmpRepeat : WORD ;	
  srcDataType : BYTE ;	
  cmpDataType : BYTE ;	
  srcDB_No : WORD ;	
  cmpDB_no : WORD ;	
  DB_NO : WORD ;	
  srcSpeicherBereich : BYTE ;	
  cmpSpeicherBereich : BYTE ;	
  LOOPS : INT ;	
  NoOfBytes : INT ;	
  srcIsDB : BOOL ;	
  cmpIsDB : BOOL ;	
  pTest : DWORD ;	
END_VAR
BEGIN
NETWORK
TITLE =Adressregiste 1 sichern
//Adressregister 2 Global- und Instanz DB werden bei CALL-Aufrufen automatisch 
//vom System gesichert, bei UC nicht!
      TAR1  #AR1; // Adressregister 1 sichern

NETWORK
TITLE =Adressdaten aus ANY-Pointer extrahieren
//Beim Wiederholungsfaktor wird automatisch von Byte ausgegeangen. 
//Für UDT's stimmt dies auch immer. Falls der Baustein allgemein zum vergleichen 
//von Anypointerbasierten Daten verwendet werden soll, so muss dies beachtet bzw. 
//angepasst werden. 
//
      L     P##srcUdtArray; // Pointer auf den Quellpointer
      LAR1  ; // in Adressregister 1

      L     B [AR1,P#1.0]; // Byte 1 = Datentyp
      T     #srcDataType; 

      L     B [AR1,P#6.0]; // Byte 6 = Speicherbereich
      T     #srcSpeicherBereich; 

      L     W [AR1,P#4.0]; // DB-Nummer oder 0, wenn kein DB
      T     #srcDB_No; 

      L     W [AR1,P#2.0]; // Wiederholungsfaktor
      T     #srcRepeat; 
      L     #srcIndex; 
      *I    ; // Offset aus Index für Quellbereich
      SLD   3; // ins Pointerformat konvertieren
      L     D [AR1,P#6.0]; // DatenAdresse im Pointeformat aus ANY
      +D    ; // Adresspointer mit verrechnetem Index
      T     #p_srcData; // Pointer Source Data

      L     P##cmpUdtArray; // Pointer auf Vergleichs UDT
      LAR1  ; // in Adressregister 1

      L     B [AR1,P#1.0]; // Byte 1 = Datentyp
      T     #cmpDataType; 

      L     B [AR1,P#6.0]; // Byte 6 = Speicherbereich
      T     #cmpSpeicherBereich; 

      L     W [AR1,P#4.0]; // DB-Nummer oder 0, wenn kein DB
      T     #cmpDB_no; 

      L     W [AR1,P#2.0]; // Wiederholungsfaktor
      T     #cmpRepeat; 
      L     #cmpIndex; 
      *I    ; // Offset aus Index für Vergleichsbereich
      SLD   3; // ins Pointerformat konvertieren
      L     D [AR1,P#6.0]; // DatenAdresse im Pointeformat aus ANY
      +D    ; // Adresspointer mit verrechnetem Index
      T     #p_cmpData; // Pointer Vergleichsdaten

NETWORK
TITLE =Prüfen ob gleiches Datenformat, wenn NEIN, dann Daten ungleich

      L     #srcDataType; // Unterschiedlicher
      L     #cmpDataType; // Datentyp?
      <>I   ; 
      SPB   NEQ; // ungleich

      L     #srcRepeat; // unterschiedlicher
      L     #cmpRepeat; // Wiederholungsfaktor
      <>I   ; 
      SPB   NEQ; // ungleich

      L     #srcRepeat; // srcRepeat=cmpRepeat, deshalb
      T     #NoOfBytes; // Anzahl zu vergleichender Bytes gleich

NETWORK
TITLE =Quell- und Vergleichsdaten vom Typ DB?

      O(    ; 
      L     #srcSpeicherBereich; 
      L     B#16#84; // Datenbaustein
      ==I   ; 
      )     ; 
      O(    ; 
      L     #srcSpeicherBereich; 
      L     B#16#85; // Instanzdatenbaustein
      ==I   ; 
      )     ; 
      =     #srcIsDB; // Quelledaten sind vom Typ DB

      O(    ; 
      L     #cmpSpeicherBereich; 
      L     B#16#84; // Datenbaustein
      ==I   ; 
      )     ; 
      O(    ; 
      L     #cmpSpeicherBereich; 
      L     B#16#85; // Instanzdatenbaustein
      ==I   ; 
      )     ; 
      =     #cmpIsDB; // Vergleichsdaten sind vom Typ DB

NETWORK
TITLE =Vorbereitung für Vergleichsroutine
//Für die eigentliche Vergleichsroutine ist es nur relevant ob die Daten aus 
//einem DB stammen, nicht ob Instanz oder Global-DB. Für den vergleich wird 
//temporär immer ein DB als Global-DB, der andere als Instanz-DB geöffnet. Da dies
// nur nach Nummern geschieht, ist es egal welcher der DBs wie geöffnet wird.
//Codierung Speicherbereich:
//80h : P : Peripherie
//81h : E : Eingänge
//82h : A : Ausgänge
//83h : M : Merker
//84h : DB: Datenbaustein
//85h : DI: Instanzdatenbaustein
//86h : L : Lokaldaten (L-Stack)
//87h : V : voriger Lokaldatenstack
      UN    #srcIsDB; // Wenn weder Qell noch Vergleichsdaten
      UN    #cmpIsDB; // vom Typ DB
      SPB   DO; // dann keine Modifikation der DB-Kennung nötig, sofort vergleichen

      UN    #srcIsDB; // Wenn Quell-Daten nicht aus DB dann weiter,
      SPB   w1; // sonst Global-DB Kennung in Quelldatenpointer eintragen

      LAR1  P##p_srcData; // Adressregister 1 mit Pointer auf p_srcData laden
      L     B#16#84; // Wert für Global-DB-Kennung
      T     B [AR1,P#0.0]; // 84h=DB in p_srcData als Speicherbereichskennung eintragen 

      AUF   DB [#srcDB_No]; // Datenbaustein Quelldaten als Global-DB öffnen

w1:   UN    #cmpIsDB; // Wenn Vergleichs-Daten nicht aus DB dann weiter,
      SPB   save; // sonst Instanz-DB Kennung in Quelldatenpointer eintragen

      LAR1  P##p_cmpData; // Adressregister 1 mit Pointer auf p_cmpData laden
      L     B#16#85; // Wert für Instanz-DB-Kennung
      T     B [AR1,P#0.0]; // 85h=DB in p_srcData als Speicherbereichskennung eintragen 

      AUF   DI [#cmpDB_no]; // Datenbaustein Vergleichsdaten als Instanz-DB öffnen

save: L     #p_srcData; // Pointer der Quelldaten p_srcData in Adressregister 1
      LAR1  ; 
      L     #p_cmpData; // Pointer der Vergleichsdaten p_cmpData in Adressregister 2
      LAR2  ; 
NETWORK
TITLE =Vergleich der Daten
//Vergleich der Daten
//Vergleichroutine basiert auf m7b_DB_COMPARE_ByRef FC218
DO:   L     #NoOfBytes; // Anzahl der zu vergleichenden Bytes
      L     4; // in Anzahl der 32-Bit-Werte umrechen
      /I    ; 
      SPZ   bts; // Wenn 0 32-Bit Werte, dann weiter mit letzten 3 Bytes 
LOOP: T     #LOOPS; 
      L     D [AR1,P#0.0]; // QuellDaten lesen
      L     D [AR2,P#0.0]; // VergleichsDaten lesen
      <>D   ; // wenn nicht gleich, dann Ende
      SPB   NEQ; 
      +AR1  P#4.0; // Quell-Pointer in AR1 um 4 Bytes erhöhen
      +AR2  P#4.0; // Vergleichs-Pointer in AR2 um 4 Bytes erhöhen
      L     #LOOPS; // Schleifenzähler wieder in Akku 1 zurück
      LOOP  LOOP; // Schleifenzähler bearbeiten

bts:  L     #NoOfBytes; // nun noch die evtl. letzte 3 Bytes prüfen
      L     2#11; // Anzahl übriger Bytes maskieren
      UW    ; // Anzahl übriger Bytes
      SPZ   EQ; // Wenn 0 dann ENDE
LOP1: T     #LOOPS; 
      L     B [AR1,P#0.0]; // QuellDaten lesen
      L     B [AR2,P#0.0]; // VergleichsDaten lesen
      <>I   ; // wenn nicht gleich, dann Ende
      SPB   NEQ; 
      +AR1  P#1.0; // Quell-Pointer in AR1 um 1 Bytes erhöhen
      +AR2  P#1.0; // Vergleichs-Pointer in AR2 um 1 Bytes erhöhen
      L     #LOOPS; // Schleifenzähler wieder in Akku 1 zurück
      LOOP  LOP1; // Schleifenzähler bearbeiten

EQ:   SET   ; // Daten sind gleich (equal)
      SAVE  ; 
      CLR   ; 
      SPA   END; 

NEQ:  CLR   ; // Daten sind ungleich (not equal)
      SAVE  ; 

NETWORK
TITLE =Adressregister 1 wieder herstellen

END:  LAR1  #AR1; // ursprüngliches Adressregister 1 herstellen


END_FUNCTION

FUNCTION "m7b_2xSTART_SWITCH" : VOID
TITLE =2-fach Startumschalter
//Dieser Baustein ermöglicht, 2 Geräte (z.B. Kompressoren) abwechselnd 
//einzuschalten. Dazu werden bei jedem Ausschalten eines Gerätes die beiden 
//FRG-Ausgänge des Bausteins umgeschaltet. 
//
//Verwendung: Startumschaltung von Kompressorenpaaren bei Klimaanlagen
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 4/2004
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  G1_RUN : BOOL ;	//Eingang Gerät 1 läuft
  G2_RUN : BOOL ;	//Eingang Gerät 2 läuft
END_VAR
VAR_OUTPUT
  FRG1 : BOOL ;	//Freigabe Start Gerät 1
  FRG2 : BOOL ;	//Freigabe Start Gerät 2
END_VAR
VAR_IN_OUT
  bTMP : BYTE ;	//statisches Hilfsbyte
END_VAR
VAR_TEMP
  lb_SWITCH : BOOL ;	//Bit 0 von IO-Byte bTMP : Umschalter
  lb_FN : BOOL ;	//Negative Flanke Geräte ausgeschaltet
  lb2 : BOOL ;	
  lb3 : BOOL ;	
  lb4 : BOOL ;	
  lb5 : BOOL ;	
  lb6 : BOOL ;	
  lb7 : BOOL ;	//Bit 7 von IO-Byte bTMP
END_VAR
BEGIN
NETWORK
TITLE =statisches HilfsByte in Lokaldatenbereich

      L     #bTMP; 
      T     LB     0; 
      NOP   0; 
NETWORK
TITLE =Freigabe umschalten, wenn beide Geräte aus sind

      O     #G1_RUN; 
      O     #G2_RUN; 
      FN    #lb_FN; 
      SPBN  NE2; 
      UN    #lb_SWITCH; 
      =     #lb_SWITCH; 
NE2:  NOP   0; 
NETWORK
TITLE =Bausteinausgang Freigabe Gerät 1

      UN    #lb_SWITCH; 
      =     #FRG1; 

NETWORK
TITLE =Bausteinausgang Freigabe Gerät 2

      U     #lb_SWITCH; 
      =     #FRG2; 

NETWORK
TITLE =statisches HilfsByte aus Lokaldatenbereich zurück

      L     LB     0; 
      T     #bTMP; 
      NOP   0; 
NETWORK
TITLE =

      SET   ; 
      SAVE  ; 
      CLR   ; 


END_FUNCTION

FUNCTION "m7b_MSG_2_ML" : VOID
TITLE =Meldungen (16Stk) mittels 2er Meldeleuchten anzeigen
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 04/2006
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME      AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  MSG_1_8 : BYTE ;	//Meldung 1 bis 8 als Bits
  MSG_9_16 : BYTE ;	
  TAKT_BYTE : BYTE ;	//System Taktmerkerbyte
END_VAR
VAR_OUTPUT
  ML1 : BOOL ;	
  ML2 : BOOL ;	
END_VAR
VAR_TEMP
  MSG_1 : BOOL ;	
  MSG_2 : BOOL ;	
  MSG_3 : BOOL ;	
  MSG_4 : BOOL ;	
  MSG_5 : BOOL ;	
  MSG_6 : BOOL ;	
  MSG_7 : BOOL ;	
  MSG_8 : BOOL ;	
  MSG_9 : BOOL ;	
  MSG_10 : BOOL ;	
  MSG_11 : BOOL ;	
  MSG_12 : BOOL ;	
  MSG_13 : BOOL ;	
  MSG_14 : BOOL ;	
  MSG_15 : BOOL ;	
  MSG_16 : BOOL ;	
  TAKT_100 : BOOL ;	
  TAKT_200 : BOOL ;	
  TAKT_400 : BOOL ;	
  TAKT_500 : BOOL ;	
  TAKT_800 : BOOL ;	
  TAKT_1000 : BOOL ;	
  TAKT_1600 : BOOL ;	
  TAKT_2000 : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =Meldungsbits für Einzelbitverarbeitung in Lokaldatenbereich

      L     #MSG_1_8; 
      T     LB     0; 

      L     #MSG_9_16; 
      T     LB     1; 

      L     #TAKT_BYTE; 
      T     LB     2; 

      L     LW     0; // Alle 16 Meldungsbits laden
      L     0; // und auf 0 prüfen
      ==I   ; // wenn 0, dann keine Meldung
      SPB   E0; // keine Meldung

NETWORK
TITLE =Meldung nach Priorität auswählen
//Durch vertauschen der Auswertungen und Sprünge kann die Priortät der 
//angezeigten Meldungen in gewünschter Reihenfolge festgelegt werden
      U     #MSG_1; 
      SPB   E1; 
      U     #MSG_2; 
      SPB   E2; 
      U     #MSG_3; 
      SPB   E3; 
      U     #MSG_4; 
      SPB   E4; 
      U     #MSG_5; 
      SPB   E5; 
      U     #MSG_6; 
      SPB   E6; 
      U     #MSG_7; 
      SPB   E7; 
      U     #MSG_8; 
      SPB   E8; 
      U     #MSG_9; 
      SPB   E9; 
      U     #MSG_10; 
      SPB   E10; 
      U     #MSG_11; 
      SPB   E11; 
      U     #MSG_12; 
      SPB   E12; 
      U     #MSG_13; 
      SPB   E13; 
      U     #MSG_14; 
      SPB   E14; 
      U     #MSG_15; 
      SPB   E15; 
      U     #MSG_16; 
      SPB   E16; 

NETWORK
TITLE =Meldungen 0..3: ML2=AUS

E0:   CLR   ; // keine Störung
      =     #ML1; 
      SPA   M0; 

E1:   U     #TAKT_1000; 
      =     #ML1; 
      SPA   M0; 

E2:   U     #TAKT_400; 
      =     #ML1; 
      SPA   M0; 

E3:   SET   ; 
      =     #ML1; 

M0:   CLR   ; 
      =     #ML2; 
      SPA   END; 

NETWORK
TITLE =Meldungen 4..7: ML2=TAKT_400ms

E4:   CLR   ; 
      =     #ML1; 
      SPA   M1; 

E5:   U     #TAKT_1000; 
      =     #ML1; 
      SPA   M1; 

E6:   U     #TAKT_400; 
      =     #ML1; 
      SPA   M1; 

E7:   SET   ; 
      =     #ML1; 

M1:   U     #TAKT_1000; 
      =     #ML2; 
      SPA   END; 

NETWORK
TITLE =Meldungen 8..11: ML2=TAKT_1000ms

E8:   CLR   ; 
      =     #ML1; 
      SPA   M2; 

E9:   U     #TAKT_1000; 
      =     #ML1; 
      SPA   M2; 

E10:  U     #TAKT_400; 
      =     #ML1; 
      SPA   M2; 

E11:  SET   ; 
      =     #ML1; 

M2:   U     #TAKT_400; 
      =     #ML2; 
      SPA   END; 

NETWORK
TITLE =Meldungen 12..15: ML2=EIN

E12:  CLR   ; 
      =     #ML1; 
      SPA   M3; 

E13:  U     #TAKT_1000; 
      =     #ML1; 
      SPA   M3; 

E14:  U     #TAKT_400; 
      =     #ML1; 
      SPA   M3; 

E15:  SET   ; 
      =     #ML1; 

M3:   SET   ; 
      =     #ML2; 
NETWORK
TITLE =Meldung 16: Beide Lampen blinken abwechselnd

E16:  U     #TAKT_1000; 
      =     #ML1; 
      UN    #TAKT_1000; 
      =     #ML2; 

NETWORK
TITLE =

END:  BEA   ; 

END_FUNCTION

FUNCTION "m7b_4SensorSpeed" : VOID
TITLE =Geschwindigkeit Achse mit 4 Sensoren bremsen/Endstellung - vw/rw
//Geschwindigkeit Achse mit 4 Sensoren
//  - Endstellung vorwärts
//  - Bremsen vorwärts
//  - Bremsen rückwärts
//  - Endstellung rückwärts
//
//Das Signal der Bremssensoren wird gemerkt, sie können also überfahren werden.
//Dies ist unbedingt notwendig bei Verwendung von Zylindersensoren.
//
//ACHTUNG: Um ein ungewollt schnelles losfahren zu vermeiden, ist es 
//empfehlenswert, bei Not-Aus, den RESET auszulösen.
//Somit wird beim ersten Start dann langsam gefahren, bis ein Sensor explizit 
//wieder schnelle Geschwindigkeit erlaubt.
//
//[IN]
//vw        : Richtung vorwärts ist aktiv
//rw        : Richtung rückwärts ist aktiv
//EST_vw    : Sensor Endstellung vorwärts
//BREMS_vw  : Sensor Bremsen vorwärts
//BREMS_rw  : Sensor Bremsen rückwärts
//EST_rw    : Sensor Endstellung rückwärts
//RESET     : Schnellmerker löschen (z.B. bei Not-Aus & CPU-RESTART)
//
//[OUT]
//vw_schnell : Achse vorwärts schnelle Geschwindigkeit
//rw_schnell : Achse rückwärts schnelle Geschwindigkeit
//
//[IN_OUT]
//bTmp : exterenes Hilfbyte zur Datenspeicherung
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 2/2006
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//03.12.2008   S.Maag     Änderung der Ausgänge von langsam nach schnell, und 
//                        zusätzlicher RESET-Eingang zum löschen der Schnell-
//                        Befehle, das hat den Vorteil, dass man verhindern kann,
//                        dass bei einem Neustart ohne belegte Sensoren ungewollt
//                        schnell losgefahren wird.
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  vw : BOOL ;	//Richtung vorwärts aktiv
  rw : BOOL ;	//Richtung rückwärts aktiv
  EST_vw : BOOL ;	//Sensor Enstellung vorwärts
  BREMS_vw : BOOL ;	//Sensor Bremsen Endstellung vorwärts
  BREMS_rw : BOOL ;	//Sensor Bremsen Enstellung rückwärts
  EST_rw : BOOL ;	//Sensor Endstellung rückwärts
  RESET : BOOL ;	//Rücksetzten der Schnellbefehle, z.B. bei CPU-Restart
END_VAR
VAR_OUTPUT
  vw_schnell : BOOL ;	
  rw_schnell : BOOL ;	
END_VAR
VAR_IN_OUT
  bTmp : BYTE ;	//Hilfbyte für Signalspeicherung
END_VAR
VAR_TEMP
  lb_schnell_vw : BOOL ;	//Lokaler Speicher: schnell vorwärts
  lb_schnell_rw : BOOL ;	//Lokaler Speicher: schnell rückwärts
  lb_FN_BREMS_vw : BOOL ;	//Lokaler Speicher: negative Flanke Sensor Bremsen vorwärts
  lb_FN_BREMS_rw : BOOL ;	//Lokaler Speicher: negative Flanke Sensor Bremsen rückwärts
  lb4 : BOOL ;	//Lokaler Speicher
  lb5 : BOOL ;	//Lokaler Speicher
  lb6 : BOOL ;	//Lokaler Speicher 
  lb7 : BOOL ;	//Lokaler Speicher
END_VAR
BEGIN
NETWORK
TITLE =Dauerhaften Zwischenspeicher in Lokaldatenbereich

      L     #bTmp; 
      T     LB     0; 
      NOP   0; 
NETWORK
TITLE =schnell vorwärts
//Umschaltung auf schnell vorwärts wenn:
//Sensor bremsen oder Endstellung rückwärts
//oder der Bremssensor vorwärts bei Rückwärtsfahrt wieder verlassen wird!
      U(    ; 
      O     #EST_rw; 
      O     #BREMS_rw; 
      O(    ; 
      U     #BREMS_vw; 
      FN    #lb_FN_BREMS_vw; 
      U     #rw; 
      )     ; 
      )     ; 
      S     #lb_schnell_vw; 
      U(    ; 
      O     #BREMS_vw; 
      O     #EST_vw; 
      O     #RESET; 
      )     ; 
      R     #lb_schnell_vw; 
      U     #lb_schnell_vw; 
      =     #vw_schnell; 
NETWORK
TITLE =schnell rückwärts
//Umschaltung auf schnell rüwckwärts wenn:
//Sensor bremsen oder Endstellung vorwärts
//oder der Bremssensor rückwärts bei Vorwärtsfahrt wieder verlassen wird!
      U(    ; 
      O     #EST_vw; 
      O     #BREMS_vw; 
      O(    ; 
      U     #BREMS_rw; 
      FN    #lb_FN_BREMS_rw; 
      U     #vw; 
      )     ; 
      )     ; 
      S     #lb_schnell_rw; 
      U(    ; 
      O     #BREMS_rw; 
      O     #EST_rw; 
      O     #RESET; 
      )     ; 
      R     #lb_schnell_rw; 
      U     #lb_schnell_rw; 
      =     #rw_schnell; 
NETWORK
TITLE =FC-ENO-Ausgang

      O     #lb_schnell_vw; 
      O     #lb_schnell_rw; 
      SAVE  ; 
      CLR   ; 

NETWORK
TITLE =Lokalen Speicher wieder in dauerhaften Zwischenspeicher 

      L     LB     0; 
      T     #bTmp; 
      NOP   0; 
END_FUNCTION

FUNCTION "m7b_2SensorSpeed" : VOID
TITLE =Geschwindigkeit Achse mit 2 mitfahrenden Sensoren
//Geschwindigkeit Achse mit 2 mitfahrenden Sensoren
//  - Sensor vorw.  (voraus bei vorwärts)
//  - Sensor rückw. (voraus bei rückwärts)
//
//Das Signal der Sensoren wird gemerkt, sie können also überfahren werden.
//
//[IN]
//vw        : Richtung vorwärts ist aktiv
//rw        : Richtung rückwärts ist aktiv
//SENS_vw   : Sensor in Vorwärtsrichtung
//SENS_rw   : Sensor in Rückwärtsrichtung
//
//[OUT]
//STOP_vw    : Stop, Endstellung vorwärts
//Bremsen_vw : Achse vorwärts langsame Geschwindigkeit (bremsen)
//Bremsen_rw : Achse rückwärts langsame Geschwindigkeit (bremsen)
//STOP_rw    : Stop, Endstellung rückwärts
//
//[IN_OUT]
//bTmp : exterenes Hilfbyte zur Datenspeicherung
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 2/2006
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  vw : BOOL ;	//Richtung vorwärts aktiv
  rw : BOOL ;	//Richtung rückwärts aktiv
  SENS_vw : BOOL ;	//Sensor Bremsen Endstellung vorwärts
  SENS_rw : BOOL ;	//Sensor Bremsen Enstellung rückwärts
END_VAR
VAR_OUTPUT
  STOP_vw : BOOL ;	//Stop vorwärts
  Bremsen_vw : BOOL ;	//Bremsen vorwaerts
  Bremsen_rw : BOOL ;	//Bremsen rückwärts
  STOP_rw : BOOL ;	//Stop rückwärts
END_VAR
VAR_IN_OUT
  bTmp : BYTE ;	//Hilfbyte für Signalspeicherung
END_VAR
VAR_TEMP
  lb_STOP_vw : BOOL ;	//Lokaler Speicher: Stop vorwärts, Endstellung
  lb_bremsen_vw : BOOL ;	//Lokaler Speicher: Bremsen vorwärts
  lb_bremsen_rw : BOOL ;	//Lokaler Speicher: Bremsen rückwärts
  lb_STOP_rw : BOOL ;	//Lokaler Speicher: Stop rückwärts, Endstellung 
  lb_FP_SENS_vw : BOOL ;	//Lokaler Speicher: positive Flanke Sensor vorwärts
  lb_FP_SENS_rw : BOOL ;	//Lokaler Speicher: positive Flanke Sensor rückwärts
  lb_FN_SENS_vw : BOOL ;	//Lokaler Speicher: negative Flanke Sensor vorwärts
  lb_FN_SENS_rw : BOOL ;	//Lokaler Speicher: negative Flanke Sensor rückwärts
  FP_SENS_vw : BOOL ;	
  FP_SENS_rw : BOOL ;	
  FN_SENS_vw : BOOL ;	
  FN_SENS_rw : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =Dauerhaften Zwischenspeicher in Lokaldatenbereich

      L     #bTmp; 
      T     LB     0; 
      NOP   0; 
NETWORK
TITLE =positive Flanke Sensor vorwärts (vorne)

      U     #SENS_vw; 
      FP    #lb_FP_SENS_vw; 
      =     #FP_SENS_vw; 
NETWORK
TITLE =negative Flanke Sensor vorwärts (vorne)

      U     #SENS_vw; 
      FN    #lb_FN_SENS_vw; 
      =     #FN_SENS_vw; 
NETWORK
TITLE =positive Flanke Sensor rückwärts (hinten)

      U     #SENS_rw; 
      FP    #lb_FP_SENS_rw; 
      =     #FP_SENS_rw; 
NETWORK
TITLE =negative Flanke Sensor rückwärts (hinten)

      U     #SENS_rw; 
      FN    #lb_FN_SENS_rw; 
      =     #FN_SENS_rw; 
NETWORK
TITLE =Stop, Endstellung vorwärts

      U     #rw; 
      U     #FN_SENS_rw; 
      R     #lb_STOP_vw; 
      U     #Bremsen_vw; 
      U     #SENS_rw; 
      S     #lb_STOP_vw; 
      NOP   0; 
NETWORK
TITLE =Bremsen vorwärts

      U     #rw; 
      U     #FN_SENS_vw; 
      R     #lb_bremsen_vw; 
      U     #vw; 
      U     #FP_SENS_vw; 
      S     #lb_bremsen_vw; 
      U     #lb_bremsen_vw; 
      =     #Bremsen_vw; 
NETWORK
TITLE =Stop, Endstellung rückwärts

      U     #vw; 
      U     #FN_SENS_vw; 
      R     #lb_STOP_rw; 
      U     #Bremsen_rw; 
      U     #SENS_vw; 
      S     #lb_STOP_rw; 
      NOP   0; 
NETWORK
TITLE =Bremsen rückwärts

      U     #vw; 
      U     #FN_SENS_rw; 
      R     #lb_bremsen_rw; 
      U     #rw; 
      U     #FP_SENS_rw; 
      S     #lb_bremsen_rw; 
      U     #lb_bremsen_rw; 
      =     #Bremsen_rw; 
NETWORK
TITLE =FC-ENO-Ausgang

      O     #lb_bremsen_vw; 
      O     #lb_bremsen_rw; 
      SAVE  ; 
      CLR   ; 

NETWORK
TITLE =Lokalen Speicher wieder in dauerhaften Zwischenspeicher 

      L     LB     0; 
      T     #bTmp; 
      NOP   0; 
END_FUNCTION

FUNCTION "m7b_SoftEncoder" : VOID
TITLE =SoftEncoder mit Sensor
//SoftEncoder mit Sensor
//Software-Encoder mit Sensor und Richtungssignal erzeugen
//
//VERWENDUNG:
//Für Standard 4 Puls Schrauben-Encoder von Transporttischen
//
//[IN]
//SENSOR    Encodersignal, Sensor
//POS       Richtungssignal positiv / Transport vorwärts
//NEG       Richtungssignal negativ / Transport rückwärts
//SET       Encoder auf Startwert setzten
//SETPOINT  Startwert Encoder
//r_mm_pro_Impuls  Auflösung Encoder mm pro Impuls
//
//[OUT]
//// mit den RP-Signalen kann direkt ein Ringpuffer angesteuert werden
//RP_POS    Richtungsimpuls positiv/vorwärts  (1 Zyklus)
//RP_NEG S  Richtungsimpuls negativ/rückwärts (1 Zyklus)
//ENCODER_mm  Encoder-Wert auf Auflösung umgerechnet [mm]
//
//[IN_OUT]
//tmpByte       Statisches Hilfsbyte (Merkerersatz)
//io_ENCODER   Positionswert des Encoders in Impulsen
//
//FC_ENO :  Richtungsimpuls vorwärts oder Richtungsimpuls rückwärts
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 9/2004
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME    AENDERUNG
//--------------------------------------------------------------------------------
//29.07.2008  S.Maag   OUT_ENCODER als DINT
//                     Richtungsimpule für vw/rw (RP_VW / RP_RW) hinzugefügt
//                     FC_ENO = RP_POS oder RP_NEG
//
//21.10.2014  S.Maag   Ausgang ENCDER_mm und Eingang r_mm_pro_Impuls
//                     Umrechnung Encoderwert auf mm, dadurch Vereinfachung
//                     des Folgeprogramms => einzelne Umrechungen entfallen       
// 
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 2.0


VAR_INPUT
  SENSOR : BOOL ;	//Eingang Encodersignal
  POS : BOOL ;	//Richtungssignal positiv / vorwärts
  NEG : BOOL ;	//Richtungssignal negativ / rückwärts
  SET : BOOL ;	//EncoderWert auf SetPoint
  SETPOINT : DINT ;	//ENCODER Wert SetPoint
  r_mm_pro_Impuls : REAL ;	//Auflösung mm pro Impuls
END_VAR
VAR_OUTPUT
  RP_POS : BOOL ;	//RichtungsImpuls positiv/vorwärts (Flanke f. Ringpuffer)
  RP_NEG : BOOL ;	//RichtungsImpuls negativ/rückwärts (Flanke f. Ringpuffer)
  ENCODER_mm : DINT ;	//Encoder umgerechnet auf mm Auflösung
END_VAR
VAR_IN_OUT
  memByte : BYTE ;	//Hilfsbyte
  io_ENCODER_IMP : DINT ;	//EncoderWert [Impulse]
END_VAR
VAR_TEMP
  tmpFP : BOOL ;	//positive Flanke Sensor Encoder
  tmpFN : BOOL ;	//negative Flanke Sensor Encoder
  tmpBit2 : BOOL ;	
  tmpBit3 : BOOL ;	
  tmpBit4 : BOOL ;	
  tmpBit5 : BOOL ;	
  tmpBit6 : BOOL ;	
  tmpBit7 : BOOL ;	
  FLK_NEG : BOOL ;	
  FLK_POS : BOOL ;	
  tmp_dResult : DINT ;	
  tmp_dVAL : DINT ;	
  tmp_rKomma : REAL ;	
  tmp_ENCODER_LO : DWORD ;	
  tmp_ENCODER_HI : DWORD ;	
END_VAR
BEGIN
NETWORK
TITLE =Hilfsbyte in Lokaldatenbereich kopieren

      L     #memByte; 
      T     LB     0; 
NETWORK
TITLE =Flankenauswertung Sensor

      U     #SENSOR; 
      FP    #tmpFP; 
      =     #FLK_POS; 

      U     #SENSOR; 
      FN    #tmpFN; 
      =     #FLK_NEG; 
NETWORK
TITLE =Richtungsimpulse mit definiertem Wert (LOW) vorbelegen

      CLR   ; 
      =     #RP_POS; 
      =     #RP_NEG; 

NETWORK
TITLE =SET: Encoder auf Startwert stellen

      U     #SET; 
      SPBNB _001; 
      L     #SETPOINT; 
      T     #io_ENCODER_IMP; 
_001: NOP   0; 
NETWORK
TITLE =Encoder-Wert bei Flanke und Richtungssignal weiterzählen

      U     #FLK_POS; // Pos. Flanke Encoder 
      U     #POS; // Ansteuersignal positiv
      SPB   pos; // zähle positiv / vorwärts
      U     #FLK_NEG; // Neg. Flanke Encoder 
      U     #NEG; // Ansteuersignal negativ
      SPB   neg; // zähle negativ / rückwärts
      CLR   ; 
      SAVE  ; 
      SPA   END; 

pos:  SAVE  ; // FC_ENO = HIGH
      =     #RP_POS; // Richtungsimpuls positiv/vw.
      L     #io_ENCODER_IMP; 
      +     L#1; 
      T     #io_ENCODER_IMP; 
      SPA   END; 

neg:  SAVE  ; // FC_ENO = HIGH
      =     #RP_NEG; // Richtungsimpuls negativ/rw.
      L     #io_ENCODER_IMP; 
      +     L#-1; 
      T     #io_ENCODER_IMP; 

NETWORK
TITLE =Hilfsbyte wieder zurück kopieren und Encoder mm berechnen

END:  L     #io_ENCODER_IMP; 
      DTR   ; 
      L     #r_mm_pro_Impuls; 
      *R    ; 
      RND   ; 
      T     #ENCODER_mm; 

      L     LB     0; 
      T     #memByte; 

      BEA   ; 
NETWORK
TITLE =
//18.10.2016 S.Maag
//Ansatz für korrekte Berechnung bei grossen Zahlen.
//Da REAL nur mit 23 Bit Genauigkeit arbeitet, wird automatisch
//gerundet, was zu fatalen Fehlern führt, wenn Wegdifferenzen berechnet werden 
//sollen. 
//
//FUNKTIONIERT NOCH NICHT: Siehe FC83 für korrekte Berechnung
// 1. ganzahlige mm Encoderwert berechnen

      L     #r_mm_pro_Impuls; // mm pro Impulse  [REAL]
      TRUNC ; // nach DINT : Kommastellen abgeschnitten
      T     #tmp_dVAL; // Wert vor Komma DINT (ganzzahlige mm Aufloesung)
      L     #io_ENCODER_IMP; // ENCODER_IMP
      *D    ; // *D := ganzahlige mm Encoder
      T     #tmp_dResult; // Zwischenergebnis := Encoderwert ganzahlige mm

// 2. Nachkommawert Aufloesung Encoder mm
      L     #r_mm_pro_Impuls; // mm pro Impulse  [REAL]
      L     #tmp_dVAL; 
      DTR   ; 
      -D    ; 
      T     #tmp_rKomma; // r_mm_pro_Impulse : Wert nach Kommastelle

// 3. Encoder Impulse 32 Bit in 2 Berechnungen zerlegen 16x HiBit + 16x LoBit 
      L     #io_ENCODER_IMP; 
      UD    DW#16#FFFF0000; 
      T     #tmp_ENCODER_HI; // ENCODER Hi zwischenspeichern
      DTR   ; 
      L     #tmp_rKomma; 
      *R    ; 
      RND   ; 
      L     #tmp_dResult; 
      +D    ; 
      T     #tmp_dResult; // Zwischenergebnis

      L     #io_ENCODER_IMP; 
      L     #tmp_ENCODER_HI; 
      -D    ; 
      T     #tmp_ENCODER_LO; 
      DTR   ; 
      L     #tmp_rKomma; 
      *R    ; 
      RND   ; 
      L     #tmp_dResult; 
      +D    ; 
      T     #tmp_dResult; // Zwischenergebnis



END_FUNCTION

FUNCTION "m7b_L_MESS" : VOID
TITLE =Längenmessung mit Lichtschranke und Encoder
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2008
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME    AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  LS : BOOL ;	//Lichtschranke
  ENCODER : DINT ;	//Wegwert ENCODER
END_VAR
VAR_OUTPUT
  IST : DINT ;	
END_VAR
VAR_IN_OUT
  memByte : BYTE ;	//Hilfsbyte
  memWEG : DINT ;	
END_VAR
VAR_TEMP
  tmpFP : BOOL ;	//positive Flanke Sensor Encoder
  tmpFN : BOOL ;	//negative Flanke Sensor Encoder
  tmpBit2 : BOOL ;	
  tmpBit3 : BOOL ;	
  tmpBit4 : BOOL ;	
  tmpBit5 : BOOL ;	
  tmpBit6 : BOOL ;	
  tmpBit7 : BOOL ;	
  FLK_POS : BOOL ;	
  FLK_NEG : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =Hilfsbyte in Lokaldatenbereich kopieren

      L     #memByte; 
      T     LB     0; 

NETWORK
TITLE =Wegwert Encoder bei Lichtschranke belegt speichern

      U     #LS; 
      FP    #tmpFP; 
      SPBNB _001; 
      L     #ENCODER; 
      T     #memWEG; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
_001: U     BIE; 
      =     #FLK_POS; 
NETWORK
TITLE =Negative Flanke als FC-ENO Ausgang speichern
//Mit der negativen Flanke am ENO-Ausgang kann bei Messende z.B. der aktuelle 
//Messert umkopiert werden
      U     #LS; 
      FN    #tmpFN; 
      =     #FLK_NEG; 
      SAVE  ; 
NETWORK
TITLE =Messung läuft? Messwert ermitteln! bzw. letzten Wert ausgeben

      O     #LS; // Wenn Lichtschranke belegt, dann messen
      O     #FLK_NEG; // auch bei neg. Flanke nochmal bearbeiten, dies ist
      SPB   DO; // nötig, da dann der Istwert in tmpWeg gespeichert werden muss

      L     #memWEG; // Hilfsspeicher Weg als Ist ausgeben
      T     #IST; // wenn Messung beendet ist
      SPA   END; 

NETWORK
TITLE =Aktuellen Istwert des Wegs berechnen
//Weg berechnen, den Lichtschranke belegt ist.
//Um den Istwert konsistent zu halten wird bei negativer Flanke des LS der 
//Istwert in memWeg gespeichert und dann ständig ausgegeben. Dies ist nötig, da 
//ein FC die Ausgänge selbst nichgt konsistent halten kann.
DO:   L     #ENCODER; // Wert vom Encoder
      L     #memWEG; // gespeicherter Wert bei LS belegt
      UC    "m7a_ABS_DIFF_DINT"; // absolute Differenz
      T     #IST; // aktueller Istwert Länge

      UN    #FLK_NEG; // Bei negativer Flanke der Lichtschranke
      SPB   END; // den Istwert als tmpWeg speichern. Dieser wird dann
      T     #memWEG; // ständig als IST ausgegeben, wenn LS nicht belegt ist.
NETWORK
TITLE =Hilfsbyte wieder zurück kopieren

END:  L     LB     0; 
      T     #memByte; 

END_FUNCTION

FUNCTION "m7b_STATUS_MOTOR" : VOID
TITLE =Motorstatus für OP erzeugen
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 03/2005
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE: 
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  VW : BOOL ;	//vorwärts EIN
  RW : BOOL ;	//rückwärts EIN
  ERR : BOOL ;	//Signal Störung
END_VAR
VAR_OUTPUT
  STATUS : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =
//0 = aus
//1 = ein
//2 = Störung
//3 = links bzw. rückwärts
      L     2; 
      U     #ERR; 
      SPB   SAVE; 

      L     3; 
      U     #RW; 
      SPB   SAVE; 

      L     1; 
      U     #VW; 
      SPB   SAVE; 
      L     0; 

SAVE: T     #STATUS; 

      O     #VW; 
      O     #RW; 
      SAVE  ; 
      CLR   ; 
END_FUNCTION

FUNCTION "m7b_STATUS_DRIVE_EX" : VOID
TITLE =EXTENDED DRIVE STAUTS 
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 12/2012
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE: Entstand aus FC81 STATUS_MOTOR
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  START_FWD : BOOL ;	//START forward
  START_REV : BOOL ;	//START reverse
  ERR : BOOL ;	//ERROR
  AUTO : BOOL ;	//Automatic
END_VAR
VAR_OUTPUT
  STATUS : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =
//0 = AUS
//1 = EIN
//2 = Störung
//3 = Rückw. (links)
//4 = HAND AUS
//5 = HAND EIN
//6 = HAND RW
      L     2; 
      U     #ERR; 
      SPB   SAVE; 

      L     3; 
      U     #AUTO; 
      U     #START_REV; 
      SPB   SAVE; 

      L     1; 
      U     #AUTO; 
      U     #START_FWD; 
      SPB   SAVE; 

      L     6; 
      UN    #AUTO; 
      U     #START_REV; 
      SPB   SAVE; 

      L     5; 
      UN    #AUTO; 
      U     #START_FWD; 
      SPB   SAVE; 

      L     4; 
      UN    #AUTO; 
      UN    #START_FWD; 
      UN    #START_REV; 
      SPB   SAVE; 

      L     0; 

SAVE: T     #STATUS; 

      O     #START_FWD; 
      O     #START_REV; 
      SAVE  ; 
      CLR   ; 
END_FUNCTION

FUNCTION "m7b_STATUS_VALVE" : VOID
TITLE =Detailed Valve Status
//Attention: Different STATUS values for AUTO and HAND mode possible.
//in Hand Mode 10 is added to the STATUS value. This is to draw the HMI-Valve
//with a different frame color in HAND Mode.
//Generally I use orange to indicate HAND Mode.
//
//If different color for Hand Mode should be deactivated, call 
//the FC with AUTO=TRUE!
// 
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 9/2018
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  COIL_A : BOOL ;	//Coil A activated (working position / open)
  COIL_B : BOOL ;	//Coil B activated (home position / close)
  POS_A : BOOL ;	//Position A reached (working position / open)
  POS_B : BOOL ;	//Position B reached (home position / closed)
  ERR_POS_A : BOOL ;	//Error Position A (working position / open)
  ERR_POS_B : BOOL ;	//Error Position B (home position / closed)
  AUTO : BOOL ;	//Auto Mode (If NOT AUTO THEN ADD (STATUS, 10)) for different Frame color in HAND
END_VAR
VAR_OUTPUT
  STATUS : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =Statusanzeige bearbeiten
//AUTO : HAND
//0    : 10    = no Action / keine Aktion aktiv bzw. undefiniert
//1    : 11    = Position A (working position / 'open')
//2    : 12    = Position B (homne psotion / 'closed')
//3    : 13    = moving to A
//4    : 14    = moving to B
//5    : 15    = Error Position A
//6    : 16    = Error Position B
      L     5; // Fehler Position A (Arbeitsstellung)
      U     #ERR_POS_A; 
      SPB   SAVE; 

      L     6; // Fehler Position B (Grundstellung)
      U     #ERR_POS_B; 
      SPB   SAVE; 

      L     1; // Position A erreicht (Arbeitsstellung)
      U     #POS_A; 
      UN    #COIL_B; 
      SPB   SAVE; 

      L     2; //  Position B erreicht (Grundstellung)
      U     #POS_B; 
      UN    #COIL_A; 
      SPB   SAVE; 

      L     3; // fährt zu Position A (Arbeitsstellung)
      U     #COIL_A; 
      SPB   SAVE; 

      L     4; // fährt zu Position B (Grundstellung)
      U     #COIL_B; 
      SPB   SAVE; 

      L     0; 

SAVE: T     #STATUS; 

NETWORK
TITLE =IF NOT AUTO THEN ADD(STATUS, 10)
//ADD 10 to STATUS in Manual Mode
//This is used to draw the HMI-Valve in a different frame color in HAND Mode.
//Generally I use orange to indicate HAND Mode
      UN    #AUTO; 
      SPBNB _001; 
      L     #STATUS; 
      L     10; 
      +I    ; 
      T     #STATUS; 
_001: NOP   0; 
NETWORK
TITLE =

      SET   ; 
      SAVE  ; 
      CLR   ; 

END_FUNCTION

FUNCTION "m7b_NiveauSchalter_REAL" : VOID
TITLE =Niveau-Schalter mit Min/Max Hysterese, Min- oder Max- schaltend 
//Niveau-Schalter mit Min/Max Hysterese, Min- oder Max- schaltend 
//
//Das Schaltsignal kann über das I/O-Bit OUT und am FC-ENO-Ausgang abgenommen 
//werden. Somit kann der FC direkt in logischen Verknüpfungen verschaltet werden.
//
//VERWENDUNG:
//2-Punkt-Regler
//Befüllen oder entleeren von Tanks mit Füllstandsmesser
//Heizen bzw. kühlen
//
//VALUE : Istwert (Temperatur, Druck, Füllstand ...)
//MIN   : Minimalwert (Ein bei Min-schaltend bzw. Aus bei Max-schaltend)
//MAX   : Maximalwert (Aus bei Min-schaltend bzw. Ein bei Max-schaltend)
//
//Fkt_Min_Max:
//  0 = Minimumschaltend
//      Beim Minimum wird eingeschaltet bis das Maximum erreicht ist, dann aus
//      (z.B. befüllen, heizen)    
//
//  1 = Maximumschaltend
//      Beim Maximu wird eingeschaltet bis das Minimum erreicht ist, dann aus
//      (z.B. entleeren, kühlen)
//
//OUT : Schaltsignal
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 7/2004
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  VALUE : REAL ;	//Istwert
  MIN : REAL ;	//Minimalwert Hysterese
  MAX : REAL ;	//Maximalwert Hysterese
  cfg_Min_Max : BOOL ;	//0=MinSchaltend (z.B. befüllen, heizen) 1=MaxSchaltend (z.B. entleeren, kühlen)
END_VAR
VAR_IN_OUT
  OUT : BOOL ;	//Hilfsbit, Hilfmerker
END_VAR
BEGIN
NETWORK
TITLE =

      U     #cfg_Min_Max; // Funktionsauswahl Min-/Max- schaltend
      SPB   MAX; // Funktion Maximum schaltend

NETWORK
TITLE =Funktion: Minimum schaltend
//Funktion: Minimum schaltend (z.B. befüllen, heizen)
//Bei Erreichen des Minimums wird eingeschaltet, bis das 
//Maximum erreicht ist, dann wird ausgeschaltet.
      U(    ; 
      L     #VALUE; 
      L     #MIN; 
      <=R   ; 
      )     ; 
      S     #OUT; 
      U(    ; 
      L     #VALUE; 
      L     #MAX; 
      >=R   ; 
      )     ; 
      R     #OUT; 
      NOP   0; 
NETWORK
TITLE =

      SPA   END; 
MAX:  NOP   0; 
NETWORK
TITLE =Funktion: Maximum schaltend
//Funktion: Maximum schaltend (z.B. entleeren, kühlen)
//Bei Erreichen des Maximus wird eingeschaltet, bis das 
//Minimum wieder erreicht ist, dann wird ausgeschaltet.
      U(    ; 
      L     #VALUE; 
      L     #MAX; 
      >=R   ; 
      )     ; 
      S     #OUT; 
      U(    ; 
      L     #VALUE; 
      L     #MIN; 
      <=R   ; 
      )     ; 
      R     #OUT; 
      NOP   0; 
NETWORK
TITLE =Schaltsignal auf FC-ENO-Ausgang für direkte Weiterverschaltung

END:  U     #OUT; 
      SAVE  ; 
      CLR   ; 

END_FUNCTION

FUNCTION "m7b_NiveauSchalter_INT" : VOID
TITLE =Niveau-Schalter mit Min/Max Hysterese, Min- oder Max- schaltend 
//Niveau-Schalter mit Min/Max Hysterese, Min- oder Max- schaltend 
//
//Das Schaltsignal kann über das I/O-Bit OUT und am FC-ENO-Ausgang abgenommen 
//werden. Somit kann der FC direkt in logischen Verknüpfungen verschaltet werden.
//
//VERWENDUNG:
//2-Punkt-Regler
//Befüllen oder entleeren von Tanks mit Füllstandsmesser
//Heizen bzw. kühlen
//
//VALUE : Istwert (Temperatur, Druck, Füllstand ...)
//MIN   : Minimalwert (Ein bei Min-schaltend bzw. Aus bei Max-schaltend)
//MAX   : Maximalwert (Aus bei Min-schaltend bzw. Ein bei Max-schaltend)
//
//Fkt_Min_Max:
//  0 = Minimumschaltend
//      Beim Minimum wird eingeschaltet bis das Maximum erreicht ist, dann aus
//      (z.B. befüllen, heizen)    
//
//  1 = Maximumschaltend
//      Beim Maximu wird eingeschaltet bis das Minimum erreicht ist, dann aus
//      (z.B. entleeren, kühlen)
//
//OUT : Schaltsignal
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 7/2004
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  VALUE : INT ;	//Istwert
  MIN : INT ;	//Minimalwert Hysterese
  MAX : INT ;	//Maximalwert Hysterese
  cf_Min_Max : BOOL ;	//0=MinSchaltend (z.B. befüllen, heizen) 1=MaxSchaltend (z.B. entleeren, kühlen)
END_VAR
VAR_IN_OUT
  OUT : BOOL ;	//Hilfsbit, Hilfmerker
END_VAR
BEGIN
NETWORK
TITLE =

      U     #cf_Min_Max; // Funktionsauswahl Min-/Max- schaltend
      SPB   MAX; // Funktion Maximum schaltend

NETWORK
TITLE =Funktion: Minimum schaltend
//Funktion: Minimum schaltend (z.B. befüllen, heizen)
//Bei Erreichen des Minimums wird eingeschaltet, bis das 
//Maximum erreicht ist, dann wird ausgeschaltet.
      U(    ; 
      L     #VALUE; 
      L     #MIN; 
      <=I   ; 
      )     ; 
      S     #OUT; 
      U(    ; 
      L     #VALUE; 
      L     #MAX; 
      >=I   ; 
      )     ; 
      R     #OUT; 
      NOP   0; 
NETWORK
TITLE =

      SPA   END; 
MAX:  NOP   0; 
NETWORK
TITLE =Funktion: Maximum schaltend
//Funktion: Maximum schaltend (z.B. entleeren, kühlen)
//Bei Erreichen des Maximus wird eingeschaltet, bis das 
//Minimum wieder erreicht ist, dann wird ausgeschaltet.
      U(    ; 
      L     #VALUE; 
      L     #MAX; 
      >=I   ; 
      )     ; 
      S     #OUT; 
      U(    ; 
      L     #VALUE; 
      L     #MIN; 
      <=I   ; 
      )     ; 
      R     #OUT; 
      NOP   0; 
NETWORK
TITLE =Schaltsignal auf FC-ENO-Ausgang für direkte Weiterverschaltung

END:  U     #OUT; 
      SAVE  ; 
      CLR   ; 

END_FUNCTION

FUNCTION "m7b_OFF_HAND_AUTO" : VOID
TITLE =Standardfunktion zur Betriebsartenumschaltung OFF/HAND/AUTO
//Betriebsartenumschaltung AUS/HAND/AUTO mit TriState Schaltfunktion
//Es kann wahlweise über OFF, SET_HAND und SET_AUTO oder einen Softwareschalter 
//vom OP/PC geschaltet werden. Alle Schaltfunktionen sind parallel anwendbar. Bei 
//einer Schaltstellungsänderung wird der Softwareschalter automatisch angepaßt.
//
//Verwendung: Konsistente Betriebsartenumschaltung AUS/HAND/OFF von
//            HMI (Softwareschalter) und Vor-Ort-Tasten
//
//Hinweis   : OFF hat die höchste priorität, dann Hand, dann AUTO
//            Die Binäreingänge haben Vorrang vor dem Softwareschalter.
//            Werden die Binäreingänge nicht benötigt, dann mit FALSE
//            beschalten.
//   
//[IN]
//OFF       : Hi an diesem Eingang Schaltet auf AUS - höchste Priotiätät
//SET_MAN   : Schaltet um auf den Zustand 1: HAND=1, AUTO=0
//SET_AUTO  : Schaltet um auf den Zustand 2: HAND=0, AUTO=1
//
//FRG_AUTO  : Automatik erlauben: Bei Übergang 1->0 wird auf AUS geschaltet
//FRG_SOFT  : Freigabe für Softwareschalter. Bei Lo wird der Softwareschalter 
//            gesperrt. Es wird nur die Umschaltfunktion des Softwareschalters 
//            gesperrt. Die aktuelle Schaltstellung wird weiterhin angezeigt.
//
//[IN_OUT]
//S_SOFT    : Softwareschalter im INT-Format 0:=AUS; 1:=HAND; 2:=AUTO;
//memByte   : statosches Hilfbyte für Zustandsspeicherung
//
//S_SOFT    : Softwareschalter 0/1/2 eines Softwareschalter, 
//            z.B. von OP, Visualisierung
//            0 : Hand=0, Auto=0
//            1 : Hand=1, Auto=0
//            2 : Hand=0, Auto=1
//[OUT]
//HAND      : Ausgang Schaltzustand HAND
//AUTO      : Ausgang Schaltzustand AUTO
//
//FC.ENO    : Ausgang ist 1, wenn ein Ereignis OFF/HAND/AUTO auftritt,
//            dass durch den Softwareschalter ausglöst wurde (=HMI/USER-action)
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//SOURCE: basiert auf Kombination von FC48 'TriStateSwitch' und FC45 'Hand/Auto'
//DATUM: 06/2012
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME      AENDERUNG
//--------------------------------------------------------------------------------
//03.09.2018   S.Maag    FRG_AUTO hinzugefügt/übernommen (war schon länger bei
//                       Maschinen verwendet, welche global USER_MODE_CONTROL
//                       hatten.)
//                       FC.ENO := SoftwareSwitch/HMI/USER-Action
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 1.0


VAR_INPUT
  OFF : BOOL ;	//Eingang für Ausschalter
  SET_HAND : BOOL ;	//Eingang für Zustand 1 (Hand) einschalten
  SET_AUTO : BOOL ;	//Eingang für Zustand 2 (Auto) einschalten
  FRG_AUTO : BOOL ;	//Automatikbetrieb erlauben: Bei Übergang 1->0 wird auf AUS geschaltet
  FRG_SOFT : BOOL ;	//Freigabe für Softwareschalter
END_VAR
VAR_OUTPUT
  HAND : BOOL ;	//HAND
  AUTO : BOOL ;	//AUTO
  EVT_OFF : BOOL ;	//Event: Mode OFF activated
  EVT_HAND : BOOL ;	//Event: Mode HAND activated
  EVT_AUTO : BOOL ;	//Event: Mode AUTO activated
  DSP_MODE : INT ;	//Display actual mode: 0:=OfF; 1:=HAND; 2:=AUTO
END_VAR
VAR_IN_OUT
  S_SOFT : INT ;	//Softwareschalter
  memByte : BYTE ;	//statischer Hiflsspeicher
END_VAR
VAR_TEMP
  lb_HAND : BOOL ;	//STATIC BYTE: Output HAND
  lb_AUTO : BOOL ;	//STATIC BYTE: Output AUTO
  lb_2 : BOOL ;	//STATIC BYTE:
  lb_LAST_STATE_AUTO : BOOL ;	//STATIC BYTE: last state was AUTO
  lb_EVT_OFF : BOOL ;	//STATIC BYTE: Event OFF
  lb_EVT_HAND : BOOL ;	//STATIC BYTE: Event HAND
  lb_EVT_AUTO : BOOL ;	//STATIC BYTE: Event AUTO
  lb_HM_FN_FRG_AUTO : BOOL ;	//STATIC BYTE: FTrig FRG_AUTO
  SOFT_STATE_HAND : BOOL ;	//Software Switch is in position HAND
  SOFT_STATE_AUTO : BOOL ;	//Software Switch is in position AUTO
  evt_FRG_OFF : BOOL ;	//Event AUTO-ENABLE OFF
  MSG_S_SOFT_ACTION : BOOL ;	//Software Switch action (HMI/User Operation)
END_VAR
BEGIN
NETWORK
TITLE =Dauerhaften Zwischenspeicher in Lokaldatenbereich

      L     #memByte; 
      T     LB     0; 
      NOP   0; 
NETWORK
TITLE =Stellung des Softwareschalters ist HAND

      L     #S_SOFT; // Wert des Softwareschalters
      L     1; 
      ==I   ; 
      =     #SOFT_STATE_HAND; // Softwareschalter steht auf State 1

NETWORK
TITLE =Stellung des Softwareschalters ist AUTO

      L     #S_SOFT; // Wert des Softwareschalters
      L     2; 
      ==I   ; 
      =     #SOFT_STATE_AUTO; // Softwareschalter steht auf State 2

NETWORK
TITLE =Ereignis Freigabe AUTO AUS (Impuls-Merker neg. Flanke)

      U     #FRG_AUTO; 
      FN    #lb_HM_FN_FRG_AUTO; 
      =     #evt_FRG_OFF; 

NETWORK
TITLE =MSG Software_Switch/HMI-Operation = FALSE
//This Signal is used to detect an HMI/User Operation of the Software Switch
      U     #MSG_S_SOFT_ACTION; 
      R     #MSG_S_SOFT_ACTION; 
NETWORK
TITLE =Auswertung der verschiedenen Schaltfunktionen

      U     #OFF; // Eingang für OFF hat immer Vorrang
      SPB   OFF; 

      U     #SET_HAND; // wenn beide Zustände gleichzeitig 
      U     #SET_AUTO; // gesetzt werden sollen, dann OFF
      SPB   OFF; 

      U     #SET_HAND; // Eingang Zustand 1 (HAND) setzen
      SPB   HAND; // Zustand 1 (HAND)

      U     #lb_AUTO; // Auto aktiv
      U     #evt_FRG_OFF; // neg. Flanke FRG_AUTO (evt. Freigabe AUS)
      SPB   OFF; 

      U     #SET_AUTO; // Eingang Zustand 2 (AUTO) setzen
      U     #FRG_AUTO; 
      SPB   AUTO; // Zustand 2 (AUTO)

      UN    #FRG_SOFT; // Wenn keine Freigabe für den Softwareschalter,
      SPB   IST; // dann Istzustand in Softwareschalter schreiben

      UN    #lb_HAND; // Wenn Schaltausgang HAND=Lo
      U     #SOFT_STATE_HAND; // und Softwareschalter Zustand 1 (Hand) angewählt
      S     #MSG_S_SOFT_ACTION; // Softwareschalter Bedienung
      SPB   HAND; // dann Zustand 1 (HAND) aktivieren

      UN    #lb_AUTO; // Wenn Schaltausgang AUTO = Lo
      U     #SOFT_STATE_AUTO; // und Softwareschalter Zustand 2 (AUTO) angewählt
      U     #FRG_AUTO; // Freigabe für Automatikbetrieb
      S     #MSG_S_SOFT_ACTION; // Softwareschalter Bedienung
      SPB   AUTO; // dann Zustand 2 (AUTO) aktivieren

      UN    #SOFT_STATE_HAND; // Softwareschalter Zustand 1 nicht angewählt
      UN    #SOFT_STATE_AUTO; // Softwareschalter Zustand 2 nicht angewählt
      S     #MSG_S_SOFT_ACTION; // Softwareschalter Bedienung
      SPB   OFF; // dann OFF

      U     #SOFT_STATE_AUTO; // Softwareschalter Zustand 2 AUTO angewählt
      UN    #FRG_AUTO; // keine AUTO-Freigabe
      SPB   IST; // dann Softwareschalter auf IST Betriebszustand

      SPA   NE3; 

HAND: S     #lb_HAND; // Schaltausgang 1 setzen
      R     #lb_AUTO; // Schaltausgang 2 löschen
      R     #lb_LAST_STATE_AUTO; // letzter aktiver Zustand war S2 löschen
      L     1; // Softwareschalter auf 1
      SPA   SAVE; 

AUTO: R     #lb_HAND; // Schaltausgang 1 löschen
      S     #lb_AUTO; // Schaltausgang 2 setzen
      S     #lb_LAST_STATE_AUTO; // letzter aktiver Zustand war S2 (merken)
      L     2; // Softwareschalter auf 2
      SPA   SAVE; 

OFF:  R     #lb_HAND; // Schaltausgang 1 löschen
      R     #lb_AUTO; // Schaltausgang 2 löschen
      L     0; // Softwareschalter auf 0
      SPA   SAVE; 

IST:  L     1; 
      U     #lb_HAND; // Ausgang 1 (HAND) ist aktiv: State 1
      SPB   SAVE; 
      L     2; 
      U     #lb_AUTO; // Ausgang 2 (AUTO) ist aktiv: State 2
      SPB   SAVE; 
      L     0; 

SAVE: T     #S_SOFT; // Softwareschalter schreiben
NE3:  NOP   0; 
NETWORK
TITLE =FC-Ausgang 'HAND' & 'Ereignis HAND'

      U     #lb_HAND; 
      =     #HAND; 
      FP    #lb_EVT_HAND; 
      =     #EVT_HAND; 
NETWORK
TITLE =FC-Ausgang 'AUTO' & 'Ereignis AUTO'

      U     #lb_AUTO; 
      =     #AUTO; 
      FP    #lb_EVT_AUTO; 
      =     #EVT_AUTO; 
NETWORK
TITLE =FC-Ausgang 'Ereignis OFF'

      UN    #lb_HAND; 
      UN    #lb_AUTO; 
      FP    #lb_EVT_OFF; 
      =     #EVT_OFF; 

NETWORK
TITLE =Anzeigeausgang aktiver Modus: DSP_MODE
//0 := OFF
//1 := HAND
//2 := AUTO
      L     1; 
      U     #lb_HAND; // Ausgang 1 (HAND) ist aktiv: State 1
      SPB   sav9; 
      L     2; 
      U     #lb_AUTO; // Ausgang 2 (AUTO) ist aktiv: State 2
      SPB   sav9; 
      L     0; 
sav9: T     #DSP_MODE; // Anzeigeausgang angewählter Modus

NETWORK
TITLE =Lokalen Speicher wieder in dauerhaften Zwischenspeicher 

      L     LB     0; 
      T     #memByte; 
      NOP   0; 
NETWORK
TITLE =FC.ENO = HMI/User-Action (Software swicht operated)

      U(    ; 
      O     #EVT_OFF; // Ereignis AUS
      O     #EVT_HAND; // Ereignis HAND
      O     #EVT_AUTO; // Ereignis AUTO
      )     ; 
      U     #MSG_S_SOFT_ACTION; // Softwareschalter Bedienung
      SAVE  ; // auf FC-ENO-Ausgang geben


END_FUNCTION

FUNCTION "m7b_NiveauSchalter_DINT" : VOID
TITLE =Niveau-Schalter mit Min/Max Hysterese, Min- oder Max- schaltend 
//Niveau-Schalter mit Min/Max Hysterese, Min- oder Max- schaltend 
//
//Das Schaltsignal kann über das I/O-Bit OUT und am FC-ENO-Ausgang abgenommen 
//werden. Somit kann der FC direkt in logischen Verknüpfungen verschaltet werden.
//
//VERWENDUNG:
//2-Punkt-Regler
//Befüllen oder entleeren von Tanks mit Füllstandsmesser
//Heizen bzw. kühlen
//
//VALUE : Istwert (Temperatur, Druck, Füllstand ...)
//MIN   : Minimalwert (Ein bei Min-schaltend bzw. Aus bei Max-schaltend)
//MAX   : Maximalwert (Aus bei Min-schaltend bzw. Ein bei Max-schaltend)
//
//Fkt_Min_Max:
//  0 = Minimumschaltend
//      Beim Minimum wird eingeschaltet bis das Maximum erreicht ist, dann aus
//      (z.B. befüllen, heizen)    
//
//  1 = Maximumschaltend
//      Beim Maximu wird eingeschaltet bis das Minimum erreicht ist, dann aus
//      (z.B. entleeren, kühlen)
//
//OUT : Schaltsignal
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2014
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE: entstand aus Niveau-Schalter INT
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  VALUE : DINT ;	//Istwert
  MIN : DINT ;	//Minimalwert Hysterese
  MAX : DINT ;	//Maximalwert Hysterese
  cf_Min_Max : BOOL ;	//0=MinSchaltend (z.B. befüllen, heizen) 1=MaxSchaltend (z.B. entleeren, kühlen)
END_VAR
VAR_IN_OUT
  OUT : BOOL ;	//Hilfsbit, Hilfmerker
END_VAR
BEGIN
NETWORK
TITLE =

      U     #cf_Min_Max; // Funktionsauswahl Min-/Max- schaltend
      SPB   MAX; // Funktion Maximum schaltend

NETWORK
TITLE =Funktion: Minimum schaltend
//Funktion: Minimum schaltend (z.B. befüllen, heizen)
//Bei Erreichen des Minimums wird eingeschaltet, bis das 
//Maximum erreicht ist, dann wird ausgeschaltet.
      U(    ; 
      L     #VALUE; 
      L     #MIN; 
      <=D   ; 
      )     ; 
      S     #OUT; 
      U(    ; 
      L     #VALUE; 
      L     #MAX; 
      >=D   ; 
      )     ; 
      R     #OUT; 
      NOP   0; 
NETWORK
TITLE =

      SPA   END; 
MAX:  NOP   0; 
NETWORK
TITLE =Funktion: Maximum schaltend
//Funktion: Maximum schaltend (z.B. entleeren, kühlen)
//Bei Erreichen des Maximus wird eingeschaltet, bis das 
//Minimum wieder erreicht ist, dann wird ausgeschaltet.
      U(    ; 
      L     #VALUE; 
      L     #MAX; 
      >=D   ; 
      )     ; 
      S     #OUT; 
      U(    ; 
      L     #VALUE; 
      L     #MIN; 
      <=D   ; 
      )     ; 
      R     #OUT; 
      NOP   0; 
NETWORK
TITLE =Schaltsignal auf FC-ENO-Ausgang für direkte Weiterverschaltung

END:  U     #OUT; 
      SAVE  ; 
      CLR   ; 

END_FUNCTION

FUNCTION "m7b_DRIVE_INFO" : VOID
TITLE =Drive Info
//Informationsfunktion für Antriebe:
//
//- Anzahl der Starts
//- Betriebsstunden
//- Service/Wartungsmeldung nach Anzahl der Starts und/oder Betriebsstunden
//- Service Warnmeldung Anzahl Starts oder Betriebstunden vor dem fälligen
//  Wartungstermin
//
//Mit Speicherung des Letzten Servicedatums sowie der Userkennung
//des Verantwortlichen
//
//PARAMETER IN:
//  SIGNAL:   Ansteuersignal des Antriebs (Antrieb Start)
//  SERVICE_RESET: Signal Service erledigt, Serviceintervall wird zurückgesetzt   
// 
//  DrvCfg: UDT91: UDT_SERVICE_CFG_DRV, Struktur mit Service Konfigurationsdaten
//
//PARAMETER IN_OUT:
//  DrvInf: UDT90: UDT_SERVICE_INF, Struktur in der Service- und Betriebsdaten  
// 
//                   gespeichert werden. 
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 5/2005
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME       AENDERUNG
//--------------------------------------------------------------------------------
//09.07.2017   S.Maag     Schon länger existierende Änderung mit RESET Button
//                        im udt_DrvInf in Bibliothek aufgenommen.
//                        Verleicherfehler im NW 9 für Starts Service behoben:
//                        war >=I statt >=D
//
//02.07.2012   S.Maag     Anzeige Rest- Zeit/Starts
//                        Vorbereitung UserName Service speichern
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  SIGNAL : BOOL ;	//Motorsignal
  SERVICE_RESET : BOOL ;	
  DrvCfg : "m7_udtServiceCFG_Drive";	
END_VAR
VAR_OUTPUT
  SERVICE : BOOL ;	//Service fällig
  SERV_WARN : BOOL ;	//Service demnächst fällig
END_VAR
VAR_IN_OUT
  DrvInf : "m7_udtSericeInfo_Drive";	
  HM : BOOL ;	//Hilfsmerker
END_VAR
VAR_TEMP
  DatumZeit : DATE_AND_TIME ;	
  DATUM : DATE ;	
  RET : INT ;	
  SERVICE_H : BOOL ;	
  SERVICE_STARTS : BOOL ;	
  SERVICE_WARN_H : BOOL ;	
  SERVICE_WARN_STARTS : BOOL ;	
  RESET : BOOL ;	
  tmpH : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =Anzahl der Starts zählen

      U     #SIGNAL; 
      FP    #HM; 
      SPBN  ne2; 
      L     #DrvInf.STARTS; // Starts gesamt
      +     L#1; 
      T     #DrvInf.STARTS; 

      L     #DrvInf.SERVICE_STARTS; // Starts seit letzter Wartung
      +     L#1; 
      T     #DrvInf.SERVICE_STARTS; 

ne2:  NOP   0; 

NETWORK
TITLE =(Betriebs-) Stunden zählen

      U     #SIGNAL; // Gerät eingeschaltet
      U     M    101.5; // Takt 1 Sekunde
      SPB   rcnt; 
      SPA   ne3; 

rcnt: L     #DrvInf.RUN_SEC; // Speicher für Sekunden
      +     1; // erhöhen
      T     #DrvInf.RUN_SEC; 
      L     3600; // prüfen ob 1 Stunde vergangen = 3600 sec.
      >=I   ; 
      SPB   rh; // wenn ja, Stunden bearbeiten
      SPA   ne3; 

rh:   L     0; // neue Stunde: zuerst Sekunden löschen
      T     #DrvInf.RUN_SEC; 

      L     #DrvInf.RUN_H; // Stundenspeicher erhöhen
      +     L#1; 
      T     #DrvInf.RUN_H; 
ne3:  NOP   0; 
NETWORK
TITLE =(Betriebs-) Stunden seit letzter Wartung zählen

      U     #SIGNAL; // Gerät eingeschaltet
      U     M    101.5; // Takt 1 Sekunde
      SPB   scnt; 
      SPA   ne4; 

scnt: L     #DrvInf.SERVICE_SEC; // Speicher für Sekunden
      +     1; // erhöhen
      T     #DrvInf.SERVICE_SEC; 
      L     3600; // prüfen ob 1 Stunde vergangen = 3600 sec.
      >=I   ; 
      SPB   sh; // wenn ja, Stunden bearbeiten
      SPA   ne4; 

sh:   L     0; // neue Stunde: zuerst Sekunden löschen
      T     #DrvInf.SERVICE_SEC; 

      L     #DrvInf.SERVICE_H; // Stundenspeicher erhöhen
      +     L#1; 
      T     #DrvInf.SERVICE_H; 

ne4:  NOP   0; 
NETWORK
TITLE =Resetbedingung
//RESET-Button über Service-Info-Struktur
//oder externer Eingang RESET
      O(    ; 
      L     #DrvInf.RESET; 
      L     1; 
      ==I   ; 
      )     ; 
      O     #SERVICE_RESET; 
      =     #RESET; 
NETWORK
TITLE =Service Intervall rücksetzen

      UN    #RESET; 
      SPB   ne5; 
      L     L#0; 
      T     #DrvInf.SERVICE_H; 
      T     #DrvInf.SERVICE_SEC; 
      T     #DrvInf.SERVICE_STARTS; 

      CALL "READ_CLK" (// System Datum- und Uhrzeit
           RET_VAL                  := #RET,
           CDT                      := #DatumZeit);

      CALL "DT_DATE" (// Datum aus System Datum- Zeit lösen
           IN                       := #DatumZeit,
           RET_VAL                  := #DATUM);

      L     #DATUM; 
      T     #DrvInf.LAST_SERVICE_DATE; // aktuelles Datum als letztes Servicedatum speichern

      L     0; // Reset-Befehl löschen
      T     #DrvInf.RESET; 
ne5:  NOP   0; 
NETWORK
TITLE =Anzeige Restzeit bis Service

      L     #DrvCfg.STD; 
      L     #DrvInf.SERVICE_H; 
      -I    ; 
      SPPZ  sav1; // Springe wenn >=0
      L     0; // sonst auf 0 begrenzen
sav1: T     #DrvInf.DSP_SERVICE_H; 
NETWORK
TITLE =Anzeige Reststarts bis Service

      L     #DrvCfg.STARTS; 
      L     #DrvInf.SERVICE_STARTS; 
      -D    ; 
      SPPZ  sav2; // Springe wenn >=0
      L     L#0; // sonst auf 0 begrenzen
sav2: T     #DrvInf.DSP_SERVICE_STARTS; 
NETWORK
TITLE =Betriebsstunden für Service prüfen
//Meldung Service ist jetzt fällig, nach Betriebsstunden
      U(    ; 
      L     #DrvCfg.STD; // Anzahl der Betriebsstunde für Service
      L     #DrvInf.SERVICE_H; // Anzahl der Betriebsstunden seit letztem Service
      >=I   ; 
      )     ; 
      U     #DrvCfg.STD_AKTIV; // Aktivierungsflag für Service nach Betriebsstunden auswerten
      =     #SERVICE_H; 

NETWORK
TITLE =Starts für Service prüfen
//Meldung Service ist jetzt fällig, nach Anzahl starts
      U(    ; 
      L     #DrvCfg.STARTS; // Anzahl der Starts für Service
      L     #DrvInf.SERVICE_STARTS; // Anzahl der Starts seit letzem Servie
      >=D   ; 
      )     ; 
      U     #DrvCfg.STARTS_AKTIV; // Aktivierungsflag für Service nach Starts auswerten
      =     #SERVICE_STARTS; 
NETWORK
TITLE =Ausgang Service
//Meldung Service ist jetzt fällig
      O     #SERVICE_H; 
      O     #SERVICE_STARTS; 
      =     #SERVICE; // Bausteinausgang Service jetzt fälig
      =     #DrvInf.FLAG_SERVICE; 
NETWORK
TITLE =Betriebsstunden für Service Warnmeldung prüfen
//Warnung bzw- Hinweis, daß Service demnächst fällig ist, nach Betriebsstunden
      U(    ; 
      L     #DrvCfg.STD; 
      L     #DrvCfg.STD_DSP_MSG; 
      -I    ; 
      L     #DrvInf.SERVICE_H; 
      >=I   ; 
      )     ; 
      U     #DrvCfg.STD_AKTIV; // Aktivierungsflag für Service nach Betriebsstunden auswerten
      =     #SERVICE_WARN_H; 

NETWORK
TITLE =Starts für Service Warnmeldung prüfen
//Warnung bzw- Hinweis, daß Service demnächst fällig ist, nach Betriebsstunden
      U(    ; 
      L     #DrvCfg.STARTS; 
      L     #DrvCfg.STARTS_DSP_MSG; 
      -D    ; 
      L     #DrvInf.SERVICE_STARTS; 
      >=D   ; 
      )     ; 
      U     #DrvCfg.STARTS_AKTIV; // Aktivierungsflag für Service nach Starts auswerten
      =     #SERVICE_WARN_STARTS; 

NETWORK
TITLE =Ausgang Service demnächst

      O     #SERVICE_WARN_H; 
      O     #SERVICE_WARN_STARTS; 
      =     #SERV_WARN; // Bausteinausgang Service demnächst fällig
      =     #DrvInf.FLAG_SERVICE_WARN; 
END_FUNCTION

FUNCTION "m7b_YK_INFO" : VOID
TITLE =Ventil/Schütz Info
//Informationsfunktion für Ventile/Schütze
//
//- Anzahl der Schaltungen
//- Service/Wartungsmeldung nach Anzahl der Schaltungen 
//- Service Warnmeldung Anzahl Schaltungen vor dem fälligen Wartungstermin
//
//Mit Speicherung des Letzten Servicedatums sowie der Userkennung
//des Verantwortlichen
//
//PARAMETER IN:
//  SIGNAL:   Ansteuersignal des Antriebs (Antrieb Start)
//  SERVICE_RESET: Signal Service erledigt, Serviceintervall wird zurückgesetzt   
// 
//  YKCfg: UDT13: UDT_SERVICE_CFG_YK, Struktur mit Service Konfigurationsdaten
//
//PARAMETER IN_OUT:
//  YKInf: UDT12: UDT_SERVICE_INF, Struktur in der Service- und Betriebsdaten    
//                 gespeichert werden. 
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 5/2005
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  SIGNAL : BOOL ;	//Motorsignal
  SERVICE_RESET : BOOL ;	
  YKCfg : "m7_udt_ServiceCFG_YK";	
END_VAR
VAR_OUTPUT
  SERVICE : BOOL ;	//Service fällig
  SERV_WARN : BOOL ;	//Service demnächst fällig
END_VAR
VAR_IN_OUT
  YKInf : "m7_udtServiceInfo_YK";	
  HM : BOOL ;	//Hilfsmerker
END_VAR
VAR_TEMP
  DatumZeit : DATE_AND_TIME ;	
  DATUM : DATE ;	
  RET : INT ;	
  SERVICE_SCHAKTUNGEN : BOOL ;	
  SERVICE_WARN_SCHALTUNGEN : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =Anzahl der Starts zählen

      U     #SIGNAL; 
      FP    #HM; 
      SPBN  ne2; 
      L     #YKInf.SCHALTUNGEN; // Starts gesamt
      +     L#1; 
      T     #YKInf.SCHALTUNGEN; 

      L     #YKInf.SERVICE_SCHALTUNGEN; // Starts seit letzter Wartung
      +     L#1; 
      L     #YKInf.SERVICE_SCHALTUNGEN; 

ne2:  NOP   0; 

NETWORK
TITLE =Service Intervall rücksetzen

      UN    #SERVICE_RESET; 
      SPB   ne5; 
      L     L#0; 
      T     #YKInf.SERVICE_SCHALTUNGEN; 

      CALL "READ_CLK" (// System Datum- und Uhrzeit
           RET_VAL                  := #RET,
           CDT                      := #DatumZeit);
// Datum aus Systemzeit, Datum lösen
      CALL "DT_DATE" (
           IN                       := #DatumZeit,
           RET_VAL                  := #DATUM);

      L     #DATUM; 
      T     #YKInf.LAST_SERVICE_DATE; // aktuelles Datum als letztes Servicedatum speichern
ne5:  NOP   0; 
NETWORK
TITLE =Schaltungen für Service prüfen
//Meldung Service ist jetzt fällig, nach Anzahl Schaltungen
      U(    ; 
      L     #YKCfg.SCHALTUNGEN; // Anzahl der Schaltungen für Service
      L     #YKInf.SERVICE_SCHALTUNGEN; // Anzahl der Schaltungen seit letzem Servie
      >=I   ; 
      )     ; 
      =     #SERVICE_SCHAKTUNGEN; 
NETWORK
TITLE =Ausgang Service
//Meldung Service ist jetzt fällig
      O     #SERVICE_SCHAKTUNGEN; 
      =     #SERVICE; // Bausteinausgang Service jetzt fälig
NETWORK
TITLE =Starts für Service Warnmeldung prüfen
//Warnung bzw- Hinweis, daß Service demnächst fällig ist, nach Betriebsstunden
      U(    ; 
      L     #YKCfg.SCHALTUNGEN; 
      L     #YKCfg.SCHALTUNGEN_DSP_MSG; 
      -I    ; 
      L     #YKInf.SERVICE_SCHALTUNGEN; 
      >=I   ; 
      )     ; 
      =     #SERVICE_WARN_SCHALTUNGEN; 
NETWORK
TITLE =Ausgang Service demnächst

      U     #SERVICE_WARN_SCHALTUNGEN; 
      =     #SERV_WARN; // Bausteinausgang Service demnächst fällig

END_FUNCTION

FUNCTION "m7b_DAMPING_INT" : INT
TITLE =Kontinuierliche Mittelwertbildung eines INT-Wertes
//x   : neuer Mittelwert
//m   : letzter Mittelwert 
//n   : Anzahl der Werte
//a   : Eingangswert
//
//x = m + (a-m)/n   
//
//
//Bei jeder neuen Berechnung wird der FC-ENO Ausgang HIGH
//
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 9/2005
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 2.0


VAR_INPUT
  IN_VALUE : INT ;	//Eingangswert
  IN_TAKT_RisingEdge : BOOL ;	//Taktflanke Zeittakt Dämpfung
  IN_rDampingFactor : REAL ;	//Dämpfungsfaktor muss >1 sein
END_VAR
VAR_IN_OUT
  IO_SENSOR_DAMP : REAL ;	
END_VAR
VAR_TEMP
  rDamping : REAL ;	
END_VAR
BEGIN
NETWORK
TITLE =

      SET   ; 
      SAVE  ; 
      CLR   ; 

NETWORK
TITLE =Dämpfung des Sensorwertes 
//Durch das aufaddieren eines Teils der Differenz zum aktuellen Analogwert
//läuft der gedämpfte Wert dem Analogwert immer etwas hinterher. Es ergibt sich 
//ein exponentieller Nachlauf (vgl. Kondensator Ladekurve) bei einem 
//Dämpfungsfaktor von 2 erhält man nach 5 Impulsen ca. 96.9%, nach 7 Impulsen ca. 
//99.2% Sensorwertes. Je höher der Dämpfungsfaktor, desto langsamer läuft der 
//Wert hinterher.
      UN    #IN_TAKT_RisingEdge; 
      SPB   end; 

      L     #IN_rDampingFactor; // sicherstellen, dass
      L     1.000000e+000; // Dämpfungsfaktor >=1.0
      <R    ; 
      SPB   sav; 
      TAK   ; 
sav:  T     #rDamping; 
      L     #IN_VALUE; 
      ITD   ; 
      DTR   ; 
      L     #IO_SENSOR_DAMP; 
      -R    ; 
      L     #rDamping; 
      /R    ; 
      L     #IO_SENSOR_DAMP; 
      +R    ; 
      T     #IO_SENSOR_DAMP; 
end:  L     #IO_SENSOR_DAMP; 
      RND   ; 
      T     #RET_VAL; 
END_FUNCTION

FUNCTION "m7b_CONT_MITTEL_DINT" : VOID
TITLE =Kontinuierliche Mittelwertbildung eines DINT-Wertes
//x   : neuer Mittelwert
//m   : letzter Mittelwert 
//n   : Anzahl der Werte
//a   : Eingangswert
//
//x = m + (a-m)/n   
//
//
//Bei jeder neuen Berechnung wird der FC-ENO Ausgang HIGH
//
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 9/2005
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  CALC : BOOL ;	//Neuen Mittelwert bilden
  RESET : BOOL ;	//RESET
  VALUE : DINT ;	//Eingangswert
END_VAR
VAR_OUTPUT
  M_DINT : DINT ;	//Mittelwert im DINT-Format
END_VAR
VAR_IN_OUT
  M_REAL : REAL ;	//Mittelwert im REAL-Format
  N : DINT ;	//Anzahl der bereits verrechneten Werte
END_VAR
VAR_TEMP
  diff : REAL ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =RESET

      UN    #RESET; 
      SPB   NE2; 

      L     0; // Rücksetzen
      T     #N; // Anzahl verrechneter Werte
      T     #M_DINT; // Mittelwert DINT

      L     0.000000e+000; // Mittelwert löschen
      T     #M_REAL; 

NE2:  NOP   0; 

NETWORK
TITLE =

      U     #CALC; 
      SAVE  ; 
      SPB   CLC; 
      SPA   OUT; 


NETWORK
TITLE =Anzahl der Verrechneten Werte erhöhen

CLC:  L     #N; 
      +     L#1; 
      T     #N; 

NETWORK
TITLE =neuen Mittelwert berechnen
//
//neuesMittel = Mittelwert + (Eingangswert - Mittelwert) / AnzahlWerte  
      L     #VALUE; // Eingangswert
      DTR   ; // in Real wandeln
      L     #M_REAL; // und vom aktuellen Mittelwert abziehen
      -R    ; // =(Eingangswert - Mittelwert)
      T     #diff; 
      L     #N; 
      DTR   ; 
      /R    ; // = (Eingangswert - Mittelwert)/AnzahlWerte
      L     #M_REAL; 
      +R    ; 
      T     #M_REAL; // neuer Mittelwert



NETWORK
TITLE =Mittelwert als DINT ausgeben

OUT:  L     #M_REAL; 
      RND   ; // in Ganzzahl wandeln
      T     #M_DINT; 

END_FUNCTION

FUNCTION "m7b_RAMPE_LIN_min" : VOID
TITLE =Linear-Rampen-Generator mit MaxBegrenzung für Hand und Auto
//Generiert eine lineare Rampe zwischen den Geschwindigkeiten MIN und MAX.
//Bei einer Entfernung = RampenDistanz wird die Rampe eingeleitet.
//Bei einer Entfernung = Vk_MinSpeed erreicht die Rampe Speed_min
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 3/2003
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME          AENDERUNG
//--------------------------------------------------------------------------------
//12.09.2007   S. Maag       Vorkontakt bei Berechnung der Rampenlänge
//                           berücksichtigt. Nun glatter Übergang bei erreichen
//                           des Vorkontaktes. (NW3: RAMP:)
//
//20.04.2009   S. Maag       FC-ENO:= True, wenn innerhalb der Rampe
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  VK_MinSpeed : DINT ;	//Vorkontakt für Fahrt mit Minimalgeschwindigkeit
  Speed_min : INT ;	//Geschwindigkeit minimal
  Speed_max : INT ;	//Geschwindigkeit maximal
  RampenDistanz : DINT ;	//Positionsdistanz, ab der mit der Rampe begonnen wird
  SW_Pos : DINT ;	//Sollwert Position
  IW_Pos : DINT ;	//Istwert Position
END_VAR
VAR_OUTPUT
  Speed : INT ;	//Solwert Geschwindigkeit
END_VAR
VAR_TEMP
  SPEED_DIFF : INT ;	
  POS_DIFF : DINT ;	
  RAMP_LENGTH : DINT ;	
END_VAR
BEGIN
NETWORK
TITLE =Geschwindigkeitsbereich, Geschwindigkeitsdifferenz


      L     #Speed_max; // Maximalgeschwindigkeit
      L     #Speed_min; // Minimalgeschwindigkeit
      -I    ; 
      T     #SPEED_DIFF; // Geschwindigkeitsbereich absolut

NETWORK
TITLE =Positionsdifferenz positiv: ABS(Soll - Ist)

      L     #SW_Pos; // Soll-Position
      L     #IW_Pos; // Ist-Position
      -D    ; // Positionierabstand
      SPP   PLUS; // positiven Wert erzeugen
      NEGD  ; 
PLUS: T     #POS_DIFF; // Positionierdifferenz
      L     #VK_MinSpeed; // Vorkontakt für Fahrt mit Minimalgeschw.
      <D    ; 
      SPB   MIN; // Minimalgeschw. laden

      TAK   ; // POS_DIFF in Akku 1 zurück
      L     #RampenDistanz; // Rampendistanz
      <=D   ; // Wenn Pos_Diff<RampenDist 
      SAVE  ; 
      SPB   RAMP; // -> innerhalb der Rampe; Rampe generieren

      L     #Speed_max; // Maximalgeschwindigkeit
      SPA   SAVE; 

MIN:  SET   ; 
      SAVE  ; 
      CLR   ; 

      L     #Speed_min; // andernfalls die Minimalgeschwindigkeit
      SPA   SAVE; // als SpeedAkt speichern
NETWORK
TITLE =Rampe generieren:
//SpeedDiff = SpeedMax - SpeedMin  :  Geschwindigkeitsbereich
//
//V(RAMPE) = SpeedDiff * (PosDiff / RampenDistanz) + SpeedMin
// Rampe generieren wird nur aufgerufen, wenn man sich innerhalb der
// Rampendistanz befindet, sonst wird SpeedMin ausgegeben
// 12.09.2007: Vorkontakt bei Berechnung der Rampenlänge berücksichtigt

RAMP: L     #RampenDistanz; // Rampendistanz (Eingang)
      L     #VK_MinSpeed; // Vorkontakt Minimalgeschwindigkeit
      -D    ; 
      T     #RAMP_LENGTH; // berechnete Rampenlänge bis Vorkontakt

      L     #POS_DIFF; // Positionierdifferenz
      DTR   ; // nach REAL
      L     #RAMP_LENGTH; // berechnete RampenDistanz
      DTR   ; // nach REAL
      /R    ; // PosDiff / RampenDistanz
      L     #SPEED_DIFF; // SpeedDiff
      ITD   ; // nach DINT
      DTR   ; // nach REAL
      *R    ; 
      RND   ; // nach DINT
      L     #Speed_min; // SpeedMin
      ITD   ; // nach DINT
      +D    ; 
      L     DW#16#FFFF; // nach INT
      UD    ; // Aktueller Speed als INT in AKKU1

NETWORK
TITLE =nun noch auf Maximalwert bei Hand oder Auto begrenzen

SAVE: L     #Speed_max; // Speed max
      >I    ; // Wenn SpeedAkt >  MaxSpeed,
      SPB   SAV0; // dann MaxSpeed speichern
      TAK   ; // sonst SpeedAkt zurück in Akku1
SAV0: T     #Speed; // Speed speichern

END_FUNCTION

FUNCTION "m7b_POSITONIEREN" : VOID
TITLE =Positionierrichtung Achse ermitteln. Position ok ausgeben
//Dieser FC ermittelt die Positonierrichtung von Achsen (vorw./rückw.)
//
//TOL_POS : Ist die zuslässige Positionsdifferenz, ab der die Achse zum
//          nachpositionieren anfängt
//
//TOL_POS_OK : Ist die zulässige Toleranz bis zu der gemeldet wird, dass
//             die Achse im gültigen Positiosfenster steht
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2003
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//21.04.2009   S.Maag      TOL_POS auf ENO-Ausgang, damit kann verzögert dann
//                         die Freigabe für den Positionier-FB gelöscht werden
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  FRG : BOOL ;	//Freigabe
  SOLL : DINT ;	//Sollwert
  IST : DINT ;	//Istwert Achse
  TOL_POS_OK : DINT ;	//Toleranz für Position ok Meldung
  TOL_POS : DINT ;	//Toleranz Posiitionierung Achse
END_VAR
VAR_OUTPUT
  PLUS : BOOL ;	
  MINUS : BOOL ;	
  POS_OK : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =Postion Achse prüfen, Positionsdifferenz

      L     #SOLL; // aktuelle Sollposition
      L     #IST; // aktuelle Istposition
      -D    ; // Positionierdifferenz
      SPP   PLUS; 
      NEGD  ; // nach positiv

PLUS: L     #TOL_POS_OK; // Toleranz für Position ok
      <D    ; 
      =     #POS_OK; // Ausgang Position ok

      TAK   ; // Positionsdifferenz in AKKU1
      L     #TOL_POS; // Toleranz für Positionierung
      <D    ; 
      SAVE  ; 
      SPB   STOP; // Innerhalb Toleranz, dann Stop

NETWORK
TITLE =FREIGABE

      UN    #FRG; // keine Freigabe, dann Stop
      SPB   STOP; 

NETWORK
TITLE =Postionierrichtung vorw. oder rückw.

      L     #SOLL; // Soll
      L     #IST; // IST
      >D    ; 
      SPB   VW; // Soll > Ist, dann vw
      SPA   RW; // sonst rw
NETWORK
TITLE =Richtungsausgänge setzen

STOP: R     #PLUS; 
      R     #MINUS; 
      BEA   ; 

VW:   R     #MINUS; 
      S     #PLUS; 
      BEA   ; 

RW:   R     #PLUS; 
      S     #MINUS; 
      BE    ; 
END_FUNCTION

FUNCTION "m7b_SPEED_SELECT" : VOID
TITLE =Speed auswählen 
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2003
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//13.03.2020   S.Maag      Baustein aus Library entfernt, wird druch
//                         FC113/114 MUX_INT ersetzt
//24.04.2009   S.Maag      EN0 := Signal Wert selektiert 
//                               (S1 | S2 | S3)  AND ENABLE
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  S1 : BOOL ;	//Auswahl Speed 1 (1-te Priorität)
  S2 : BOOL ;	//Auswahl Speed 2 (2-te Priorität)
  S3 : BOOL ;	//Auswahl Speed 3 (3-te Priorität)
  FRG : BOOL ;	
  SPEED_1 : INT ;	
  SPEED_2 : INT ;	
  SPEED_3 : INT ;	
END_VAR
VAR_OUTPUT
  SPEED : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =

      UN    #FRG; // keine Freigabe, dann 0 ausgeben
      SPB   STOP; 

      U     #S1; 
      SPB   S1; 

      U     #S2; 
      SPB   S2; 

      U     #S3; 
      SPB   S3; 
      SPA   STOP; 

S1:   L     #SPEED_1; 
      SPA   SAVE; 

S2:   L     #SPEED_2; 
      SPA   SAVE; 

S3:   L     #SPEED_3; 
      SPA   SAVE; 

STOP: CLR   ; // EN0-Ausgang =0, da Stopp
      SAVE  ; 
      L     0; 
      T     #SPEED; 
      BEA   ; 

SAVE: T     #SPEED; 
      SAVE  ; 
END_FUNCTION

FUNCTION "m7b_READ_SSI_ENCODER" : VOID
TITLE =SSI-Encoder einlesen: Position mit Auflösung & 0-Pkt-Korrektur 
//[IN]     
//PED_IN         Perepherie-Kanal SSI-ENCODER z.B. PED256
//Encoder_Bits   Anzahl der Bits, die Encoder verarbeitet, meist 24 oder 25.
//               Diese Angabe ist vor allem für invertierte Drehrichtung
//               wichtig, da sonst die hohen nicht belegten Bits des Encoders
//               immer 1 sind, was einen grossen negtiven Wert bedeuted. 
//
//FKT_AUFL       Faktor für Endoderauflösung
//O_Pkt_Korr     0-Punkt Korrekturwert, Wert wird addiert
//INV            Drehrichtung invertieren
//
//[OUT]
//POS_DINT       Position als DINT-Wert 32 Bit
//POS_INT        Position als INT-Wert 16 Bit
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 7/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM      NAME     AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE: 
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  PED_IN : DWORD ;	//Perepherie-Kanal SSI-ENCODER z.B. PED256
  EncoderBits : INT ;	//Anzahl der Bits, die Encoder verarbeitet, meist 24 oder 25
  FKT_AUFL : REAL ;	//Faktor Auflösung, wird multipliziert
  O_Pkt_Korr : DINT ;	//0-Punkt Korrekturwert, Wert wird addiert
  INV : BOOL ;	//Drehrichtung invertieren
END_VAR
VAR_OUTPUT
  POS_DINT : DINT ;	//Position als DINT-Wert 32 Bit
  POS_INT : INT ;	//Position als INT-Wert 16 Bit
END_VAR
VAR_TEMP
  MASKE : DWORD ;	//Bitmaske zur verarbeitender Bits des Encoder, meist nur 24Bit
  Bits : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =Bitmaske der vom Geber verarbeiteten Anzahl der Bits erzeugen

      L     #EncoderBits; // Anzahl der vom Encoder verarbeitetn Bits max. 32
      DEC   1; // umrechnen auf 0..31 durch abziehen von 1
      L     2#11111; // Auf 5 Bit := 0..31 
      UW    ; // begrenzen
      L     31; // max. zu verarbeitender Bitwert in Akku 1
      TAK   ; // vom Encoder max. verarbeiter Bitwert 0..31 in Akku 1 zurück
      -I    ; // Vom Encoder wengier als verarbeitet Bits
      L     DW#16#FFFFFFFF; // 32 Bits auf 1 := Maske bei 32 verarbeitetn Bits
      SRD   ; // Maske um Differenz der Bits in Akku2-LL verschieben
      T     #MASKE; // = Maske der vom Encoder verarbeiteten Bits
NETWORK
TITLE =Encoderwert mit Auflösung und 0-Punkt-Korrektur berechnen

      L     #PED_IN; // Wert von Encoder
      UN    #INV; // Drehrichtung invertieren ?
      SPB   calc; // wenn nein, dann berechnen
      NEGD  ; // Wert invertieren
calc: L     #MASKE; // Geber hat meist keine 32Bit, Rest ausblenden
      UD    ; // sonst sind bei invertierter Messrichtung die höchsten Bits immer 1
      DTR   ; // wandeln nach Real
      L     #FKT_AUFL; // Faktor für Geberanpassung
      *R    ; 
      RND   ; // in DINT zurückwandeln
      L     #O_Pkt_Korr; // Korrekturwert für 0-Punktverschiebung
      +D    ; 
      T     #POS_DINT; // Istwert Encoder 32 Bit
      T     #POS_INT; // Istwert Encoder 16 Bit
NETWORK
TITLE =FC-ENO = HIGH

      SET   ; 
      SAVE  ; 
      CLR   ; 

END_FUNCTION

FUNCTION "m7b_ENCODER_KORR" : VOID
TITLE =Encoderwerte: Position mit Auflösung & 0-Pkt-Korrektur 
//[IN]     
//ENCODER        Roh-Wert des Encoders
//Encoder_Bits   Anzahl der Bits (1..32), die verarbeitet werden sollen.
//               Bei SSI-Encodern sind dies meist 24;25 Bits.
//               Diese Angabe ist vor allem für invertierte Drehrichtung
//               wichtig, da sonst die hohen nicht belegten Bits des Encoders
//               immer 1 sind, was einen grossen negtiven Wert bedeuted. 
//FKT_AUFL       Faktor für Endoderauflösung
//O_Pkt_Korr     0-Punkt Korrekturwert, Wert wird addiert
//INV            Drehrichtung invertieren
//
//[OUT]
//POS_DINT       Position als DINT-Wert 32 Bit
//POS_INT        Position als INT-Wert 16 Bit
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 7/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM      NAME     AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE: 
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  ENCODER : INT ;	//Perepherie-Kanal SSI-ENCODER z.B. PED256
  EncoderBits : INT ;	//Anzahl der Bits, die Encoder verarbeitet (1..32), meist 24 oder 25
  FKT_AUFL : REAL ;	//Faktor Auflösung, wird multipliziert
  O_Pkt_Korr : DINT ;	//0-Punkt Korrekturwert, Wert wird addiert
  INV : BOOL ;	//Drehrichtung invertieren
END_VAR
VAR_OUTPUT
  POS_DINT : DINT ;	//Position als DINT-Wert 32 Bit
  POS_INT : INT ;	//Position als INT-Wert 16 Bit
END_VAR
VAR_TEMP
  MASKE : DWORD ;	//Bitmaske zur verarbeitender Bits des Encoder, meist nur 24Bit
  Bits : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =Bitmaske der vom Encoder verarbeiteten Anzahl der Bits erzeugen

      L     #EncoderBits; // Anzahl der vom Encoder verarbeitetn Bits max. 32
      DEC   1; // umrechnen auf 0..31 durch abziehen von 1
      L     2#11111; // Auf 5 Bit := 0..31 
      UW    ; // begrenzen
      L     31; // max. zu verarbeitender Bitwert in Akku 1
      TAK   ; // vom Encoder max. verarbeiter Bitwert 0..31 in Akku 1 zurück
      -I    ; // Vom Encoder weniger als verarbeitete Bits
      L     DW#16#FFFFFFFF; // 32 Bits auf 1 := Maske bei 32 verarbeitetn Bits
      SRD   ; // Maske um Differenz der Bits in Akku2-LL verschieben
      T     #MASKE; // = Maske der vom Encoder verarbeiteten Bits
NETWORK
TITLE =Encoderwert mit Auflösung und 0-Punkt-Korrektur berechnen

      L     #ENCODER; // Wert von Encoder
      UN    #INV; // Drehrichtung invertieren ?
      SPB   calc; // wenn nein, dann berechnen
      NEGD  ; // Wert invertieren
calc: L     #MASKE; // Geber hat meist keine 32Bit, Rest ausblenden
      UD    ; // sonst sind bei invertierter Messrichtung die höchsten Bits immer 1
      DTR   ; // wandeln nach Real
      L     #FKT_AUFL; // Faktor für Geberanpassung
      *R    ; 
      RND   ; // in DINT zurückwandeln
      L     #O_Pkt_Korr; // Korrekturwert für 0-Punktverschiebung
      +D    ; 
      T     #POS_DINT; // Istwert Encoder 32 Bit
      T     #POS_INT; // Istwert Encoder 16 Bit
NETWORK
TITLE =FC-ENO = HIGH

      SET   ; 
      SAVE  ; 
      CLR   ; 

END_FUNCTION

FUNCTION "m7b_TACHO" : VOID
TITLE =Tacho: (zurückgelegter Weg je Zeiteinheit)
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 5/2003
//INTERNET: www.maagic7.de
//
//Dieser FC ermittelt den zurückgelegten Weg je Zeiteinheit.
//Der Weg wird absolut (immer positiv) ermittelt und entspricht somit der 
//Geschwindigkeit.
//Zusätzlich werden die Richtungen POSITIV und NEGAIV als extra Signal ausgegeben.
//Ist keines der beiden Signale aktiv, so steht die Achse
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//30.10.2017   S.Maag         io_SpeedPulse von INT auf DINT geaendert
//                            INT macht hier keinen Sinn!
//
//17.11.2006   S.Maag         FC getestet
//                            FC-ENO-Ausgang = Antrieb läuft; hinzugefügt
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  ENCODER : DINT ;	//Positionswert des Encoders
  TA_IMP : BOOL ;	//Abtastimpuls, Impuls (1Zyklus)
  FRG : BOOL ;	//Freigabe, Start
END_VAR
VAR_OUTPUT
  POSITIV : BOOL ;	//Drehrichtung positiv
  NEGATIV : BOOL ;	//Drehrichtung negativ
END_VAR
VAR_IN_OUT
  io_dSpeedPulse : DINT ;	//Geschwindigkeit als Positionswerte je TriggerEreignis
  memENCODER : DINT ;	//Speicherung der Encoder StartPosition
  memByte : BYTE ;	//Hilfspeicher BYTE
END_VAR
VAR_TEMP
  tmpStart : BOOL ;	
  tmpPositiv : BOOL ;	
  tmpNegativ : BOOL ;	
  LB_3 : BOOL ;	
  LB_4 : BOOL ;	
  LB_5 : BOOL ;	
  LB_6 : BOOL ;	
  LB_7 : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =

      L     #memByte; // Hilfword für Signalspeicherung
      T     LB     0; // in Lokaldatenbereich, wegen Bitadressierung
NETWORK
TITLE =START-Eingang prüfen 

      UN    #FRG; // Wenn nicht gestartet, dann
      R     #tmpStart; // HM Start löschen
      BEB   ; 
NETWORK
TITLE =Start-Ereignis verarbeiten

      U     #tmpStart; 
      SPB   NWE; 

      S     #tmpStart; // HM gestartet
      L     #ENCODER; // akt. EncoderWert
      T     #memENCODER; // als Vergleich speichern
      SPA   END; 
NWE:  NOP   0; 

NETWORK
TITLE =Trigger-Ereignis : Speed ermitteln

      UN    #TA_IMP; // Wenn Trigger-Ereignis eintritt,
      SPB   END; 

      L     #memENCODER; // StartPos Encoder 
      L     #ENCODER; // akt. EncoderPos
      T     #memENCODER; // als neue StartPos speichern
      -D    ; // zurückgelegten Weg ermitteln
      U     >0; // Wegdifferenz <0 (da memENC-ENC)
      =     #tmpNegativ; // = Drehrichtung negativ
      U     <0; // Wegdifferenz >0 (da memENC-ENC)
      =     #tmpPositiv; // = Drehrichtung positiv
      SPP   PLUS; 
      NEGD  ; 
PLUS: T     #io_dSpeedPulse; // SPEED = WEG / ZeitEinheit

NETWORK
TITLE =Richtungsausgänge Ausgeben
//die Richtungsausgänge müssen über den Umweg eines statischen Hilfsspeichers 
//immer Ausgegeben werden. Bei direkter Ausgabe hätten sie einen nicht 
//definierten 
//Zustand, da die Ausgabe im obigen NW nur mit Auftreten eines Impulses erfolgt
END:  U     #tmpNegativ; 
      =     #NEGATIV; 
      U     #tmpPositiv; 
      =     #POSITIV; 

NETWORK
TITLE =FC-ENO Ausgang = Antrieb läuft, RUN

      O     #tmpNegativ; 
      O     #tmpPositiv; 
      SAVE  ; 
      CLR   ; 

NETWORK
TITLE =Bitadressierte Signale aus Lokaldatenbereich wieder speichern

      L     LB     0; // Lokaldatenword
      T     #memByte; // nach Singnalspeicher

END_FUNCTION

FUNCTION "m7b_WEG_ZAEHLER" : VOID
TITLE =Weg-Zähler (km Zähler)
//Dieser FC arbeitet als Weg-Zähler, vergleichbar einem km-Zähler.
//
//IN: ENDODER: Positionswert des zu zählenden Encoders
//IN: INKR   : Anzahl der Weginkremente, die jeweils eine Zähleinheit bilden
//IN: FRG    : Zählfreigabe; Zählvorgang an der akt. EncoderPos. beginnen
//IN: RICHTUNG: hiermit kann die Zählrichtung für den Weg angebeben werden 0:+/1:-
//
//Der Baustein verfügt über eine integrierte Fehlerkorrektur: D.h. es soll z.B. 
//in einer Teilung von je 100 INKR gezählt werden. Dabei kommt es vor, bedingt 
//durch SPS Zykluszeit usw., das das Zählerereignis erst bei einem Weg von z.B. 
//105 INKR bearbeitet wird. Dies wird korrigiert, indem beim nächsten Mal die 
//Soll-Inkremente dann auf 95 festgelegt werden usw. Dies verhindert einen sich 
//aufschaukelden Fehler!
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 3/2003
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  ENCODER : DINT ;	//Positionswert Encoder
  INKR : DINT ;	//Inkremente für einen gezählten Wegimpuls (TEILUNG)
  FRG : BOOL ;	//Zählfreigabe
  RICHTUNG : BOOL ;	//Zählrichtung 0 = vorw. / 1 = rückw.
END_VAR
VAR_IN_OUT
  Weg : DINT ;	//Speicher für Wegwert
  tmpWeg : DINT ;	//Hilfsspeicher für Zwischenspeicherung Startwert Zählen
  tmpINKR : DINT ;	
  btmpStart : BOOL ;	//Hilfsmerker Zähler gestartet
END_VAR
VAR_TEMP
  WEGDIFF : DINT ;	
END_VAR
BEGIN
NETWORK
TITLE =

      UN    #FRG; // keine FRG
      R     #btmpStart; // Zähler gestartet clr
      BEB   ; 

NETWORK
TITLE =Zähler starten: jedesmal bei Wiederkehr von FRG neu starten

      U     #btmpStart; // Zähler bereits gestartet
      SPB   NWE; // Netzwerkende

      S     #btmpStart; // Zähler ist gestartet

      L     #ENCODER; // Encoder-Wert
      T     #tmpWeg; // als Startwert speichern

      L     #INKR; // Anzahl der zu zählenden Inkremente
      T     #tmpINKR; // in temp-Varible speichern

NWE:  NOP   0; 
NETWORK
TITLE =

      L     #ENCODER; // aktueller Encoder Wert
      L     #tmpWeg; // Hilfsspeicher StartWert Encoder
      -D    ; // zurückgelegte Strecke
      SPP   WEIT; // Wenn positiv dann weiter
      NEGD  ; // Vorzeichen drehen
WEIT: L     #tmpINKR; // Anzahl der Inkremente pro Wegeinheit
      -D    ; // >=0 : Wegeinheit erreicht; >0 zuviel gez. INKR
      SPPZ  CNT; // springe zu zählen, wenn >=0
      BEA   ; 

CNT:  L     #INKR; // Inkremente pro Wegeinheit
      TAK   ; // zu viel gezählte INKR in Akku 1 zurück
      -D    ; // Korrektur SollInkr.: beim nächsten mal weniger zählen
      T     #tmpINKR; // beim nächsten mal zu zählende Inkremente

      L     1; 
      UN    #RICHTUNG; // keine Richtungsumkehr
      SPB   INC; // Weg erhöhen
      NEGD  ; // Vorzeichen drehen
INC:  L     #Weg; 
      +D    ; 
      T     #Weg; 

      L     #ENCODER; // Encoder-Wert
      T     #tmpWeg; // als Startwert speichern

END_FUNCTION

FUNCTION "m7b_AchseReferenzieren" : VOID
TITLE =Standard Funktion Achse referenzieren
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 6/2003
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME       AENDERUNG
//--------------------------------------------------------------------------------
//07.04.2009   S.Maag     IO auf Ausgänge, REF_OK bei INIT/Reset löschen
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  REF_START : BOOL ;	//Start rererenzieren
  REF_SENSOR : BOOL ;	//Referenzsensor 1-Position
  MSG_REF_VERLASSEN : BOOL ;	//Meldung Referenzpunkt ist verlassen
  RESET : BOOL ;	
END_VAR
VAR_OUTPUT
  REF_OK : BOOL ;	//Achse ist Referenziert
  REF_FAHRT : BOOL ;	//Referenzfahrt aktiv! mit diesem Ausgang die Achse fahren
  REF_VERLASSEN : BOOL ;	//Steuerausgang Referenzpunkt verlassen
  ERROR : BOOL ;	//Fehler
END_VAR
VAR_IN_OUT
  IO_LOAD_POS : BOOL ;	//Referenzposition laden
  SNR : INT ;	//Schrittnummer
  tmpTime : TIME ;	
END_VAR
VAR_TEMP
  SysTime : TIME ;	
END_VAR
BEGIN
NETWORK
TITLE =Fehlerüberwachung, Zeitüberschreitung referenzieren

      L     #SNR; // Wenn Schrittnummer >1, dann ist
      L     1; // der Ablauf gestartet und Fehlerprüfung 
      >I    ; // findet statt
      SPBN  NOER; // sonst kein Fehler

      CALL "TIME_TCK" (// aktuelle Systemzeit
           RET_VAL                  := #SysTime);// Zwischenspeichern

      L     #tmpTime; // gespeicherte Zeit: RefSensor erreicht
      L     #SysTime; 
      UC    "m7b_ABS_DIFF_S7SysTime"; // Absolute Differenz S7SytemTimer 31Bit
      L     T#1M; // 30 sec
      >=D   ; // wenn 30 sec erreicht, dann Fehler
      SPB   ERR; 

NOER: CLR   ; // kein Fehler
ERR:  =     #ERROR; 
NETWORK
TITLE =RESET

      U     #RESET; // Schrittabläufe  clr
      SPBNB _001; 
      L     0; 
      T     #SNR; 
_001: NOP   0; 
NETWORK
TITLE =Ablauf Referenzieren: Ablaufsteuerung

      L     #SNR; // Schrittnummer
      SPL   CLR; // Sprungziel bei SNR>max
      SPA   INIT; // 0-Schritt, RESET
      SPA   S1; // Startschritt
      SPA   S2; // Schritt 2
      SPA   S3; 
      SPA   S4; 
      SPA   S5; 

CLR:  L     1; // CLR : Ablauf löschen, RESET
      T     #SNR; // Schrittnummer auf Startschritt

      SET   ; // VKE = 1
// hier die bei RESET zu löschenden Merker eintragen
      R     #IO_LOAD_POS; // Referenzposition laden clr
      R     #REF_FAHRT; // Start Referenzfahrt
      R     #REF_VERLASSEN; // zuerst Referenzpunkt verlassen

      SPA   END; 

INIT: SET   ; // Initialisierung, Null-Schritt
      R     #REF_OK; 
      SPA   CLR; 

NEXT: L     #SNR; // NEXT : Schrittnummer auf nächsten
      +     1; // Schritt
      T     #SNR; 
END:  BEA   ; 
NETWORK
TITLE =Warten auf Eingangssignal Referenzieren Start

S1:   U     #REF_START; // Eingangssignal referenzieren Start
      SPBN  END; 

      R     #REF_OK; // Refernziert clr
      R     #IO_LOAD_POS; // Referenzposition laden clr
//   S     #OUT_REF_FAHRT              // Start Referenzfahrt
      S     #REF_VERLASSEN; // zuerst Referenzpunkt verlassen
      CALL "TIME_TCK" (// Systemzeit bei Ablauf start erreicht
           RET_VAL                  := #tmpTime);

      SPA   NEXT; 

NETWORK
TITLE =Referenzpukt verlassen

S2:   U     #MSG_REF_VERLASSEN; // Meldung von aussen, Ref.Pkt. verlassen
      R     #REF_VERLASSEN; // zuerst Referenzpunkt verlassen
      S     #REF_FAHRT; // Start Referenzfahrt
      SPB   NEXT; 
      SPA   END; 
NETWORK
TITLE =Warten bis Referenzsensor erreicht

S3:   U     #REF_SENSOR; // Referenzsensor erreicht
      R     #REF_FAHRT; // Referenzfahrt clr
      SPBN  END; 

      CALL "TIME_TCK" (// Systemzeit bei Referenzsensor erreicht
           RET_VAL                  := #tmpTime);

      SPA   NEXT; 

NETWORK
TITLE =1 Sekunde Warten bis Achse steht, dann RefPos-laden

S4:   NOP   0; 

      L     #tmpTime; // gespeicherte Zeit: RefSensor erreicht
      L     #SysTime; // aktuelle Systemzeit
      -D    ; 
      SPP   PLUS; 
      NEGD  ; 
PLUS: L     T#1S; // 1 Sekunde
      >=D   ; 
      SPBN  END; 

      S     #IO_LOAD_POS; // Referenzposition laden

      SPA   NEXT; 

NETWORK
TITLE =Referenzieren beendet, Referenzposition ist geladen

S5:   UN    #IO_LOAD_POS; // Merker Load_Pos ist 0, somit ist Position geladen
      S     #REF_OK; 
      SPB   NEXT; 
      SPA   END; 

END_FUNCTION

FUNCTION "m7b_RPM_DRIVE" : VOID
TITLE =RPM Drive: Drehzahlberechnung Antrieb
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 11/2017
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//16.08.2018   S.Maag     (Fmin => %Drehzahl) Berechnung hinzugefügt  
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 1.0


VAR_INPUT
  Sollwert : INT ;	//aktueller Sollwert Freuquenzumrichter % [0..1000]
  F_maxSoll : INT ;	//Frequenz [1/10Hz) bei Sollwert = 1000
  Fmin : INT ;	//untere Frequenzgrenze Motor (z.B. 30Hz ohne Fremdlüfter)
  MOT_Fnenn : INT ;	//Motor Nennfrequenz [Hz]
  MOT_Nnenn : INT ;	//Motor Nenndrehzahl [1/min]
  Igetr : REAL ;	//Übersetzung Getriebe
  Imasch : REAL ;	//Übersetung Maschine
END_VAR
VAR_OUTPUT
  F_Motor : INT ;	//Frequenz Motor
  N_MOT : INT ;	//Drehzahl Motor
  N_Masch : INT ;	//Drehzahl Maschine
  Prozent_Fmin : INT ;	//Drehzahl %, der Fmin entspricht
END_VAR
VAR_TEMP
  rSoll : REAL ;	
  rF_MOT : REAL ;	
  rN_MOT : REAL ;	
END_VAR
BEGIN
NETWORK
TITLE =

      L     #Sollwert; 
      ITD   ; 
      DTR   ; 
      T     #rSoll; 
NETWORK
TITLE =Motorfrequenz

      L     #rSoll; 
      L     1.000000e+003; 
      /R    ; 
      L     #F_maxSoll; 
      ITD   ; 
      DTR   ; 
      *R    ; 
      T     #rF_MOT; 
      RND   ; 
      T     #F_Motor; 

NETWORK
TITLE =Motordrehzahl

      L     #rF_MOT; 
      L     #MOT_Fnenn; 
      ITD   ; 
      DTR   ; 
      /R    ; 
      L     #MOT_Nnenn; 
      ITD   ; 
      DTR   ; 
      *R    ; 
      T     #rN_MOT; 
      RND   ; 
      T     #N_MOT; 
NETWORK
TITLE =Maschinendrehzahl

      L     #Igetr; 
      L     #Imasch; 
      *R    ; 
      L     #rN_MOT; 
      *R    ; 
      RND   ; 
      T     #N_Masch; 
NETWORK
TITLE =Fmin => %Drehzahl
//16.08.2018 S.Maag
//Fmin => Drehzahl hinzugefügt
      L     #Fmin; 
      ITD   ; 
      L     L#1000; // 1000%
      *D    ; 
      L     #F_maxSoll; 
      ITD   ; 
      /D    ; 
      T     #Prozent_Fmin; 
END_FUNCTION

FUNCTION "m7b_MAPx4xBIT" : VOID
TITLE =4x mapping for BITs
//This function maps 4 individual Inputs to 4 individual Outputs using the 
//mapping table MAP_1..MAP_4. There is no check for double using an INPUT. 
//
//OUT(1)=IN(MAP_1)
//OUT(2)=IN(MAP_2)
//OUT(3)=IN(MAP_3)
//OUT(4)=IN(MAP_4)
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 07/2012
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME       AENDERUNG
//--------------------------------------------------------------------------------
//25.06.2019   S.Maag     Bei MAP3 (NW4 Sprungmarke c4:) fehlte der CLR Befehl 
//                        noch, so dass BIT 4 nicht immer korrekt durchgeschaltet
//                        wurde. Siehe Änderung vom 18.10.2012.
//                        Dieses Problem betrifft nur CPUs mit Interpreter.
//                        CPU's mit ASIC (VIPA, Siemens 318,400er)sind davon 
//                        nicht betroffen!
//
//18.10.2012   S.Maag     Siemens CPU314C verarbeitet VKE bei Sprung nicht richtig
//                        wenn Sprungziel-Nr >1. Deswegen vor jedem U-Befehl ein 
//                        CLR, somit werden alle Statusbits gelöscht und die 
//                        Verknüpfung funktioniert bei allen Sprunziel-Nummern.
//--------------------------------------------------------------------------------
//HINWEISE:
//Seit 07.04.2020 neue Version in SCL mit 2 mapping modes.      
//Für neue Projekte nur noch neue Version verwenden
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  IN_BIT_1 : BOOL ;	
  IN_BIT_2 : BOOL ;	
  IN_BIT_3 : BOOL ;	
  IN_BIT_4 : BOOL ;	
  MAP_1 : INT ;	
  MAP_2 : INT ;	
  MAP_3 : INT ;	
  MAP_4 : INT ;	
END_VAR
VAR_OUTPUT
  OUT_BIT_1 : BOOL ;	
  OUT_BIT_2 : BOOL ;	
  OUT_BIT_3 : BOOL ;	
  OUT_BIT_4 : BOOL ;	
END_VAR
VAR_TEMP
  iDIV : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =

      SET   ; 
      SAVE  ; 
      CLR   ; 

NETWORK
TITLE =MAP 1 : OUT_BIT_1 := IN_BIT(MAP_1)
//18.10.2012   S.Maag
//bei Siemens CPU314C wird Zuweisung von Bit teilweise nicht korrekt verarbeitet, 
//wenn in MAP ein Wert größer 1 steht. Bei 1 funktioniert es perfekt. Bei 2/3/4 
//nicht.
      L     #MAP_1; // MAPPING-ZIEL Eingang 1
      SPL   a0; // Sprungziel bei MAP > 4
      SPA   a0; // MAP TO 0
      SPA   a1; // MAP TO 1
      SPA   a2; // MAP TO 2
      SPA   a3; // MAP TO 3
      SPA   a4; // MAO TO 4

a0:   CLR   ; 
      SPA   aSAV; 
a1:   CLR   ; 
      U     #IN_BIT_1; 
      SPA   aSAV; 
a2:   CLR   ; 
      U     #IN_BIT_2; 
      SPA   aSAV; 
a3:   CLR   ; 
      U     #IN_BIT_3; 
      SPA   aSAV; 
a4:   CLR   ; 
      U     #IN_BIT_4; 
aSAV: =     #OUT_BIT_1; 

NETWORK
TITLE =MAP 2 : OUT_BIT_2 := IN_BIT(MAP_2)

      L     #MAP_2; // MAPPING-ZIEL Eingang 2
      SPL   b0; // Sprungziel bei MAP > 4
      SPA   b0; // MAP TO 0
      SPA   b1; // MAP TO 1
      SPA   b2; // MAP TO 2
      SPA   b3; // MAP TO 3
      SPA   b4; // MAO TO 4

b0:   CLR   ; 
      SPA   bSAV; 
b1:   CLR   ; 
      U     #IN_BIT_1; 
      SPA   bSAV; 
b2:   CLR   ; 
      U     #IN_BIT_2; 
      SPA   bSAV; 
b3:   CLR   ; 
      U     #IN_BIT_3; 
      SPA   bSAV; 
b4:   CLR   ; 
      U     #IN_BIT_4; 
bSAV: =     #OUT_BIT_2; 

NETWORK
TITLE =MAP 3: OUT_BIT_3 := IN_BIT(MAP_3)

      L     #MAP_3; // MAPPING-ZIEL Eingang 3
      SPL   c0; // Sprungziel bei MAP > 4
      SPA   c0; // MAP TO 0
      SPA   c1; // MAP TO 1
      SPA   c2; // MAP TO 2
      SPA   c3; // MAP TO 3
      SPA   c4; // MAO TO 4

c0:   CLR   ; 
      SPA   cSAV; 
c1:   CLR   ; 
      U     #IN_BIT_1; 
      SPA   cSAV; 
c2:   CLR   ; 
      U     #IN_BIT_2; 
      SPA   cSAV; 
c3:   CLR   ; 
      U     #IN_BIT_3; 
      SPA   cSAV; 
c4:   CLR   ; 
      U     #IN_BIT_4; 
cSAV: =     #OUT_BIT_3; 

NETWORK
TITLE =MAP 4 : OUT_BIT_4 := IN_BIT(MAP_4)

      L     #MAP_4; // MAPPING-ZIEL Eingang 4
      SPL   d0; // Sprungziel bei MAP > 4
      SPA   d0; // MAP TO 0
      SPA   d1; // MAP TO 1
      SPA   d2; // MAP TO 2
      SPA   d3; // MAP TO 3
      SPA   d4; // MAO TO 4

d0:   CLR   ; 
      SPA   dSAV; 
d1:   CLR   ; 
      U     #IN_BIT_1; 
      SPA   dSAV; 
d2:   CLR   ; 
      U     #IN_BIT_2; 
      SPA   dSAV; 
d3:   CLR   ; 
      U     #IN_BIT_3; 
      SPA   dSAV; 
d4:   CLR   ; 
      U     #IN_BIT_4; 
dSAV: =     #OUT_BIT_4; 

NETWORK
TITLE =



END_FUNCTION

FUNCTION "m7b_X_Switch_BYTE" : VOID
TITLE =X_Switch_BYTE : Kreuzschalter für BYTE-Werte
//KREUZSCHALTUNG
//
//X_Switch : False: 1:1 - Schaltung OUT1:IN1; OUT2=IN2
//           True :   X - Schaltung OUT1:IN2; OUT2=IN1
//
//IN1 : Eingang 1
//IN2 : Eingang 2
//OUT1: Ausgang 1
//OUT2: Ausgang 2
//
//FC-ENO : Der X_Switch Eingang wird auf ENO druchgeschleift
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2013
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE: Entstand aus FC116 X_Switch_INT
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  X_Switch : BOOL ;	//False: 1:1 Schaltung; True: X-Schaltung
  IN1 : BYTE ;	//Eingangswert 1
  IN2 : BYTE ;	//Eingangswert 2
END_VAR
VAR_OUTPUT
  OUT1 : BYTE ;	
  OUT2 : BYTE ;	
END_VAR
BEGIN
NETWORK
TITLE =Kreuschalterfunktion

      U     #X_Switch; // Wenn Kreuzschaltung aktiv
      SAVE  ; // Schalter auf ENO durchschleifen
      SPB   X; // Ausgänge kreuz geschaltet

      L     #IN1; // Ausgänge 1:1 schalten
      T     #OUT1; 

      L     #IN2; 
      T     #OUT2; 
      BEA   ; 

X:    L     #IN1; // Ausgänge über Kreuz schalten
      T     #OUT2; 

      L     #IN2; 
      T     #OUT1; 



END_FUNCTION

FUNCTION "m7b_GetBitFromByte" : VOID
TITLE =Bit mit Nr. aus Byte lesen; GetBit(IN_Byte, IN_BitNo)
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 11/2015
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME         AENDERUNG
//--------------------------------------------------------------------------------
//22.04.2020   S.Maag       Code optimiert: Abfrage <0 & >0 durch AND 7
//                          ersetzt. Indirekte Adressierung durch SRW
//--------------------------------------------------------------------------------
VERSION : 0.1


VAR_INPUT
  IN_BYTE : BYTE ;	
  IN_BitNo : INT ;	//Bit [0..7]
END_VAR
BEGIN
NETWORK
TITLE =%Byte.BitNo

      L     #IN_BitNo; // Bit-No
      UW    W#16#7; // Limit [0..7]
      +     1; // Add 1 because we must Shift 1 for Bit 0
      L     #IN_BYTE; // load the Byte
      SRW   ; // Shift right to get the selected bit
      U     >0; // IF BIT
      SAVE  ; 
END_FUNCTION

FUNCTION "m7b_SetBitInByte" : BYTE
TITLE =Bit mit Nr. in Byte zuweisen; SetBit(BitVal,myByte, BitNo)
//
//ENO : Returns the original value of the selected Bit
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 4/2020
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME         AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
VERSION : 0.1


VAR_INPUT
  IN_BitVal : BOOL ;	//Bit value to set (FALSE, TRUE)
  IN_BYTE : BYTE ;	
  IN_BitNo : INT ;	//Bit [0..7]
END_VAR
VAR_TEMP
  tmpByte : BYTE ;	
  tmpBitNo : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =%Byte.BitNo := BitVal
//ENO := %In_BYTE.BitNo;
//
//tmpByte := IN_BYTE;
//%tmpByte.BitNo := IN_BitVal;
//RET_VAL := tmpByte; 
      L     #IN_BitNo; // Bit-No
      UW    W#16#7; // Limit [0..7]
      T     #tmpBitNo; // BitNo 0..7

      L     #IN_BYTE; // Load IN_BYTE
      T     #tmpByte; // copy it to tmpByte

      L     P##tmpByte; // Pointer *Byte
      L     #tmpBitNo; // + BitNo
      +D    ; // = Pointer *Byte.BitNo 
      LAR1  ; // Load *Byte.BitNo in AddressRegister 1 

      U      [AR1,P#0.0]; // Get the original BitValue %IN_BYTE.BitNo
      SAVE  ; // ENO := %IN_BYTE.BitNo
      CLR   ; 

      U     #IN_BitVal; // The BitValue (True or False)
      =      [AR1,P#0.0]; // *Byte.BitNo := BitVal
      L     #tmpByte; // The modified Byte
      T     #RET_VAL; // Return the modified Byte

END_FUNCTION

FUNCTION "m7b_RP_COPY_CHRONO" : VOID
TITLE =RP_COPY_CHRONO: kopiert Ringpuffer in choronologischer Folge
//Kopiert einen Ringpuffer. Die Daten werden dabei chronologisch in aufsteigender 
//Reihenfolge angeordnet. D.h. am Anfang des Zieldatenbereichs steht der älteste 
//Wert, am Ende der Neueste.
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 1/2005
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE: getestet 10.01.2005
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  QUELL_DB : INT ;	
  ZIEL_DB : INT ;	
  QUELL_DW : INT ;	
  ZIEL_DW : INT ;	
  ANZAHL : INT ;	
  ptrRP : INT ;	
  RP_VOLL : BOOL ;	
END_VAR
VAR_TEMP
  Quell_DB_Nr : INT ;	
  Ziel_Db_Nr : INT ;	
  QUELL_ADR : DINT ;	
  ZIEL_ADR : DINT ;	
  LOOP : INT ;	
  ACTIVE_DI : INT ;	//Zwichenspeicher Nr. aktiver Instanzdatenbaustein
  AR1 : DWORD ;	
  AR2 : DWORD ;	
  END_ADR : DINT ;	
  Quell_ADR_1 : DINT ;	//Quelladresse des 1. zu kopierenden Datenblocks
  Ziel_ADR_2 : DINT ;	//Zieladresse des 2. zu kopierenden Datenblocks
  ANZAHL1 : INT ;	//Anzahl DW des 1. zu kopierenden Blocks
  ANZAHL2 : INT ;	//Anzahl DW des 2. zu kopierenden Blocks
END_VAR
BEGIN
NETWORK
TITLE =Register sichern

      L     DINO; // Nr. Instanzdatenbaustein in AKKU
      T     #ACTIVE_DI; 
      TAR1  #AR1; // Adressregister 1 sichern
      TAR2  #AR2; // Adressregister 2 sichern

NETWORK
TITLE =Datenbausteinnummern müssen auf Temp-Variablen kopiert werden

      L     #QUELL_DB; 
      T     #Quell_DB_Nr; 

      L     #ZIEL_DB; 
      T     #Ziel_Db_Nr; 
NETWORK
TITLE =Variablen initalisieren, bei welchen dies nötig ist

      L     0; 
      T     #ANZAHL1; 
      T     #ANZAHL2; 

NETWORK
TITLE =Endadresse Quell-Datenbereich berechnen

      L     #QUELL_DW; 
      L     #ANZAHL; 
      SLW   1; 
      +D    ; 
      +     L#-2; 
      T     #END_ADR; 
NETWORK
TITLE =1. zu kopierender Datenblock
//Der 1. zu kopierende Datenblock enthält die älteseten Ringpufferdaten. Also 
//alle Daten ab der Adresse des aktuellen Pointers (Pointer zeigt immer auf die 
//Adresse des als nächstes zu schreibenden Wertes, die ist gleichzeitig der 
//älteste Wert im Puffer) 
//Ringpuffers.
      L     #ptrRP; // Pointer Ringpuffer (ByteAdresse)
      T     #Quell_ADR_1; // Stardadresse 1. zu kopierender Block

      L     #END_ADR; // Wenn END_ADR <= Pointer,
      L     #ptrRP; // dann kann kein hinterer
      -D    ; 
      SRD   1; // halbieren, da Byteadressen
      T     #ANZAHL1; // Anzahl zu kopierender DW

NETWORK
TITLE =Adressen für Quell und Ziel-DW als Pointer in Adressregister

      L     #Quell_ADR_1; // Quelldatenwort-Nr 
      SLD   3; // als Pointer
      L     P#0.0; 
      +D    ; 
      LAR1  ; // ins Adressregister 1

      L     #ZIEL_DW; // Zieldatenwort-Nr
      SLD   3; // als Pointer 
      L     P#0.0; 
      +D    ; 
      LAR2  ; // ins Adressregister 2
NETWORK
TITLE =Daten kopieren
//Schnelle Kopierroutine: kopiert Blöcke von Datenworten in 4 Byte Schritten
//Quell- und Ziel- DB müssen nur einmal geöffnet werden.
      AUF   DI [#Quell_DB_Nr]; // Quell-DB als Instanz-DB öffnen
      AUF   DB [#Ziel_Db_Nr]; // Ziel-DB als Global-DB öffnen

      L     #ANZAHL1; // Anzahl der zu kopierenden DW's (Anzahl der 16 Bit-Werte)
      SRW   1; // in Anzahl der 32-Bit-Werte umrechen
LOOP: L     DID [AR1,P#0.0]; // Quell-DW lesen
      T     DBD [AR2,P#0.0]; // Ziel-DW lesen
      +AR1  P#4.0; // Quell-Pointer in AR1 um 4 Bytes erhöhen
      +AR2  P#4.0; // Ziel-Pointer in AR2 um 4 Bytes erhöhen
      TAK   ; // Schleifenzählr wieder in Akku 1 zurück
      LOOP  LOOP; // Schleifenzähler bearbeiten

      L     #ANZAHL1; // nun noch prüfen ob noch ein 16-Bit-Wert kopiert werden muss
      SRW   1; // LSB von Anzahl wird in Ergebnisvorzeichenregister geschoben
      SPZ   END; // prüft somit, ob LSB von ANZAHL = 1 ist
      L     DIW [AR1,P#0.0]; // Dann muss das letze DW noch kopiert werden
      T     DBW [AR2,P#0.0]; 
NETWORK
TITLE =Anzahl Datenworte des 2. zu kopierenden Blocks

      NOP   0; 
      L     #ANZAHL; // gesamte Anzahl zu kopierender Datenworte
      L     #ANZAHL1; // Anzahl der im 1. Durchgang kopierten Datenworte
      -I    ; // 
      T     #ANZAHL2; // Anzahl der im 2. Durchgang zu kopierenden Worte
      SPMZ  END; // springt zum Ende, wenn Ergebnis <=0

NETWORK
TITLE =Zieladresse 2. zu kopierender Block

      L     #ANZAHL1; // Anzahl Datenworte
      L     #ZIEL_DW; 
      +I    ; // Anzahl 2x zu Ziel_DW zählen
      +I    ; // wegen Byteadressen
      T     #Ziel_ADR_2; 
NETWORK
TITLE =Adressen für Quell und Ziel-DW als Pointer in Adressregister

      L     #QUELL_DW; // Quelldatenwort-Nr 
      SLD   3; // als Pointer
      L     P#0.0; 
      +D    ; 
      LAR1  ; // ins Adressregister 1

      L     #Ziel_ADR_2; // Zieldatenwort-Nr
      SLD   3; // als Pointer 
      L     P#0.0; 
      +D    ; 
      LAR2  ; // ins Adressregister 2
NETWORK
TITLE =Daten kopieren

      AUF   DI [#Quell_DB_Nr]; // Quell-DB als Instanz-DB öffnen
      AUF   DB [#Ziel_Db_Nr]; // Ziel-DB als Global-DB öffnen

      L     #ANZAHL2; // Anzahl der zu kopierenden DW's (Anzahl der 16 Bit-Werte)
      SRW   1; // in Anzahl der 32-Bit-Werte umrechen
LP2:  L     DID [AR1,P#0.0]; // Quell-DW lesen
      T     DBD [AR2,P#0.0]; // Ziel-DW lesen
      +AR1  P#4.0; // Quell-Pointer in AR1 um 4 Bytes erhöhen
      +AR2  P#4.0; // Ziel-Pointer in AR2 um 4 Bytes erhöhen
      TAK   ; // Schleifenzählr wieder in Akku 1 zurück
      LOOP  LP2; // Schleifenzähler bearbeiten

      L     #ANZAHL2; // nun noch prüfen ob noch ein 16-Bit-Wert kopiert werden muss
      SRW   1; // LSB von Anzahl wird in Ergebnisvorzeichenregister geschoben
      SPZ   END; // prüft somit, ob LSB von ANZAHL = 1 ist
      L     DIW [AR1,P#0.0]; // Dann muss das letze DW noch kopiert werden
      T     DBW [AR2,P#0.0]; 
NETWORK
TITLE =Registerinhalte wieder herstellen

END:  AUF   DI [#ACTIVE_DI]; // Activen Instanz-DB wieder herstellen
      LAR1  #AR1; // Adressregister 1 wieder herstellen
      LAR2  #AR2; // Adressregister 2 wieder herstellen

      SET   ; 
      SAVE  ; 
      CLR   ; 
END_FUNCTION

FUNCTION "m7b_ChangeEvent_INT" : VOID
TITLE =Ereignis INT Wert hat sich geändert
//Der FC-ENO-Ausgang wird für einen Zyklus "1", wenn der sich der Eingangswert 
//geändert hat, ansonsten ist der FC-ENO-Ausgang "0"
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  inINT : INT ;	
END_VAR
VAR_IN_OUT
  memINT : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =

      L     #inINT; // Eingangwert
      L     #memINT; // letzter Wert
      <>I   ; // ungleich!
      SAVE  ; // als ENO ausgeben
      SPB   do; // und neuen
      BEA   ; 
do:   L     #inINT; // Wert speichern
      T     #memINT; 

END_FUNCTION

FUNCTION "m7b_RP_WRITE_INT" : VOID
TITLE =Ringpuffer schreiben INT-Werte
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 7/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//09.07.2010   S.Maag      ENO nur True, wenn Ringpuffer geschrieben/verarbeitet
//                         wird, sonst FALSE
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  DB_RP : BLOCK_DB ;	
  RP_POS : BOOL ;	//Ringpuffer schreiben positiv
  RP_NEG : BOOL ;	//Ringpuffer schreiben negativ
  IN_INT : INT ;	//Eingangswert INT
END_VAR
VAR_IN_OUT
  RP_IDX : INT ;	//Indexwert Ringpuffer 0..255
END_VAR
VAR_TEMP
  AR1 : DWORD ;	
END_VAR
BEGIN
NETWORK
TITLE =

      TAR1  #AR1; // Adressregister 1 sichern

NETWORK
TITLE =

      U     #RP_POS; // positiver Impuls := Ringpuffer vorwärts
      SPB   pos; 

      U     #RP_NEG; // negativer Impuls := Ringpuffer rückwärts
      SPB   neg; 

      CLR   ; // ENO = FALSE, => keine Verarbeitung
      SAVE  ; 
      BEA   ; 

pos:  L     #RP_IDX; // positiver Impuls := Ringpuffer vorwärts
      INC   1; // INC: Bytebefehl 0..255
      SPA   save; 

neg:  L     #RP_IDX; // negativer Impuls := Ringpuffer rückwärts
      DEC   1; // DEC: Bytebefehl 0..255

save: T     #RP_IDX; // Indexwert Ringpuffer 0..255
      SLD   4; // SLD 1 wegen DINT-Werten=>Byte + SLD 3 wegen Pointer
      L     P#0.0; // 0-Pointer addieren
      +D    ; // Pointer auf Daten erzeugen
      LAR1  ; // in Adressregister 1 laden

      AUF   #DB_RP; // Ringpuffer DB öffnen
      L     #IN_INT; // Eingangswert laden
      T     DBW [AR1,P#0.0]; // in DB speichern

      LAR1  #AR1; // ursprüngliches Adressregister 1 herstellen
      SET   ; // ENO = TRUE, => Verarbeitung
      SAVE  ; 
      BEA   ; 


END_FUNCTION

FUNCTION "m7b_RP_READ_INT" : INT
TITLE =Ringpuffer lesen INT-Werte
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 7/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  DB_RP : BLOCK_DB ;	
  RP_IDX : INT ;	//Ringpuffer Index
  RP_OFFSET : INT ;	//Offeset Ringpufferindex
END_VAR
VAR_TEMP
  AR1 : DWORD ;	
END_VAR
BEGIN
NETWORK
TITLE =

      TAR1  #AR1; // Adressregister 1 sichern

      L     #RP_IDX; // aktueller Ringpuffer-Index
      L     #RP_OFFSET; // Offset für lesen
      -I    ; 
      L     W#16#FF; // auf 0..255 begrenzen
      UW    ; 
      SLD   4; // SLD 1 wegen DINT-Werten=>Byte + SLD 3 wegen Pointer
      L     P#0.0; // 0-Pointer addieren
      +D    ; // Pointer auf Daten erzeugen
      LAR1  ; // in Adressregister 1 laden

      AUF   #DB_RP; // Ringpuffer DB öffnen
      L     DBW [AR1,P#0.0]; // Wert aus Ringpuffer laden
      T     #RET_VAL; // Rückgabewert

      LAR1  #AR1; // ursprüngliches Adressregister 1 herstellen
      SET   ; 
      SAVE  ; 
      CLR   ; 

END_FUNCTION

FUNCTION "m7b_MUXx3xINT" : INT
TITLE =3-fach Integer Multiplexer
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2003
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//24.04.2009   S.Maag      EN0 := Signal Wert selektiert 
//                               (S1 | S2 | S3)  AND ENABLE
//
//29.01.2013   S.Maag      Anzeige aktiver Kanal (DSP_CHANNEL)
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 2.0


VAR_INPUT
  S1 : BOOL ;	
  S2 : BOOL ;	
  S3 : BOOL ;	
  ENABLE : BOOL ;	
  INT1 : INT ;	
  INT2 : INT ;	
  INT3 : INT ;	
END_VAR
VAR_OUTPUT
  DSP_CHANNEL : INT ;	//Displays the activated channel
END_VAR
BEGIN
NETWORK
TITLE =

      UN    #ENABLE; // keine Freigabe, dann 0 ausgeben
      SPB   STOP; 

      U     #S1; 
      SPB   S1; 
      U     #S2; 
      SPB   S2; 
      U     #S3; 
      SPB   S3; 

      SPA   STOP; 

S1:   L     1; // Wert für Kanalanzeige
      L     #INT1; 
      SPA   SAVE; 

S2:   L     2; 
      L     #INT2; 
      SPA   SAVE; 

S3:   L     3; 
      L     #INT3; 
      SPA   SAVE; 

STOP: CLR   ; // EN0-Ausgang =0, da Stopp
      L     0; // Wert für Kanalanzeige
      L     0; // Wert für Multiplexer

SAVE: SAVE  ; 
      T     #RET_VAL; // Mulitplexer Ausgang
      TAK   ; // Wert aktiver Kanal
      T     #DSP_CHANNEL; // Anzeige aktiver Kanal


END_FUNCTION

FUNCTION "m7b_MUXx4xINT" : INT
TITLE =4-fach Integer Multiplexer
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//25.08.2008   S.Maag      enstanden aus MUXx3xINT
//
//24.04.2009   S.Maag      EN0 := Signal Wert selektiert 
//                               (S1 | S2 | S3)  AND ENABLE
//
//29.01.2013   S.Maag      Anzeige aktiver Kanal (DSP_CHANNEL)
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 2.0


VAR_INPUT
  S1 : BOOL ;	
  S2 : BOOL ;	
  S3 : BOOL ;	
  S4 : BOOL ;	
  ENABLE : BOOL ;	
  INT1 : INT ;	
  INT2 : INT ;	
  INT3 : INT ;	
  INT4 : INT ;	
END_VAR
VAR_OUTPUT
  DSP_CHANNEL : INT ;	//Displays the activated channel
END_VAR
BEGIN
NETWORK
TITLE =

      UN    #ENABLE; // keine Freigabe, dann 0 ausgeben
      SPB   STOP; 

      U     #S1; 
      SPB   S1; 
      U     #S2; 
      SPB   S2; 
      U     #S3; 
      SPB   S3; 
      U     #S4; 
      SPB   S4; 

      SPA   STOP; 

S1:   L     1; // Wert für Kanalanzeige
      L     #INT1; 
      SPA   SAVE; 

S2:   L     2; 
      L     #INT2; 
      SPA   SAVE; 

S3:   L     3; 
      L     #INT3; 
      SPA   SAVE; 

S4:   L     4; 
      L     #INT4; 
      SPA   SAVE; 

STOP: CLR   ; // EN0-Ausgang =0, da Stopp
      L     0; // Wert für Kanalanzeige
      L     0; // Wert für Multiplexer

SAVE: SAVE  ; 
      T     #RET_VAL; // Mulitplexer Ausgang
      TAK   ; // Wert aktiver Kanal
      T     #DSP_CHANNEL; // Anzeige aktiver Kanal

END_FUNCTION

FUNCTION "m7b_MAPx4xINT" : VOID
TITLE =4x mapping for INTEGER
//This function maps 4 individual Inputs to 4 individual Outputs using the 
//mapping table MAP_1..MAP_4. There is no check for double using an INPUT. 
//
//OUT(1)=IN(MAP_1)
//OUT(2)=IN(MAP_2)
//OUT(3)=IN(MAP_3)
//OUT(4)=IN(MAP_4)
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 07/2012
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME       AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//HINWEISE:
//Seit 07.04.2020 neue Version in SCL mit 2 mapping Modes.      
//Für neue Projekte nur noch neue Version verwenden
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  IN_1 : INT ;	//Input Value 1
  IN_2 : INT ;	//Input Value 2
  IN_3 : INT ;	//Input Value 3
  IN_4 : INT ;	//Input Value 4
  ZERO_VAL : INT ;	//Zero Value (used as 'zero', if no mapping)
  MAP_1 : INT ;	//Source Nr. for OUT_1: OUT_1=IN(MAP_1)
  MAP_2 : INT ;	//Source Nr. for OUT_2: OUT_2=IN(MAP_2)
  MAP_3 : INT ;	//Source Nr. for OUT_3: OUT_3=IN(MAP_3)
  MAP_4 : INT ;	//Source Nr. for OUT_4: OUT_3=IN(MAP_4)
END_VAR
VAR_OUTPUT
  OUT_1 : INT ;	
  OUT_2 : INT ;	
  OUT_3 : INT ;	
  OUT_4 : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =

      SET   ; 
      SAVE  ; 
      CLR   ; 

NETWORK
TITLE =MAP 1 : OUT_1 := IN (MAP_1)

      L     #MAP_1; // MAPPING-ZIEL Eingang 1
      SPL   a0; // Sprungziel bei MAP > 4
      SPA   a0; // MAP TO 0
      SPA   a1; // MAP TO 1
      SPA   a2; // MAP TO 2
      SPA   a3; // MAP TO 3
      SPA   a4; // MAO TO 4

a0:   L     #ZERO_VAL; 
      SPA   aSAV; 
a1:   L     #IN_1; 
      SPA   aSAV; 
a2:   L     #IN_2; 
      SPA   aSAV; 
a3:   L     #IN_3; 
      SPA   aSAV; 
a4:   L     #IN_4; 
aSAV: T     #OUT_1; 
NETWORK
TITLE =MAP 2 : OUT_2 := IN (MAP_2)

      L     #MAP_2; // MAPPING-ZIEL Eingang 2
      SPL   b0; // Sprungziel bei MAP > 4
      SPA   b0; // MAP TO 0
      SPA   b1; // MAP TO 1
      SPA   b2; // MAP TO 2
      SPA   b3; // MAP TO 3
      SPA   b4; // MAO TO 4

b0:   L     #ZERO_VAL; 
      SPA   bSAV; 
b1:   L     #IN_1; 
      SPA   bSAV; 
b2:   L     #IN_2; 
      SPA   bSAV; 
b3:   L     #IN_3; 
      SPA   bSAV; 
b4:   L     #IN_4; 
bSAV: T     #OUT_2; 
NETWORK
TITLE =MAP 3 : OUT_3 := IN (MAP_3)

      L     #MAP_3; // MAPPING-ZIEL Eingang 3
      SPL   c0; // Sprungziel bei MAP > 4
      SPA   c0; // MAP TO 0
      SPA   c1; // MAP TO 1
      SPA   c2; // MAP TO 2
      SPA   c3; // MAP TO 3
      SPA   c4; // MAO TO 4

c0:   L     #ZERO_VAL; 
      SPA   cSAV; 
c1:   L     #IN_1; 
      SPA   cSAV; 
c2:   L     #IN_2; 
      SPA   cSAV; 
c3:   L     #IN_3; 
      SPA   cSAV; 
c4:   L     #IN_4; 
cSAV: T     #OUT_3; 
NETWORK
TITLE =MAP 4 : OUT_4 := IN (MAP_4)

      L     #MAP_4; // MAPPING-ZIEL Eingang 4
      SPL   d0; // Sprungziel bei MAP > 4
      SPA   d0; // MAP TO 0
      SPA   d1; // MAP TO 1
      SPA   d2; // MAP TO 2
      SPA   d3; // MAP TO 3
      SPA   d4; // MAO TO 4

d0:   L     #ZERO_VAL; 
      SPA   dSAV; 
d1:   L     #IN_1; 
      SPA   dSAV; 
d2:   L     #IN_2; 
      SPA   dSAV; 
d3:   L     #IN_3; 
      SPA   dSAV; 
d4:   L     #IN_4; 
dSAV: T     #OUT_4; 
END_FUNCTION

FUNCTION "m7b_X_Switch_INT" : VOID
TITLE =X_Switch_INT : Kreuzschalter für INT-Werte
//KREUZSCHALTUNG
//
//X_Switch : False: 1:1 - Schaltung OUT1:IN1; OUT2=IN2
//           True :   X - Schaltung OUT1:IN2; OUT2=IN1
//
//IN1 : Eingang 1
//IN2 : Eingang 2
//OUT1: Ausgang 1
//OUT2: Ausgang 2
//
//FC-ENO : Der X_Switch Eingang wird auf ENO druchgeschleift
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 03/2009
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  X_Switch : BOOL ;	//False: 1:1 Schaltung; True: X-Schaltung
  IN1 : INT ;	//Eingangswert 1
  IN2 : INT ;	//Eingangswert 2
END_VAR
VAR_OUTPUT
  OUT1 : INT ;	
  OUT2 : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =Kreuschalterfunktion

      U     #X_Switch; // Wenn Kreuzschaltung aktiv
      SAVE  ; // Schalter auf ENO durchschleifen
      SPB   X; // Ausgänge kreuz geschaltet

      L     #IN1; // Ausgänge 1:1 schalten
      T     #OUT1; 

      L     #IN2; 
      T     #OUT2; 
      BEA   ; 

X:    L     #IN1; // Ausgänge über Kreuz schalten
      T     #OUT2; 

      L     #IN2; 
      T     #OUT1; 



END_FUNCTION

FUNCTION "m7b_InvertRange_INT" : INT
TITLE =InvertRange_INT: Invertiert einen Bereich (Messrichtungsumkehr)
//Invertiert einen Wertebereich (Messrichtungsumkehr), vertauscht sozusagen Ober- 
//und Untergrenze.
//Bei symetrischen Wertebereichen: MIN = -MAX ist das einfach eine 
//Vorzeichenumkehr.
//
//ENO : Übersteuerungsanzeige: der invertierte Wert liegt ausserhalb des 
//      Wertebereichs. Dieses Signal kann z.B. dazu verwendet werden um
//      eine gesonderte verarbeitung im Fehlerfalle druchzuführen.
//
//
//z.B. MIN=-100 MAX=100 VALUE=20 : Xinv= -20
//     MIN=  20 MAX=100 VALUE=20 : Xinv= 100
//                      VALUE=50 : Xinv=  70 
//                          
//Xinv= MIN + MAX - VALUE 
// 
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  VALUE : INT ;	//Value to invert
  MIN : INT ;	//Minimum of Range
  MAX : INT ;	//Maximum of Range
END_VAR
BEGIN
NETWORK
TITLE =Invert Range: Wertebereich umkehren
//Xinv= MAX - VALUE + MIN  :  Bessere Berechnung wegen Überläufen
      L     #MAX; 
      L     #VALUE; 
      -I    ; 
      L     #MIN; 
      +I    ; 
      T     #RET_VAL; 
NETWORK
TITLE =FC-ENO-Ausgang als Übersteuerungsanzeige

      L     #MAX; // Maximalwert
      >I    ; // Wert > MAX
      SPB   SAVE; // Max-Wert überschritten
      TAK   ; // Ausgangswert in Akku 1 zurueck
      L     #MIN; 
      <I    ; 
      SPB   SAVE; // MinWert unterschritten
      CLR   ; 
SAVE: SAVE  ; 
      CLR   ; 
END_FUNCTION

FUNCTION "m7b_MinDiffABS_INT" : VOID
TITLE =MinDiffABS_INT: Minimale Absolutdifferenz 2er INT-Werte ok! 
//Überprüft, ob die absolute Differenz (absolut) zweier INT dem angebegenen 
//Mindestwert entspricht. Wenn ja, dann wird ENO=True
//
//BENÖTIGTE SFCs: keine
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//10.09.2020   S.Maag      Ausgang iDiff hinzugefügt
//--------------------------------------------------------------------------------
//
//HINWEISE: 
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  VAL_1 : INT ;	
  VAL_2 : INT ;	
  MinDiff : INT ;	
END_VAR
VAR_OUTPUT
  iDiff : INT ;	//Differenz=ABS(VAL_1-VAL_2)
END_VAR
VAR_TEMP
  aktSysTime : TIME ;	//aktuelle Systemzeit
END_VAR
BEGIN
NETWORK
TITLE =prüfen ob Differenz ok

      L     #VAL_1; 
      L     #VAL_2; 
      -I    ; 
      SPP   pos; 
      NEGI  ; 
pos:  T     #iDiff; 
      L     #MinDiff; 
      >=I   ; 
      SAVE  ; 

END_FUNCTION

FUNCTION "m7b_ChangeEvent_DINT" : VOID
TITLE =Ereignis DINT Wert hat sich geändert
//Der FC-ENO-Ausgang wird für einen Zyklus "1", wenn der sich der Eingangswert 
//geändert hat, ansonsten ist der FC-ENO-Ausgang "0"
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  inDINT : DINT ;	
END_VAR
VAR_IN_OUT
  memDINT : DINT ;	
END_VAR
BEGIN
NETWORK
TITLE =

      L     #inDINT; // Eingangwert
      L     #memDINT; // letzter Wert
      <>D   ; // ungleich!
      SAVE  ; // als ENO ausgeben
      SPB   do; // und neuen
      BEA   ; 
do:   L     #inDINT; // Wert speichern
      T     #memDINT; 

END_FUNCTION

FUNCTION "m7b_RP_WRITE_DINT" : VOID
TITLE =Ringpuffer schreiben DINT-Werte
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 7/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//09.07.2010   S.Maag      ENO nur True, wenn Ringpuffer geschrieben/verarbeitet
//                         wird, sonst FALSE
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  DB_RP : BLOCK_DB ;	
  RP_POS : BOOL ;	//Ringpuffer schreiben positiv
  RP_NEG : BOOL ;	//Ringpuffer schreiben negativ
  IN_DINT : DINT ;	//Eingangswert DINT
END_VAR
VAR_IN_OUT
  RP_IDX : INT ;	//Indexwert Ringpuffer 0..255
END_VAR
VAR_TEMP
  AR1 : DWORD ;	
END_VAR
BEGIN
NETWORK
TITLE =

      TAR1  #AR1; // Adressregister 1 sichern

NETWORK
TITLE =

      U     #RP_POS; // positiver Impuls := Ringpuffer vorwärts
      SPB   pos; 

      U     #RP_NEG; // negativer Impuls := Ringpuffer rückwärts
      SPB   neg; 

      CLR   ; // ENO = FALSE, => keine Verarbeitung
      SAVE  ; 
      BEA   ; 

pos:  L     #RP_IDX; // positiver Impuls := Ringpuffer vorwärts
      INC   1; // INC: Bytebefehl 0..255
      SPA   save; 

neg:  L     #RP_IDX; // negativer Impuls := Ringpuffer rückwärts
      DEC   1; // DEC: Bytebefehl 0..255

save: T     #RP_IDX; // Indexwert Ringpuffer 0..255
      SLD   5; // SLD 2 wegen DINT-Werten=>Byte + SLD 3 wegen Pointer
      L     P#0.0; // 0-Pointer addieren
      +D    ; // Pointer auf Daten erzeugen
      LAR1  ; // in Adressregister 1 laden

      AUF   #DB_RP; // Ringpuffer DB öffnen
      L     #IN_DINT; // Eingangswert laden
      T     DBD [AR1,P#0.0]; // in DB speichern

      LAR1  #AR1; // ursprüngliches Adressregister 1 herstellen
      SET   ; // ENO = TRUE, => Verarbeitung
      SAVE  ; 
      BEA   ; 


END_FUNCTION

FUNCTION "m7b_RP_READ_DINT" : DINT
TITLE =Ringpuffer lesen DINT-Werte
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 7/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  DB_RP : BLOCK_DB ;	
  RP_IDX : INT ;	//Ringpuffer Index
  RP_OFFSET : INT ;	//Offeset Ringpufferindex
END_VAR
VAR_TEMP
  AR1 : DWORD ;	
END_VAR
BEGIN
NETWORK
TITLE =

      TAR1  #AR1; // Adressregister 1 sichern

      L     #RP_IDX; // aktueller Ringpuffer-Index
      L     #RP_OFFSET; // Offset für lesen
      -I    ; 
      L     W#16#FF; // auf 0..255 begrenzen
      UW    ; 
      SLD   5; // SLD 2 wegen DINT-Werten=>Byte + SLD 3 wegen Pointer
      L     P#0.0; // 0-Pointer addieren
      +D    ; // Pointer auf Daten erzeugen
      LAR1  ; // in Adressregister 1 laden

      AUF   #DB_RP; // Ringpuffer DB öffnen
      L     DBD [AR1,P#0.0]; // Wert aus Ringpuffer laden
      T     #RET_VAL; // Rückgabewert

      LAR1  #AR1; // ursprüngliches Adressregister 1 herstellen
      SET   ; 
      SAVE  ; 
      CLR   ; 

END_FUNCTION

FUNCTION "m7b_MUXx3xDINT" : DINT
TITLE =3-fach DINT Multiplexer
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2003
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//24.04.2009   S.Maag      EN0 := Signal Wert selektiert 
//                               (S1 | S2 | S3)  AND ENABLE
//
//29.01.2013   S.Maag      Anzeige aktiver Kanal (DSP_CHANNEL)
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 2.0


VAR_INPUT
  S1 : BOOL ;	
  S2 : BOOL ;	
  S3 : BOOL ;	
  ENABLE : BOOL ;	
  DINT1 : DINT ;	
  DINT2 : DINT ;	
  DINT3 : DINT ;	
END_VAR
VAR_OUTPUT
  DSP_CHANNEL : INT ;	//Displays the activated channel
END_VAR
BEGIN
NETWORK
TITLE =

      UN    #ENABLE; // keine Freigabe, dann 0 ausgeben
      SPB   STOP; 

      U     #S1; 
      SPB   S1; 
      U     #S2; 
      SPB   S2; 
      U     #S3; 
      SPB   S3; 

      SPA   STOP; 

S1:   L     1; // Wert für Kanalanzeige
      L     #DINT1; 
      SPA   SAVE; 

S2:   L     2; 
      L     #DINT2; 
      SPA   SAVE; 

S3:   L     3; 
      L     #DINT3; 
      SPA   SAVE; 

STOP: CLR   ; // EN0-Ausgang =0, da Stopp
      L     0; // Wert für Kanalanzeige
      L     L#0; // Wert für Multiplexer

SAVE: SAVE  ; 
      T     #RET_VAL; // Mulitplexer Ausgang
      TAK   ; // Wert aktiver Kanal
      T     #DSP_CHANNEL; // Anzeige aktiver Kanal

END_FUNCTION

FUNCTION "m7b_MUXx4xDINT" : DINT
TITLE =4-fach DINT Multiplexer
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//25.08.2008   S.Maag      enstanden aus MUXx3xINT
//
//24.04.2009   S.Maag      EN0 := Signal Wert selektiert 
//                               (S1 | S2 | S3)  AND ENABLE
//
//29.01.2013   S.Maag      Anzeige aktiver Kanal (DSP_CHANNEL)
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 2.0


VAR_INPUT
  S1 : BOOL ;	
  S2 : BOOL ;	
  S3 : BOOL ;	
  S4 : BOOL ;	
  ENABLE : BOOL ;	
  DINT1 : DINT ;	
  DINT2 : DINT ;	
  DINT3 : DINT ;	
  DINT4 : DINT ;	
END_VAR
VAR_OUTPUT
  DSP_CHANNEL : INT ;	//Displays the activated channel
END_VAR
BEGIN
NETWORK
TITLE =

      UN    #ENABLE; // keine Freigabe, dann 0 ausgeben
      SPB   STOP; 

      U     #S1; 
      SPB   S1; 
      U     #S2; 
      SPB   S2; 
      U     #S3; 
      SPB   S3; 
      U     #S4; 
      SPB   S4; 

      SPA   STOP; 

S1:   L     1; // Wert für Kanalanzeige
      L     #DINT1; 
      SPA   SAVE; 

S2:   L     2; 
      L     #DINT2; 
      SPA   SAVE; 

S3:   L     3; 
      L     #DINT3; 
      SPA   SAVE; 

S4:   L     4; 
      L     #DINT4; 
      SPA   SAVE; 

STOP: CLR   ; // EN0-Ausgang =0, da Stopp
      L     0; // Wert für Kanalanzeige
      L     L#0; // Wert für Multiplexer

SAVE: SAVE  ; 
      T     #RET_VAL; // Mulitplexer Ausgang
      TAK   ; // Wert aktiver Kanal
      T     #DSP_CHANNEL; // Anzeige aktiver Kanal

END_FUNCTION

FUNCTION "m7b_MAPx4xDINT" : VOID
TITLE =4x mapping for DOUBLE INTEGER
//This function maps 4 individual Inputs to 4 individual Outputs using the 
//mapping table MAP_1..MAP_4. There is no check for double using an INPUT. 
//
//OUT(1)=IN(MAP_1)
//OUT(2)=IN(MAP_2)
//OUT(3)=IN(MAP_3)
//OUT(4)=IN(MAP_4)
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 07/2012
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//HINWEISE:
//Seit 07.04.2020 neue Version in SCL mit 2 mapping Modes.      
//Für neue Projekte nur noch neue Version verwenden
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  IN_1 : DINT ;	//Input Value 1
  IN_2 : DINT ;	//Input Value 2
  IN_3 : DINT ;	//Input Value 3
  IN_4 : DINT ;	//Input Value 4
  ZERO_VAL : DINT ;	//Zero Value (used as 'zero', if no mapping)
  MAP_1 : INT ;	//Source Nr. for OUT_1: OUT_1=IN(MAP_1)
  MAP_2 : INT ;	//Source Nr. for OUT_2: OUT_2=IN(MAP_2)
  MAP_3 : INT ;	//Source Nr. for OUT_3: OUT_3=IN(MAP_3)
  MAP_4 : INT ;	//Source Nr. for OUT_4: OUT_3=IN(MAP_4)
END_VAR
VAR_OUTPUT
  OUT_1 : DINT ;	
  OUT_2 : DINT ;	
  OUT_3 : DINT ;	
  OUT_4 : DINT ;	
END_VAR
BEGIN
NETWORK
TITLE =

      SET   ; 
      SAVE  ; 
      CLR   ; 

NETWORK
TITLE =MAP 1 : OUT_1 := IN (MAP_1)

      L     #MAP_1; // MAPPING-ZIEL Eingang 1
      SPL   a0; // Sprungziel bei MAP > 4
      SPA   a0; // MAP TO 0
      SPA   a1; // MAP TO 1
      SPA   a2; // MAP TO 2
      SPA   a3; // MAP TO 3
      SPA   a4; // MAO TO 4

a0:   L     #ZERO_VAL; 
      SPA   aSAV; 
a1:   L     #IN_1; 
      SPA   aSAV; 
a2:   L     #IN_2; 
      SPA   aSAV; 
a3:   L     #IN_3; 
      SPA   aSAV; 
a4:   L     #IN_4; 
aSAV: T     #OUT_1; 
NETWORK
TITLE =MAP 2 : OUT_2 := IN (MAP_2)

      L     #MAP_2; // MAPPING-ZIEL Eingang 2
      SPL   b0; // Sprungziel bei MAP > 4
      SPA   b0; // MAP TO 0
      SPA   b1; // MAP TO 1
      SPA   b2; // MAP TO 2
      SPA   b3; // MAP TO 3
      SPA   b4; // MAO TO 4

b0:   L     #ZERO_VAL; 
      SPA   bSAV; 
b1:   L     #IN_1; 
      SPA   bSAV; 
b2:   L     #IN_2; 
      SPA   bSAV; 
b3:   L     #IN_3; 
      SPA   bSAV; 
b4:   L     #IN_4; 
bSAV: T     #OUT_2; 
NETWORK
TITLE =MAP 3 : OUT_3 := IN (MAP_3)

      L     #MAP_3; // MAPPING-ZIEL Eingang 3
      SPL   c0; // Sprungziel bei MAP > 4
      SPA   c0; // MAP TO 0
      SPA   c1; // MAP TO 1
      SPA   c2; // MAP TO 2
      SPA   c3; // MAP TO 3
      SPA   c4; // MAO TO 4

c0:   L     #ZERO_VAL; 
      SPA   cSAV; 
c1:   L     #IN_1; 
      SPA   cSAV; 
c2:   L     #IN_2; 
      SPA   cSAV; 
c3:   L     #IN_3; 
      SPA   cSAV; 
c4:   L     #IN_4; 
cSAV: T     #OUT_3; 
NETWORK
TITLE =MAP 4 : OUT_4 := IN (MAP_4)

      L     #MAP_4; // MAPPING-ZIEL Eingang 4
      SPL   d0; // Sprungziel bei MAP > 4
      SPA   d0; // MAP TO 0
      SPA   d1; // MAP TO 1
      SPA   d2; // MAP TO 2
      SPA   d3; // MAP TO 3
      SPA   d4; // MAO TO 4

d0:   L     #ZERO_VAL; 
      SPA   dSAV; 
d1:   L     #IN_1; 
      SPA   dSAV; 
d2:   L     #IN_2; 
      SPA   dSAV; 
d3:   L     #IN_3; 
      SPA   dSAV; 
d4:   L     #IN_4; 
dSAV: T     #OUT_4; 
END_FUNCTION

FUNCTION "m7b_X_Switch_DINT" : VOID
TITLE =X_Switch_DINT : Kreuzschalter für DINT-Werte
//KREUZSCHALTUNG
//
//X_Switch : False: 1:1 - Schaltung OUT1:IN1; OUT2=IN2
//           True :   X - Schaltung OUT1:IN2; OUT2=IN1
//
//IN1 : Eingang 1
//IN2 : Eingang 2
//OUT1: Ausgang 1
//OUT2: Ausgang 2
//
//FC-ENO : Der X_Switch Eingang wird auf ENO druchgeschleift
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 03/2009
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  X_Switch : BOOL ;	//False: 1:1 Schaltung; True: X-Schaltung
  IN1 : DINT ;	//Eingangswert 1
  IN2 : DINT ;	//Eingangswert 2
END_VAR
VAR_OUTPUT
  OUT1 : DINT ;	
  OUT2 : DINT ;	
END_VAR
BEGIN
NETWORK
TITLE =Kreuschalterfunktion

      U     #X_Switch; // Wenn Kreuzschaltung aktiv
      SAVE  ; // Schalter auf ENO durchschleifen
      SPB   X; // Ausgänge kreuz geschaltet

      L     #IN1; // Ausgänge 1:1 schalten
      T     #OUT1; 

      L     #IN2; 
      T     #OUT2; 
      BEA   ; 

X:    L     #IN1; // Ausgänge über Kreuz schalten
      T     #OUT2; 

      L     #IN2; 
      T     #OUT1; 



END_FUNCTION

FUNCTION "m7b_InvertRange_DINT" : DINT
TITLE =InvertRange_DINT: Invertiert einen Bereich (Messrichtungsumkehr)
//Invertiert einen Wertebereich (Messrichtungsumkehr), vertauscht sozusagen Ober- 
//und Untergrenze.
//Bei symetrischen Wertebereichen: MIN = -MAX ist das einfach eine 
//Vorzeichenumkehr.
//
//ENO : Übersteuerungsanzeige: der invertierte Wert liegt ausserhalb des 
//      Wertebereichs. Dieses Signal kann z.B. dazu verwendet werden um
//      eine gesonderte verarbeitung im Fehlerfalle druchzuführen.
//
//
//z.B. MIN=-100 MAX=100 VALUE=20 : Xinv= -20
//     MIN=  20 MAX=100 VALUE=20 : Xinv= 100
//                      VALUE=50 : Xinv=  70 
//                          
//Xinv= MIN + MAX - VALUE 
// 
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  VALUE : DINT ;	//Value to invert
  MIN : DINT ;	//Minimum of Range
  MAX : DINT ;	//Maximum of Range
END_VAR
BEGIN
NETWORK
TITLE =Invert Range: Wertebereich umkehren
//Xinv= MAX - VALUE + MIN  :  Bessere Berechnung wegen Überläufen
      L     #MAX; 
      L     #VALUE; 
      -D    ; 
      L     #MIN; 
      +D    ; 
      T     #RET_VAL; 
NETWORK
TITLE =FC-ENO-Ausgang als Übersteuerungsanzeige

      L     #MAX; // Maximalwert
      >D    ; // Wert > MAX
      SPB   SAVE; // Max-Wert überschritten
      TAK   ; // Ausgangswert in Akku 1 zurueck
      L     #MIN; 
      <D    ; 
      SPB   SAVE; // MinWert unterschritten
      CLR   ; 
SAVE: SAVE  ; 
      CLR   ; 
END_FUNCTION

FUNCTION "m7b_MinDiffABS_DINT" : VOID
TITLE =MinDiffABS_DINT: Minimale Absolutdifferenz 2er DINT-Werte ok! 
//Überprüft, ob die absolute Differenz (absolut) zweier DINT dem angebegenen 
//Mindestwert entspricht. Wenn ja, dann wird ENO=True
//
//BENÖTIGTE SFCs: keine
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//10.09.2020   S.Maag      Ausgang dDiff hinzugefügt
//--------------------------------------------------------------------------------
//
//HINWEISE: 
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  VAL_1 : DINT ;	
  VAL_2 : DINT ;	
  MinDiff : DINT ;	
END_VAR
VAR_OUTPUT
  dDiff : DINT ;	//Differenz=ABS(VAL_1-VAL_2)
END_VAR
VAR_TEMP
  aktSysTime : TIME ;	//aktuelle Systemzeit
END_VAR
BEGIN
NETWORK
TITLE =prüfen ob Differenz ok

      L     #VAL_1; 
      L     #VAL_2; 
      -D    ; 
      SPP   pos; 
      NEGD  ; 
pos:  T     #dDiff; 
      L     #MinDiff; 
      >=D   ; 
      SAVE  ; 

END_FUNCTION

FUNCTION "m7b_SchleppZeiger_DINT" : VOID
TITLE =SchleppZeiger_DINT: Schleppzeiger für DINT (drag indicator)
//Schleppzeiger für Doppel-Integerwerte
//
//Der FC-ENO-Ausgang wird dann "1", wenn der Schleppzeiger einen neuen Wert 
//erhält, ansonsten ist der FC-ENO-Ausgang "0"
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 9/2004
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  dValue : DINT ;	//aktueller Wert
  cfgMinMax : BOOL ;	//Konfig.: 0=Minimum Schleppzeiger 1=Maximum Schleppzeiger
  Init : BOOL ;	//Initialisierung, Schleppzeiger wird auf aktuellen Wert gesetzt
END_VAR
VAR_IN_OUT
  SchleppZeiger : DINT ;	//Schleppzeiger-Wert
END_VAR
BEGIN
NETWORK
TITLE =

      U     #Init; 
      SPB   INIT; 

      U     #cfgMinMax; // Maximum Schleppzeiger
      SPB   MAX; 

      L     #SchleppZeiger; // Minimum Schleppzeiger
      L     #dValue; 
      <D    ; 
      SPB   END; 
      SPA   SAVE; 

INIT: L     #dValue; // Schleppzeicher initialisieren
      SPA   SAVE; 

MAX:  L     #SchleppZeiger; 
      L     #dValue; 
      >D    ; 
      SPB   END; 

SAVE: T     #SchleppZeiger; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
      BEA   ; 

END:  CLR   ; 
      SAVE  ; 

END_FUNCTION

FUNCTION "m7b_ChangeEvent_REAL" : VOID
TITLE =Ereignis REAL Wert hat sich geändert
//Der FC-ENO-Ausgang wird für einen Zyklus "1", wenn der sich der Eingangswert 
//geändert hat, ansonsten ist der FC-ENO-Ausgang "0"
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  inREAL : REAL ;	
END_VAR
VAR_IN_OUT
  memREAL : REAL ;	
END_VAR
BEGIN
NETWORK
TITLE =

      L     #inREAL; // Eingangwert
      L     #memREAL; // letzter Wert
      <>R   ; // ungleich!
      SAVE  ; // als ENO ausgeben
      SPB   do; // und neuen
      BEA   ; 
do:   L     #inREAL; // Wert speichern
      T     #memREAL; 

END_FUNCTION

FUNCTION "m7b_RP_WRITE_REAL" : VOID
TITLE =Ringpuffer schreiben REAL-Werte
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 7/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//09.07.2010   S.Maag      ENO nur True, wenn Ringpuffer geschrieben/verarbeitet
//                         wird, sonst FALSE
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  DB_RP : BLOCK_DB ;	
  RP_POS : BOOL ;	//Ringpuffer schreiben positiv
  RP_NEG : BOOL ;	//Ringpuffer schreiben negativ
  IN_REAL : DINT ;	//Eingangswert DINT
END_VAR
VAR_IN_OUT
  RP_IDX : INT ;	//Indexwert Ringpuffer 0..255
END_VAR
VAR_TEMP
  AR1 : DWORD ;	
END_VAR
BEGIN
NETWORK
TITLE =

      TAR1  #AR1; // Adressregister 1 sichern

NETWORK
TITLE =

      U     #RP_POS; // positiver Impuls := Ringpuffer vorwärts
      SPB   pos; 

      U     #RP_NEG; // negativer Impuls := Ringpuffer rückwärts
      SPB   neg; 

      CLR   ; // ENO = FALSE, => keine Verarbeitung
      SAVE  ; 
      BEA   ; 

pos:  L     #RP_IDX; // positiver Impuls := Ringpuffer vorwärts
      INC   1; // INC: Bytebefehl 0..255
      SPA   save; 

neg:  L     #RP_IDX; // negativer Impuls := Ringpuffer rückwärts
      DEC   1; // DEC: Bytebefehl 0..255

save: T     #RP_IDX; // Indexwert Ringpuffer 0..255
      SLD   5; // SLD 2 wegen DINT-Werten=>Byte + SLD 3 wegen Pointer
      L     P#0.0; // 0-Pointer addieren
      +D    ; // Pointer auf Daten erzeugen
      LAR1  ; // in Adressregister 1 laden

      AUF   #DB_RP; // Ringpuffer DB öffnen
      L     #IN_REAL; // Eingangswert laden
      T     DBD [AR1,P#0.0]; // in DB speichern

      LAR1  #AR1; // ursprüngliches Adressregister 1 herstellen
      SET   ; // ENO = TRUE, => Verarbeitung
      SAVE  ; 
      BEA   ; 


END_FUNCTION

FUNCTION "m7b_RP_READ_REAL" : REAL
TITLE =Ringpuffer lesen REAL-Werte
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 7/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  DB_RP : BLOCK_DB ;	
  RP_IDX : INT ;	//Ringpuffer Index
  RP_OFFSET : INT ;	//Offeset Ringpufferindex
END_VAR
VAR_TEMP
  AR1 : DWORD ;	
END_VAR
BEGIN
NETWORK
TITLE =

      TAR1  #AR1; // Adressregister 1 sichern

      L     #RP_IDX; // aktueller Ringpuffer-Index
      L     #RP_OFFSET; // Offset für lesen
      -I    ; 
      L     W#16#FF; // auf 0..255 begrenzen
      UW    ; 
      SLD   5; // SLD 2 wegen DINT-Werten=>Byte + SLD 3 wegen Pointer
      L     P#0.0; // 0-Pointer addieren
      +D    ; // Pointer auf Daten erzeugen
      LAR1  ; // in Adressregister 1 laden

      AUF   #DB_RP; // Ringpuffer DB öffnen
      L     DBD [AR1,P#0.0]; // Wert aus Ringpuffer laden
      T     #RET_VAL; // Rückgabewert

      LAR1  #AR1; // ursprüngliches Adressregister 1 herstellen
      SET   ; 
      SAVE  ; 
      CLR   ; 

END_FUNCTION

FUNCTION_BLOCK "m7b_CYCLE_TIME_SPLITTER"
TITLE =Zykluszeitverteilung
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  RESET : BOOL ;	
END_VAR
VAR_OUTPUT
  CYC_1of2 : BOOL ;	
  CYC_2of2 : BOOL ;	
  CYC_1of4 : BOOL ;	
  CYC_2of4 : BOOL ;	
  CYC_3of4 : BOOL ;	
  CYC_4of4 : BOOL ;	
END_VAR
VAR
  mem_1Of4 : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =Zyklus 1 von 2
//======================================================================
//                    C Y C L E   1 o f 2
//======================================================================
      UN    #CYC_1of2; 
      =     L      0.0; 
      U     L      0.0; 
      BLD   102; 
      =     #CYC_1of2; 
      U     L      0.0; 
      NOT   ; 
      =     #CYC_2of2; 
NETWORK
TITLE =
//======================================================================
//                    C Y C L E   1  o f  4
//======================================================================
      U     #CYC_3of4; 
      =     #CYC_4of4; 
NETWORK
TITLE =

      U     #CYC_2of4; 
      =     #CYC_3of4; 
NETWORK
TITLE =

      U     #CYC_1of4; 
      =     #CYC_2of4; 
NETWORK
TITLE =

      UN    #CYC_1of4; 
      UN    #CYC_2of4; 
      UN    #CYC_3of4; 
      UN    #CYC_4of4; 
      O     #mem_1Of4; 
      =     #CYC_1of4; 
NETWORK
TITLE =

      U     #CYC_4of4; 
      =     #mem_1Of4; 
NETWORK
TITLE =

      U     BIE; 
      UN    #RESET; 
      SAVE  ; 
      BEB   ; 
NETWORK
TITLE =

      U     #RESET; 
      R     #CYC_1of2; 
      R     #CYC_2of2; 
      R     #CYC_1of4; 
      R     #CYC_2of4; 
      R     #CYC_3of4; 
      R     #CYC_4of4; 
END_FUNCTION_BLOCK

FUNCTION "m7b_MUXx3xREAL" : REAL
TITLE =3-fach REAL Multiplexer
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//25.08.2008   S.Maag      enstanden aus MUXx3xINT
//
//24.04.2009   S.Maag      EN0 := Signal Wert selektiert 
//                               (S1 | S2 | S3)  AND ENABLE
//
//29.01.2013   S.Maag      Anzeige aktiver Kanal (DSP_CHANNEL)
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 2.0


VAR_INPUT
  S1 : BOOL ;	
  S2 : BOOL ;	
  S3 : BOOL ;	
  ENABLE : BOOL ;	
  REAL1 : REAL ;	
  REAL2 : REAL ;	
  REAL3 : REAL ;	
END_VAR
VAR_OUTPUT
  DSP_CHANNEL : INT ;	//Displays the activated channel
END_VAR
BEGIN
NETWORK
TITLE =

      UN    #ENABLE; // keine Freigabe, dann 0 ausgeben
      SPB   STOP; 

      U     #S1; 
      SPB   S1; 
      U     #S2; 
      SPB   S2; 
      U     #S3; 
      SPB   S3; 

      SPA   STOP; 

S1:   L     1; // Wert für Kanalanzeige
      L     #REAL1; 
      SPA   SAVE; 

S2:   L     2; 
      L     #REAL2; 
      SPA   SAVE; 

S3:   L     3; 
      L     #REAL3; 
      SPA   SAVE; 

STOP: CLR   ; // EN0-Ausgang =0, da Stopp
      L     0; // Wert für Kanalanzeige
      L     0.000000e+000; // Wert für Multiplexer

SAVE: SAVE  ; 
      T     #RET_VAL; // Mulitplexer Ausgang
      TAK   ; // Wert aktiver Kanal
      T     #DSP_CHANNEL; // Anzeige aktiver Kanal

END_FUNCTION

FUNCTION "m7b_MUXx4xREAL" : REAL
TITLE =4-fach REAL Multiplexer
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//25.08.2008   S.Maag      enstanden aus MUXx3xINT
//
//24.04.2009   S.Maag      EN0 := Signal Wert selektiert 
//                               (S1 | S2 | S3)  AND ENABLE
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 2.0


VAR_INPUT
  S1 : BOOL ;	
  S2 : BOOL ;	
  S3 : BOOL ;	
  S4 : BOOL ;	
  ENABLE : BOOL ;	
  REAL1 : REAL ;	
  REAL2 : REAL ;	
  REAL3 : REAL ;	
  REAL4 : REAL ;	
END_VAR
VAR_OUTPUT
  DSP_CHANNEL : INT ;	//Displays the activated channel
END_VAR
BEGIN
NETWORK
TITLE =

      UN    #ENABLE; // keine Freigabe, dann 0 ausgeben
      SPB   STOP; 

      U     #S1; 
      SPB   S1; 
      U     #S2; 
      SPB   S2; 
      U     #S3; 
      SPB   S3; 
      U     #S4; 
      SPB   S4; 

      SPA   STOP; 

S1:   L     1; // Wert für Kanalanzeige
      L     #REAL1; 
      SPA   SAVE; 

S2:   L     2; 
      L     #REAL2; 
      SPA   SAVE; 

S3:   L     3; 
      L     #REAL3; 
      SPA   SAVE; 

S4:   L     4; 
      L     #REAL4; 
      SPA   SAVE; 

STOP: CLR   ; // EN0-Ausgang =0, da Stopp
      L     0; // Wert für Kanalanzeige
      L     0.000000e+000; // Wert für Multiplexer

SAVE: SAVE  ; 
      T     #RET_VAL; // Mulitplexer Ausgang
      TAK   ; // Wert aktiver Kanal
      T     #DSP_CHANNEL; // Anzeige aktiver Kanal

END_FUNCTION

FUNCTION "m7b_MAPx4xREAL" : VOID
TITLE =4x mapping for REAL
//This function maps 4 individual Inputs to 4 individual Outputs using the 
//mapping table MAP_1..MAP_4. There is no check for double using an INPUT. 
//
//OUT(1)=IN(MAP_1)
//OUT(2)=IN(MAP_2)
//OUT(3)=IN(MAP_3)
//OUT(4)=IN(MAP_4)
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 07/2012
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//HINWEISE:
//Seit 07.04.2020 neue Version in SCL mit 2 mapping Modes.      
//Für neue Projekte nur noch neue Version verwenden
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  IN_1 : REAL ;	//Input Value 1
  IN_2 : REAL ;	//Input Value 2
  IN_3 : REAL ;	//Input Value 3
  IN_4 : REAL ;	//Input Value 4
  ZERO_VAL : REAL ;	//Zero Value (used as 'zero', if no mapping)
  MAP_1 : INT ;	//Source Nr. for OUT_1: OUT_1=IN(MAP_1)
  MAP_2 : INT ;	//Source Nr. for OUT_2: OUT_2=IN(MAP_2)
  MAP_3 : INT ;	//Source Nr. for OUT_3: OUT_3=IN(MAP_3)
  MAP_4 : INT ;	//Source Nr. for OUT_4: OUT_3=IN(MAP_4)
END_VAR
VAR_OUTPUT
  OUT_1 : REAL ;	
  OUT_2 : REAL ;	
  OUT_3 : REAL ;	
  OUT_4 : REAL ;	
END_VAR
BEGIN
NETWORK
TITLE =

      SET   ; 
      SAVE  ; 
      CLR   ; 

NETWORK
TITLE =MAP 1 : OUT_1 := IN (MAP_1)

      L     #MAP_1; // MAPPING-ZIEL Eingang 1
      SPL   a0; // Sprungziel bei MAP > 4
      SPA   a0; // MAP TO 0
      SPA   a1; // MAP TO 1
      SPA   a2; // MAP TO 2
      SPA   a3; // MAP TO 3
      SPA   a4; // MAO TO 4

a0:   L     #ZERO_VAL; 
      SPA   aSAV; 
a1:   L     #IN_1; 
      SPA   aSAV; 
a2:   L     #IN_2; 
      SPA   aSAV; 
a3:   L     #IN_3; 
      SPA   aSAV; 
a4:   L     #IN_4; 
aSAV: T     #OUT_1; 
NETWORK
TITLE =MAP 2 : OUT_2 := IN (MAP_2)

      L     #MAP_2; // MAPPING-ZIEL Eingang 2
      SPL   b0; // Sprungziel bei MAP > 4
      SPA   b0; // MAP TO 0
      SPA   b1; // MAP TO 1
      SPA   b2; // MAP TO 2
      SPA   b3; // MAP TO 3
      SPA   b4; // MAO TO 4

b0:   L     #ZERO_VAL; 
      SPA   bSAV; 
b1:   L     #IN_1; 
      SPA   bSAV; 
b2:   L     #IN_2; 
      SPA   bSAV; 
b3:   L     #IN_3; 
      SPA   bSAV; 
b4:   L     #IN_4; 
bSAV: T     #OUT_2; 
NETWORK
TITLE =MAP 3 : OUT_3 := IN (MAP_3)

      L     #MAP_3; // MAPPING-ZIEL Eingang 3
      SPL   c0; // Sprungziel bei MAP > 4
      SPA   c0; // MAP TO 0
      SPA   c1; // MAP TO 1
      SPA   c2; // MAP TO 2
      SPA   c3; // MAP TO 3
      SPA   c4; // MAO TO 4

c0:   L     #ZERO_VAL; 
      SPA   cSAV; 
c1:   L     #IN_1; 
      SPA   cSAV; 
c2:   L     #IN_2; 
      SPA   cSAV; 
c3:   L     #IN_3; 
      SPA   cSAV; 
c4:   L     #IN_4; 
cSAV: T     #OUT_3; 
NETWORK
TITLE =MAP 4 : OUT_4 := IN (MAP_4)

      L     #MAP_4; // MAPPING-ZIEL Eingang 4
      SPL   d0; // Sprungziel bei MAP > 4
      SPA   d0; // MAP TO 0
      SPA   d1; // MAP TO 1
      SPA   d2; // MAP TO 2
      SPA   d3; // MAP TO 3
      SPA   d4; // MAO TO 4

d0:   L     #ZERO_VAL; 
      SPA   dSAV; 
d1:   L     #IN_1; 
      SPA   dSAV; 
d2:   L     #IN_2; 
      SPA   dSAV; 
d3:   L     #IN_3; 
      SPA   dSAV; 
d4:   L     #IN_4; 
dSAV: T     #OUT_4; 
END_FUNCTION

FUNCTION "m7b_X_Switch_REAL" : VOID
TITLE =X_Switch_DINT : Kreuzschalter für REAL-Werte
//KREUZSCHALTUNG
//
//X_Switch : False: 1:1 - Schaltung OUT1:IN1; OUT2=IN2
//           True :   X - Schaltung OUT1:IN2; OUT2=IN1
//
//IN1 : Eingang 1
//IN2 : Eingang 2
//OUT1: Ausgang 1
//OUT2: Ausgang 2
//
//FC-ENO : Der X_Switch Eingang wird auf ENO druchgeschleift
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 03/2009
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  X_Switch : BOOL ;	//False: 1:1 Schaltung; True: X-Schaltung
  IN1 : REAL ;	//Eingangswert 1
  IN2 : REAL ;	//Eingangswert 2
END_VAR
VAR_OUTPUT
  OUT1 : REAL ;	
  OUT2 : REAL ;	
END_VAR
BEGIN
NETWORK
TITLE =Kreuschalterfunktion

      U     #X_Switch; // Wenn Kreuzschaltung aktiv
      SAVE  ; // Schalter auf ENO durchschleifen
      SPB   X; // Ausgänge kreuz geschaltet

      L     #IN1; // Ausgänge 1:1 schalten
      T     #OUT1; 

      L     #IN2; 
      T     #OUT2; 
      BEA   ; 

X:    L     #IN1; // Ausgänge über Kreuz schalten
      T     #OUT2; 

      L     #IN2; 
      T     #OUT1; 



END_FUNCTION

FUNCTION "m7b_InvertRange_REAL" : REAL
TITLE =InvertRange_REAL: Invertiert einen Bereich (Messrichtungsumkehr)
//Invertiert einen Wertebereich (Messrichtungsumkehr), vertauscht sozusagen Ober- 
//und Untergrenze.
//Bei symetrischen Wertebereichen: MIN = -MAX ist das einfach eine 
//Vorzeichenumkehr.
//
//ENO : Übersteuerungsanzeige: der invertierte Wert liegt ausserhalb des 
//      Wertebereichs. Dieses Signal kann z.B. dazu verwendet werden um
//      eine gesonderte verarbeitung im Fehlerfalle druchzuführen.
//
//
//z.B. MIN=-100 MAX=100 VALUE=20 : Xinv= -20
//     MIN=  20 MAX=100 VALUE=20 : Xinv= 100
//                      VALUE=50 : Xinv=  70 
//                          
//Xinv= MIN + MAX - VALUE 
// 
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  VALUE : REAL ;	//Value to invert
  MIN : REAL ;	//Minimum of Range
  MAX : REAL ;	//Maximum of Range
END_VAR
BEGIN
NETWORK
TITLE =Invert Range: Wertebereich umkehren
//Xinv= MAX - VALUE + MIN  :  Bessere Berechnung wegen Überläufen
      L     #MAX; 
      L     #VALUE; 
      -R    ; 
      L     #MIN; 
      +R    ; 
      T     #RET_VAL; 
NETWORK
TITLE =FC-ENO-Ausgang als Übersteuerungsanzeige

      L     #MAX; // Maximalwert
      >R    ; // Wert > MAX
      SPB   SAVE; // Max-Wert überschritten
      TAK   ; // Ausgangswert in Akku 1 zurueck
      L     #MIN; 
      <R    ; 
      SPB   SAVE; // MinWert unterschritten
      CLR   ; 
SAVE: SAVE  ; 
      CLR   ; 
END_FUNCTION

FUNCTION "m7b_MinDiffABS_REAL" : VOID
TITLE =MinDiffABS_REAL: Minimale Absolutdifferenz 2er REAL-Werte ok! 
//Überprüft, ob die absolute Differenz (absolut) zweier DINT dem angebegenen 
//Mindestwert entspricht. Wenn ja, dann wird ENO=True
//
//BENÖTIGTE SFCs: keine
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//--------------------------------------------------------------------------------
//10.09.2020   S.Maag      Ausgang rDiff hinzugefügt
//--------------------------------------------------------------------------------
//
//HINWEISE: 
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  VAL_1 : REAL ;	
  VAL_2 : REAL ;	
  MinDiff : REAL ;	
END_VAR
VAR_OUTPUT
  rDiff : REAL ;	//Differenz=ABS(VAL_1-VAL_
END_VAR
VAR_TEMP
  aktSysTime : TIME ;	//aktuelle Systemzeit
END_VAR
BEGIN
NETWORK
TITLE =prüfen ob Differenz ok

      L     #VAL_1; 
      L     #VAL_2; 
      -R    ; 
      SPP   pos; 
      NEGR  ; 
pos:  T     #rDiff; 
      L     #MinDiff; 
      >=R   ; 
      SAVE  ; 

END_FUNCTION

FUNCTION "m7b_SchleppZeiger_REAL" : VOID
TITLE =SchleppZeiger_REAL: Schleppzeiger für REAL
//Schleppzeiger für REAL-Werte
//
//Der FC-ENO-Ausgang wird dann "1", wenn der Schleppzeiger einen neuen Wert 
//erhält, ansonsten ist der FC-ENO-Ausgang "0"
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 9/2004
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  rValue : REAL ;	//aktueller Wert
  cfgMinMax : BOOL ;	//Konfig.: 0=Minimum Schleppzeiger 1=Maximum Schleppzeiger
  Init : BOOL ;	//Initialisierung, Schleppzeiger wird auf aktuellen Wert gesetzt
END_VAR
VAR_IN_OUT
  SchleppZeiger : REAL ;	//Schleppzeiger-Wert
END_VAR
BEGIN
NETWORK
TITLE =

      U     #Init; 
      SPB   INIT; 

      U     #cfgMinMax; // Maximum Schleppzeiger
      SPB   MAX; 

      L     #SchleppZeiger; // Minimum Schleppzeiger
      L     #rValue; 
      <R    ; 
      SPB   END; 
      SPA   SAVE; 

INIT: L     #rValue; // Schleppzeicher initialisieren
      SPA   SAVE; 

MAX:  L     #SchleppZeiger; 
      L     #rValue; 
      >R    ; 
      SPB   END; 

SAVE: T     #SchleppZeiger; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
      BEA   ; 

END:  CLR   ; 
      SAVE  ; 

END_FUNCTION

FUNCTION "m7b_ChangeEvent_TIME" : VOID
TITLE =Ereignis TIME Wert hat sich geändert
//Der FC-ENO-Ausgang wird für einen Zyklus "1", wenn der sich der Eingangswert 
//geändert hat, ansonsten ist der FC-ENO-Ausgang "0"
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  inTIME : TIME ;	
END_VAR
VAR_IN_OUT
  memTIME : TIME ;	
END_VAR
BEGIN
NETWORK
TITLE =

      L     #inTIME; // Eingangwert
      L     #memTIME; // letzter Wert
      <>D   ; // ungleich!
      SAVE  ; // als ENO ausgeben
      SPB   do; // und neuen
      BEA   ; 
do:   L     #inTIME; // Wert speichern
      T     #memTIME; 

END_FUNCTION

FUNCTION "m7b_MinMaxLimit_TIME" : VOID
TITLE =Min/Max Begrenzung TIME; Begrenzungsanzeige im BIE-Bit / FC-ENO
//Min- Max- Begrenzung für TIME mit Begrenzungsanzeige
//
//BIE bzw. FC-ENO : 0 = Wert war ok       : Begrenzung nicht aktiv
//                  1 = Wert war nicht ok.: Begrenzung aktiv
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2008
//INTERNET: www.maagic7.de
//
//VERWENDUNG:
//Begrenzung eines Wertes auf den Min- Max- Bereich bei gleichzeitiger 
//Weiterverarbeitung des Begrenzungssignals am FC-ENO-Ausgang z.B. zur Warn- bzw.
//Störungsanzeige oder zur direkten Weiterverschaltung.
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  min : TIME ;	//minimal Wert
  max : TIME ;	//maximal Wert
END_VAR
VAR_IN_OUT
  VALUE : TIME ;	//Sollwert
END_VAR
BEGIN
NETWORK
TITLE =MIN <= VALUE <= MAX

      L     #VALUE; // Sollwert
      L     #min; // minimal Wert
      <D    ; 
      SPB   LIM; // Limitierung wenn VALUE < MIN
      TAK   ; // VALUE wieder in Akku 1
      L     #max; // Maximalwert
      >D    ; 
      SPB   LIM; // Limitierung wenn VALUE > MAX

      CLR   ; // VKE löschen, da keine Begrenzung erfolgte
      SAVE  ; // BIE-Bit = 0, da Wert im Bereich war; ="Keine Begrenzung"
      BEA   ; 

LIM:  T     #VALUE; // max.Wert als Sollwert ausgeben
      SET   ; 
      SAVE  ; // VKE->BIE (=1=): Anzeige FC-ENO Ausgang (=Begrenzung)
      CLR   ; 

END_FUNCTION

FUNCTION "m7b_BitToTIME" : VOID
TITLE =Bit To Time
//Je nach dem Wert des Eingangsbits wird der Wert
//VAL_0 oder VAL_1 als Ausgangswert VAL ausgegeben.
//Der Wert der Eingangsbits wird auf den FC-ENO-Ausgang durchgeschleift
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2008
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  BIT : BOOL ;	
  VAL_0 : TIME ;	
  VAL_1 : TIME ;	
END_VAR
VAR_OUTPUT
  VAL : TIME ;	
END_VAR
BEGIN
NETWORK
TITLE =

      U     #BIT; 
      SAVE  ; // Wert von Bit auf FC-EN0
      SPB   HIGH; 
      L     #VAL_0; 
      SPA   SAVE; 
HIGH: L     #VAL_1; 
SAVE: T     #VAL; 
      CLR   ; 

END_FUNCTION

FUNCTION "m7b_MUXx3xTIME" : TIME
TITLE =3x TIME Multiplexer
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//09.10.2008   S.Maag      enstanden aus MUXx3xDINT
//
//24.04.2009   S.Maag      EN0 := Signal Wert selektiert 
//                               (S1 | S2 | S3)  AND ENABLE
//
//29.01.2013   S.Maag      Anzeige aktiver Kanal (DSP_CHANNEL)
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  S1 : BOOL ;	
  S2 : BOOL ;	
  S3 : BOOL ;	
  ENABLE : BOOL ;	
  TIME1 : TIME ;	
  TIME2 : TIME ;	
  TIME3 : TIME ;	
END_VAR
VAR_OUTPUT
  DSP_CHANNEL : INT ;	//Displays the activated channel
END_VAR
BEGIN
NETWORK
TITLE =

      UN    #ENABLE; // keine Freigabe, dann 0 ausgeben
      SPB   STOP; 

      U     #S1; 
      SPB   S1; 
      U     #S2; 
      SPB   S2; 
      U     #S3; 
      SPB   S3; 

      SPA   STOP; 

S1:   L     1; // Wert für Kanalanzeige
      L     #TIME1; 
      SPA   SAVE; 

S2:   L     2; 
      L     #TIME2; 
      SPA   SAVE; 

S3:   L     3; 
      L     #TIME3; 
      SPA   SAVE; 

STOP: CLR   ; // EN0-Ausgang =0, da Stopp
      L     0; // Wert für Kanalanzeige
      L     T#0MS; // Wert für Multiplexer

SAVE: SAVE  ; 
      T     #RET_VAL; // Mulitplexer Ausgang
      TAK   ; // Wert aktiver Kanal
      T     #DSP_CHANNEL; // Anzeige aktiver Kanal

END_FUNCTION

FUNCTION "m7b_MUXx4xTIME" : TIME
TITLE =4x TIME Multiplexer
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//09.10.2008   S.Maag      enstanden aus MUXx4xDINT
//
//24.04.2009   S.Maag      EN0 := Signal Wert selektiert 
//                               (S1 | S2 | S3)  AND ENABLE
//
//29.01.2013   S.Maag      Anzeige aktiver Kanal (DSP_CHANNEL)
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  S1 : BOOL ;	
  S2 : BOOL ;	
  S3 : BOOL ;	
  S4 : BOOL ;	
  ENABLE : BOOL ;	
  TIME1 : TIME ;	
  TIME2 : TIME ;	
  TIME3 : TIME ;	
  TIME4 : TIME ;	
END_VAR
VAR_OUTPUT
  DSP_CHANNEL : INT ;	//Displays the activated channel
END_VAR
BEGIN
NETWORK
TITLE =

      UN    #ENABLE; // keine Freigabe, dann 0 ausgeben
      SPB   STOP; 

      U     #S1; 
      SPB   S1; 
      U     #S2; 
      SPB   S2; 
      U     #S3; 
      SPB   S3; 
      U     #S4; 
      SPB   S4; 

      SPA   STOP; 

S1:   L     1; // Wert für Kanalanzeige
      L     #TIME1; 
      SPA   SAVE; 

S2:   L     2; 
      L     #TIME2; 
      SPA   SAVE; 

S3:   L     3; 
      L     #TIME3; 
      SPA   SAVE; 

S4:   L     4; 
      L     #TIME4; 
      SPA   SAVE; 

STOP: CLR   ; // EN0-Ausgang =0, da Stopp
      L     0; // Wert für Kanalanzeige
      L     T#0MS; // Wert für Multiplexer

SAVE: SAVE  ; 
      T     #RET_VAL; // Mulitplexer Ausgang
      TAK   ; // Wert aktiver Kanal
      T     #DSP_CHANNEL; // Anzeige aktiver Kanal

END_FUNCTION

FUNCTION "m7b_TOL_TIME" : VOID
TITLE =Wert mit Toleranzbereich ok
//Prüft ob der IST-Wert im Toleranzbereich des Sollwerts ist
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//09.10.2008  S.Maag      enstanden aus m7TOLERANZ_DINT
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  IST : TIME ;	//Istwert
  SOLL : TIME ;	//Sollwert
  TOL : TIME ;	//Toleranzbereich
END_VAR
VAR_OUTPUT
  OK : BOOL ;	//Wert im Toleranzbereich
END_VAR
BEGIN
NETWORK
TITLE =

      L     #SOLL; // Sollwert
      L     #IST; // Istwert
      -D    ; // Differenz 
      SPP   plus; // Vorzeichen immer
      NEGD  ; // auf positiv
plus: L     #TOL; // Soll, Ist Differenz mit TOL vergleichen
      <=D   ; // ist die ABS(SOLL-IST)<= Toleranz, dann ok!
      =     #OK; 
      SAVE  ; 
      CLR   ; 
END_FUNCTION

FUNCTION "m7b_MIN_MAX_OK_TIME" : VOID
TITLE =Wert zwischen Min und Max? MIN <= VALUE <= MAX
//Prüft ob der IST-Wert zwischen MIN & MAX liegt
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//09.10.2008  S.Maag      enstanden aus m7MIN_MAX_OK_DINT
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  VALUE : TIME ;	//Zu prüfender Wert
  MIN : TIME ;	//Zulässiger Minimalwert
  MAX : TIME ;	//Zulässiger Maximalwert
END_VAR
VAR_OUTPUT
  OK : BOOL ;	//Wert im Toleranzbereich
END_VAR
BEGIN
NETWORK
TITLE =

      L     #MIN; // minmal zulässiger Wert
      L     #VALUE; 
      >D    ; // falls MIN > VALUE
      SPB   NOK; // dann nicht ok
      L     #MAX; 
      >D    ; // falls VALUE > MAX
      SPB   NOK; // dann nicht ok
      =     #OK; // sonst ok
      SAVE  ; 
      BEA   ; 
NOK:  CLR   ; // Wert nicht ok
      =     #OK; 
      SAVE  ; 


END_FUNCTION

FUNCTION "m7b_Scale_TIME" : TIME
TITLE =Bereich Skalieren TIME
//Skaliert eienen Wert von einem Eingagswertebereich auf einen 
//Ausgangswertebereich:
//
//FC-ENO: Übersteuerungsanzeige
//
//ACHTUNG: die Eingangswerte werden nicht auf Gültigkeit geprüft 
//         und der Ausgangswert wird nicht begrenzt. Bei Übersteuerung wird
//         der FC-ENO-Ausgang "1"
//
//z.B. Eingangswertebereich 100 -  300   
//     Ausgangswertebereich   0 - 1000
//
//                           (MaxOutput - MinOutput)
//Xout = (Value - MinInput) --------------------------  + MinOutput
//                            (MaxInput - MinInput) 
//
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 3/2003
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  tMinInput : TIME ;	
  tMaxInput : TIME ;	
  tValue : TIME ;	
  tMinOutput : TIME ;	
  tMaxOutput : TIME ;	
END_VAR
VAR_TEMP
  rTemp : REAL ;	
END_VAR
BEGIN
NETWORK
TITLE =Eingagswertebereich berechnen
//(MaxInput - MinInput)
      L     #tMaxInput; 
      L     #tMinInput; 
      -D    ; // Differenz  
      DTR   ; // zu        REAL
      T     #rTemp; 

NETWORK
TITLE =Faktor aus Ausgangs- und Eingangs-Wertebereich
// (MaxOutput - MinOutput)
//-------------------------
//  (MaxInput - MinInput)
      L     #tMaxOutput; 
      L     #tMinOutput; 
      -D    ; // Differenz
      DTR   ; // zu        REAL
      L     #rTemp; 
      /R    ; // Gleitpunktdivision
      T     #rTemp; 

NETWORK
TITLE =skalierter Ausgangswert
//                     (MaxOutput - MinOutput)
// (Value - MinInput) -------------------------- + MinOutput
//                      (MaxInput - MinInput) 
      L     #tValue; // Eingangswert
      L     #tMinInput; // UnterGrenze Eingangswert
      -D    ; // Differenz  
      DTR   ; // zu        REAL
      L     #rTemp; 
      *R    ; // Gleitpunktmultiplikation
      RND   ; // zu Festpunkt 32Bit
      L     #tMinOutput; 
      +D    ; 
      T     #RET_VAL; // Rückgabewert
NETWORK
TITLE =FC-ENO-Ausgangs als Übersteuerungsanzeige

      L     #tMaxOutput; // MaxOutput
      >D    ; // Wert > MaxOutput
      SPB   SAVE; // Max-Wert überschritten
      TAK   ; // Ausgangswert in Akku 1 zurueck
      L     #tMinOutput; 
      <D    ; 
      SPB   SAVE; // MinWert unterschritten
      CLR   ; 
SAVE: SAVE  ; 
      CLR   ; 
END_FUNCTION

FUNCTION "m7b_MinDiffABS_TIME" : VOID
TITLE =MinDiffABS_TIME: Minimale Absolutdifferenz 2er IEC-Zeiten ok! 
//Überprüft, ob die absolute Differenz (absolut) zweier IEC-Zeiten dem 
//angebegenen Mindestwert entspricht. Wenn ja, dann wird ENO=True
//
//BENÖTIGTE SFCs: keine
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 3/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  Time1 : TIME ;	
  Time2 : TIME ;	
  MinTimeDiff : TIME ;	
END_VAR
VAR_TEMP
  aktSysTime : TIME ;	//aktuelle Systemzeit
END_VAR
BEGIN
NETWORK
TITLE =prüfen ob Zeit abgelaufen ist

      L     #Time1; 
      L     #Time2; 
      -D    ; 
      SPP   pos; 
      NEGD  ; 
pos:  L     #MinTimeDiff; 
      >=D   ; 
      SAVE  ; 

END_FUNCTION

FUNCTION "m7b_SchleppZeiger_TIME" : VOID
TITLE =SchleppZeiger_TIME: Schleppzeiger für TIME (drag indicator)
//Schleppzeiger für IEC-TIME-Werte
//Der FC-ENO-Ausgang wird dann "1", wenn der Schleppzeiger einen neuen Wert 
//erhält, ansonsten ist der FC-ENO-Ausgang "0"
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 9/2004
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  tValue : TIME ;	//aktueller Wert
  cfgMinMax : BOOL ;	//Konfig.: 0=Minimum Schleppzeiger 1=Maximum Schleppzeiger
  Init : BOOL ;	//Initialisierung, Schleppzeiger wird auf aktuellen Wert gesetzt
END_VAR
VAR_IN_OUT
  SchleppZeiger : TIME ;	//Schleppzeiger-Wert
END_VAR
BEGIN
NETWORK
TITLE =

      U     #Init; 
      SPB   INIT; 

      U     #cfgMinMax; // Maximum Schleppzeiger
      SPB   MAX; 

      L     #SchleppZeiger; // Minimum Schleppzeiger
      L     #tValue; 
      <D    ; 
      SPB   END; 
      SPA   SAVE; 

INIT: L     #tValue; // Schleppzeicher initialisieren
      SPA   SAVE; 

MAX:  L     #SchleppZeiger; 
      L     #tValue; 
      >D    ; 
      SPB   END; 

SAVE: T     #SchleppZeiger; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
      BEA   ; 

END:  CLR   ; 
      SAVE  ; 

END_FUNCTION

FUNCTION "m7b_ChangeEvent_TOD" : VOID
TITLE =Ereignis Time_Of_Day Wert hat sich geändert
//Der FC-ENO-Ausgang wird für einen Zyklus "1", wenn der sich der Eingangswert 
//geändert hat, ansonsten ist der FC-ENO-Ausgang "0"
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  inTOD : TIME_OF_DAY ;	
END_VAR
VAR_IN_OUT
  memTOD : TIME_OF_DAY ;	
END_VAR
BEGIN
NETWORK
TITLE =

      L     #inTOD; // Eingangwert
      L     #memTOD; // letzter Wert
      <>D   ; // ungleich!
      SAVE  ; // als ENO ausgeben
      SPB   do; // und neuen
      BEA   ; 
do:   L     #inTOD; // Wert speichern
      T     #memTOD; 

END_FUNCTION

FUNCTION "m7b_MinMaxLimit_TOD" : VOID
TITLE =Min/Max limit Time_Of_Day; Begrenzungsanzeige im BIE-Bit/FC-ENO
//Min- Max- Begrenzung für TIME mit Begrenzungsanzeige
//
//BIE bzw. FC-ENO : 0 = Wert war ok       : Begrenzung nicht aktiv
//                  1 = Wert war nicht ok.: Begrenzung aktiv
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2008
//INTERNET: www.maagic7.de
//
//VERWENDUNG:
//Begrenzung eines Wertes auf den Min- Max- Bereich bei gleichzeitiger 
//Weiterverarbeitung des Begrenzungssignals am FC-ENO-Ausgang z.B. zur Warn- bzw.
//Störungsanzeige oder zur direkten Weiterverschaltung.
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  min : TIME_OF_DAY ;	//minimal Wert
  max : TIME_OF_DAY ;	//maximal Wert
END_VAR
VAR_IN_OUT
  VALUE : TIME_OF_DAY ;	//Sollwert
END_VAR
BEGIN
NETWORK
TITLE =MIN <= VALUE <= MAX

      L     #VALUE; // Sollwert
      L     #min; // minimal Wert
      <D    ; 
      SPB   LIM; // Limitierung wenn VALUE < MIN
      TAK   ; // VALUE wieder in Akku 1
      L     #max; // Maximalwert
      >D    ; 
      SPB   LIM; // Limitierung wenn VALUE > MAX

      CLR   ; // VKE löschen, da keine Begrenzung erfolgte
      SAVE  ; // BIE-Bit = 0, da Wert im Bereich war; ="Keine Begrenzung"
      BEA   ; 

LIM:  T     #VALUE; // max.Wert als Sollwert ausgeben
      SET   ; 
      SAVE  ; // VKE->BIE (=1=): Anzeige FC-ENO Ausgang (=Begrenzung)
      CLR   ; 

END_FUNCTION

FUNCTION "m7b_BitToTOD" : VOID
TITLE =Bit To Time_Of_Day
//Je nach dem Wert des Eingangsbits wird der Wert
//VAL_0 oder VAL_1 als Ausgangswert VAL ausgegeben.
//Der Wert der Eingangsbits wird auf den FC-ENO-Ausgang durchgeschleift
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2008
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  BIT : BOOL ;	
  VAL_0 : TIME_OF_DAY ;	
  VAL_1 : TIME_OF_DAY ;	
END_VAR
VAR_OUTPUT
  VAL : TIME ;	
END_VAR
BEGIN
NETWORK
TITLE =

      U     #BIT; 
      SAVE  ; // Wert von Bit auf FC-EN0
      SPB   HIGH; 
      L     #VAL_0; 
      SPA   SAVE; 
HIGH: L     #VAL_1; 
SAVE: T     #VAL; 
      CLR   ; 

END_FUNCTION

FUNCTION "m7b_MUXx3xTOD" : TIME_OF_DAY
TITLE =3x Time_Of_Day Multiplexer
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//09.10.2008   S.Maag      enstanden aus MUXx3xDINT
//
//24.04.2009   S.Maag      EN0 := Signal Wert selektiert 
//                               (S1 | S2 | S3)  AND ENABLE
//
//29.01.2013   S.Maag      Anzeige aktiver Kanal (DSP_CHANNEL)
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  S1 : BOOL ;	
  S2 : BOOL ;	
  S3 : BOOL ;	
  ENABLE : BOOL ;	
  TIME1 : TIME_OF_DAY ;	
  TIME2 : TIME_OF_DAY ;	
  TIME3 : TIME_OF_DAY ;	
END_VAR
VAR_OUTPUT
  DSP_CHANNEL : INT ;	//Displays the activated channel
END_VAR
BEGIN
NETWORK
TITLE =

      UN    #ENABLE; // keine Freigabe, dann 0 ausgeben
      SPB   STOP; 

      U     #S1; 
      SPB   S1; 
      U     #S2; 
      SPB   S2; 
      U     #S3; 
      SPB   S3; 

      SPA   STOP; 

S1:   L     1; // Wert für Kanalanzeige
      L     #TIME1; 
      SPA   SAVE; 

S2:   L     2; 
      L     #TIME2; 
      SPA   SAVE; 

S3:   L     3; 
      L     #TIME3; 
      SPA   SAVE; 


STOP: CLR   ; // EN0-Ausgang =0, da Stopp
      L     0; // Wert für Kanalanzeige
      L     L#0; // Wert für Multiplexer

SAVE: SAVE  ; 
      T     #RET_VAL; // Mulitplexer Ausgang
      TAK   ; // Wert aktiver Kanal
      T     #DSP_CHANNEL; // Anzeige aktiver Kanal

END_FUNCTION

FUNCTION "m7b_MUXx4xTOD" : TIME_OF_DAY
TITLE =4x Time_Of_Day Multiplexer
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//09.10.2008   S.Maag      enstanden aus MUXx4xDINT
//
//24.04.2009   S.Maag      EN0 := Signal Wert selektiert 
//                               (S1 | S2 | S3)  AND ENABLE
//
//29.01.2013   S.Maag      Anzeige aktiver Kanal (DSP_CHANNEL)
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  S1 : BOOL ;	
  S2 : BOOL ;	
  S3 : BOOL ;	
  S4 : BOOL ;	
  ENABLE : BOOL ;	
  TIME1 : TIME_OF_DAY ;	
  TIME2 : TIME_OF_DAY ;	
  TIME3 : TIME_OF_DAY ;	
  TIME4 : TIME_OF_DAY ;	
END_VAR
VAR_OUTPUT
  DSP_CHANNEL : INT ;	//Displays the activated channel
END_VAR
BEGIN
NETWORK
TITLE =

      UN    #ENABLE; // keine Freigabe, dann 0 ausgeben
      SPB   STOP; 

      U     #S1; 
      SPB   S1; 
      U     #S2; 
      SPB   S2; 
      U     #S3; 
      SPB   S3; 
      U     #S4; 
      SPB   S4; 

      SPA   STOP; 

S1:   L     1; // Wert für Kanalanzeige
      L     #TIME1; 
      SPA   SAVE; 

S2:   L     2; 
      L     #TIME2; 
      SPA   SAVE; 

S3:   L     3; 
      L     #TIME3; 
      SPA   SAVE; 

S4:   L     4; 
      L     #TIME4; 
      SPA   SAVE; 

STOP: CLR   ; // EN0-Ausgang =0, da Stopp
      L     0; // Wert für Kanalanzeige
      L     L#0; // Wert für Multiplexer

SAVE: SAVE  ; 
      T     #RET_VAL; // Mulitplexer Ausgang
      TAK   ; // Wert aktiver Kanal
      T     #DSP_CHANNEL; // Anzeige aktiver Kanal

END_FUNCTION

FUNCTION "m7b_TOL_TOD" : VOID
TITLE =Wert mit Toleranzbereich ok [Time_Of_Day]
//Prüft ob der IST-Wert im Toleranzbereich des Sollwerts ist
//ACHTUNG: Die Toleranz kann nicht als Tageszeit angegeben werden, sie ist als
//         TIME anzugeben
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//09.10.2008  S.Maag      enstanden aus m7TOLERANZ_DINT
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  IST : TIME_OF_DAY ;	//Istwert
  SOLL : TIME_OF_DAY ;	//Sollwert
  TOL : TIME ;	//Toleranzbereich
END_VAR
VAR_OUTPUT
  OK : BOOL ;	//Wert im Toleranzbereich
END_VAR
BEGIN
NETWORK
TITLE =

      L     #SOLL; // Sollwert
      L     #IST; // Istwert
      -D    ; // Differenz 
      SPP   plus; // Vorzeichen immer
      NEGD  ; // auf positiv
plus: L     #TOL; // Soll, Ist Differenz mit TOL vergleichen
      <=D   ; // ist die ABS(SOLL-IST)<= Toleranz, dann ok!
      =     #OK; 
      SAVE  ; 
      CLR   ; 
END_FUNCTION

FUNCTION "m7b_MIN_MAX_OK_TOD" : VOID
TITLE =Wert zwischen Min und Max? MIN <= VALUE <= MAX
//Prüft ob der IST-Wert zwischen MIN & MAX liegt
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//09.10.2008  S.Maag      enstanden aus m7MIN_MAX_OK_DINT
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  VALUE : TIME_OF_DAY ;	//Zu prüfender Wert
  MIN : TIME_OF_DAY ;	//Zulässiger Minimalwert
  MAX : TIME_OF_DAY ;	//Zulässiger Maximalwert
END_VAR
VAR_OUTPUT
  OK : BOOL ;	//Wert im Toleranzbereich
END_VAR
BEGIN
NETWORK
TITLE =

      L     #MIN; // minmal zulässiger Wert
      L     #VALUE; 
      >D    ; // falls MIN > VALUE
      SPB   NOK; // dann nicht ok
      L     #MAX; 
      >D    ; // falls VALUE > MAX
      SPB   NOK; // dann nicht ok
      =     #OK; // sonst ok
      SAVE  ; 
      BEA   ; 
NOK:  CLR   ; // Wert nicht ok
      =     #OK; 
      SAVE  ; 


END_FUNCTION

FUNCTION "m7b_Scale_TOD" : TIME_OF_DAY
TITLE =Bereich Skalieren Time_Of_Day
//Skaliert eienen Wert von einem Eingagswertebereich auf einen 
//Ausgangswertebereich:
//
//FC-ENO: Übersteuerungsanzeige
//
//ACHTUNG: die Eingangswerte werden nicht auf Gültigkeit geprüft 
//         und der Ausgangswert wird nicht begrenzt. Bei Übersteuerung wird
//         der FC-ENO-Ausgang "1"
//
//z.B. Eingangswertebereich 100 -  300   
//     Ausgangswertebereich   0 - 1000
//
//                           (MaxOutput - MinOutput)
//Xout = (Value - MinInput) --------------------------  + MinOutput
//                            (MaxInput - MinInput) 
//
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 3/2003
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  tMinInput : TIME_OF_DAY ;	
  tMaxInput : TIME_OF_DAY ;	
  tValue : TIME_OF_DAY ;	
  tMinOutput : TIME_OF_DAY ;	
  tMaxOutput : TIME_OF_DAY ;	
END_VAR
VAR_TEMP
  rTemp : REAL ;	
END_VAR
BEGIN
NETWORK
TITLE =Eingagswertebereich berechnen
//(MaxInput - MinInput)
      L     #tMaxInput; 
      L     #tMinInput; 
      -D    ; // Differenz  
      DTR   ; // zu        REAL
      T     #rTemp; 

NETWORK
TITLE =Faktor aus Ausgangs- und Eingangs-Wertebereich
// (MaxOutput - MinOutput)
//-------------------------
//  (MaxInput - MinInput)
      L     #tMaxOutput; 
      L     #tMinOutput; 
      -D    ; // Differenz
      DTR   ; // zu        REAL
      L     #rTemp; 
      /R    ; // Gleitpunktdivision
      T     #rTemp; 

NETWORK
TITLE =skalierter Ausgangswert
//                     (MaxOutput - MinOutput)
// (Value - MinInput) -------------------------- + MinOutput
//                      (MaxInput - MinInput) 
      L     #tValue; // Eingangswert
      L     #tMinInput; // UnterGrenze Eingangswert
      -D    ; // Differenz  
      DTR   ; // zu        REAL
      L     #rTemp; 
      *R    ; // Gleitpunktmultiplikation
      RND   ; // zu Festpunkt 32Bit
      L     #tMinOutput; 
      +D    ; 
      T     #RET_VAL; // Rückgabewert
NETWORK
TITLE =FC-ENO-Ausgangs als Übersteuerungsanzeige

      L     #tMaxOutput; // MaxOutput
      >D    ; // Wert > MaxOutput
      SPB   SAVE; // Max-Wert überschritten
      TAK   ; // Ausgangswert in Akku 1 zurueck
      L     #tMinOutput; 
      <D    ; 
      SPB   SAVE; // MinWert unterschritten
      CLR   ; 
SAVE: SAVE  ; 
      CLR   ; 
END_FUNCTION

FUNCTION "m7b_MinDiffABS_TOD" : VOID
TITLE =MinDiffABS_TOD: Minimale Absolutdifferenz 2er TOD-Zeiten ok! 
//Überprüft, ob die absolute Differenz (absolut) zweier Time_Of_Day-Zeiten dem 
//angebegenen Mindestwert entspricht. Wenn ja, dann wird ENO=True
//
//ACHTUNG: Die Differenz kann nicht im TimeOfDay-Format angeben werden, diese 
//         muss TIME sein
//
//BENÖTIGTE SFCs: keine
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  TOD1 : TIME_OF_DAY ;	
  TOD2 : TIME_OF_DAY ;	
  MinTimeDiff : TIME ;	
END_VAR
VAR_TEMP
  aktSysTime : TIME ;	//aktuelle Systemzeit
END_VAR
BEGIN
NETWORK
TITLE =prüfen ob Zeit abgelaufen ist

      L     #TOD1; 
      L     #TOD2; 
      -D    ; 
      SPP   pos; 
      NEGD  ; 
pos:  L     #MinTimeDiff; 
      >=D   ; 
      SAVE  ; 

END_FUNCTION

FUNCTION "m7b_ChangeEvent_DATE" : VOID
TITLE =Ereignis Date Wert hat sich geändert
//Der FC-ENO-Ausgang wird für einen Zyklus "1", wenn der sich der Eingangswert 
//geändert hat, ansonsten ist der FC-ENO-Ausgang "0"
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 5/2010
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//05.2010      S.Maag          Entstand aus FC150 ChangeEventTOD
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  inDate : DATE ;	
END_VAR
VAR_IN_OUT
  memDate : DATE ;	
END_VAR
BEGIN
NETWORK
TITLE =

      L     #inDate; // Eingangwert
      L     #memDate; // letzter Wert
      <>D   ; // ungleich!
      SAVE  ; // als ENO ausgeben
      SPB   do; // und neuen
      BEA   ; 
do:   L     #inDate; // Wert speichern
      T     #memDate; 

END_FUNCTION

FUNCTION "m7b_ChangeEvent_BYTE" : VOID
TITLE =Ereignis Byte Wert hat sich geändert
//Der FC-ENO-Ausgang wird für einen Zyklus "1", wenn der sich der Eingangswert 
//geändert hat, ansonsten ist der FC-ENO-Ausgang "0"
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  inBYTE : BYTE ;	
END_VAR
VAR_IN_OUT
  memBYTE : BYTE ;	
END_VAR
BEGIN
NETWORK
TITLE =

      L     #inBYTE; // Eingangwert
      L     #memBYTE; // letzter Wert
      <>I   ; // ungleich!
      SAVE  ; // als ENO ausgeben
      SPB   do; // und neuen
      BEA   ; 
do:   L     #inBYTE; // Wert speichern
      T     #memBYTE; 

END_FUNCTION

FUNCTION "m7b_ByteCompare" : VOID
TITLE =BYTE Compare : 2 Bytes vergleichen
//Der FC-ENO-Ausgang wird True, wenn Byte1=Byte2
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 4/2009
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  Byte1 : BYTE ;	
  Byte2 : BYTE ;	
END_VAR
BEGIN
NETWORK
TITLE =

      L     #Byte1; 
      L     #Byte2; 
      ==I   ; 
      SAVE  ; 
      CLR   ; 
END_FUNCTION

FUNCTION "m7b_SPLIT_BYTE_TO_8xINT" : VOID
TITLE =Splits 1 Byte (8xFLAGs) into 8xINT
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 11/2012
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  FLAGs : BYTE ;	//Byte: FLAGs
END_VAR
VAR_OUTPUT
  INT_BIT_0 : INT ;	
  INT_BIT_1 : INT ;	
  INT_BIT_2 : INT ;	
  INT_BIT_4 : INT ;	
  INT_BIT_3 : INT ;	
  INT_BIT_5 : INT ;	
  INT_BIT_6 : INT ;	
  INT_BIT_7 : INT ;	
END_VAR
VAR_TEMP
  wADR : WORD ;	
  LOOPS : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =

      L     P##INT_BIT_0; // load AR1 with Pointer
      LAR1  ; // of first INT output

NETWORK
TITLE =

      L     #FLAGs; 
      L     8; // Schleifenzähler
LOOP: T     #LOOPS; 
      TAK   ; // FLAGs back to AKKU 1   
      SRW   1; 
      SPP   Hi; 
      L     0; 
      SPA   save; 
Hi:   L     1; 
save: T     W [AR1,P#0.0]; 
      +AR1  P#2.0; 
      TAK   ; // FLAGs back to AKKU 1   
      L     #LOOPS; // Schleifenzähler laden
      LOOP  LOOP; // Schleife bearbeiten
END_FUNCTION

FUNCTION_BLOCK "cPUMP"
TITLE =Pumpensteuerung mit Min- Laufzeit und Impulsbetrieb
//Pumpensteuerung mit Minimallaufzeit sowie Impulsbetrieb (Sommerbetrieb)
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 7/2012
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  FRG : BOOL ;	//Freigabe
  START : BOOL ;	//Pumpe Start
  cfg_PulsBetrieb : BOOL ;	//Pulsbetrieb: nach Max. Ausschaltzeit timPulsOn einschalten
  timMinOn : TIME ;	//Mindestlaufzeit
  timMinOFF : TIME ;	//Min Ausschaltzeit
  timMaxOFF : TIME ;	//Max Ausschaltzeit
  timPulsON : TIME ;	//Einschaltpuls nach max. Ausschaltzeit
END_VAR
VAR_OUTPUT
  PUMP : BOOL ;	
END_VAR
VAR
  Q_TON_Min : BOOL ;	
  Q_PUMP : BOOL ;	
  Q_TON_MaxOff : BOOL ;	
  Q_PULS_ON : BOOL ;	
  Q_TOF_MinAus : BOOL ;	
  TON_MinON : "TON";	
  ton_maxOff : "TON";	
END_VAR
VAR_TEMP
  fktMinON : BOOL ;	
  MinAusSperre : BOOL ;	
  dummy : BOOL ;	
  tMinOn : TIME ;	
  tOFF : TIME ;	
  DSP_tOFF : TIME ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =Funktion Mindeslaufzeit aktiv

      L     #timMinOn; 
      L     0; 
      <>D   ; 
      =     #fktMinON; 
NETWORK
TITLE =(tMaxOff > tMinOff)? sonst tMinOff verwenden

      L     #timMaxOFF; 
      L     #timMinOFF; 
      >=D   ; 
      =     L     14.0; 
      U     L     14.0; 
      SPBNB _001; 
      L     #timMaxOFF; 
      T     #tOFF; 
_001: NOP   0; 
      U     L     14.0; 
      NOT   ; 
      SPBNB _002; 
      L     #timMinOFF; 
      T     #tOFF; 
_002: NOP   0; 
NETWORK
TITLE =Maximale Ausschaltzeit

      U(    ; 
      UN    #Q_PUMP; 
      =     L     14.0; 
      BLD   103; 
      CALL #ton_maxOff (
           IN                       := L     14.0,
           PT                       := #tOFF,
           Q                        := #Q_TON_MaxOff,
           ET                       := #DSP_tOFF);
      U     BIE; 
      )     ; 
      U     #Q_TON_MaxOff; 
      U     #cfg_PulsBetrieb; 
      S     #Q_PULS_ON; 
      U(    ; 
      ON    #Q_TON_Min; 
      ON    #FRG; 
      )     ; 
      R     #Q_PULS_ON; 
      NOP   0; 
NETWORK
TITLE =Mindestauschaltzeit Sperre

      U(    ; 
      L     #timMinOFF; 
      L     0; 
      <>D   ; 
      )     ; 
      U(    ; 
      L     #timMinOFF; 
      L     #DSP_tOFF; 
      <D    ; 
      )     ; 
      =     #MinAusSperre; 
NETWORK
TITLE =Mindestlaufzeit-Timer auch für PulsEin Zeit verwenden
//T#0s in Zeit kopieren, für Reset der Zeit.
//
      O(    ; 
      UN    #Q_PULS_ON; 
      SPBNB _003; 
      L     #timMinOn; 
      T     #tMinOn; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
_003: U     BIE; 
      )     ; 
      O(    ; 
      U     #Q_PULS_ON; 
      SPBNB _004; 
      L     #timPulsON; 
      T     #tMinOn; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
_004: U     BIE; 
      )     ; 
      O(    ; 
      U     #Q_TON_Min; 
      UN    #FRG; 
      SPBNB _005; 
      L     T#0MS; 
      T     #tMinOn; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
_005: U     BIE; 
      )     ; 
      =     #dummy; 
NETWORK
TITLE =Ausgang Pumpe

      U(    ; 
      O     #START; 
      O     ; 
      U     #fktMinON; 
      UN    #Q_TON_Min; 
      O     #Q_PULS_ON; 
      )     ; 
      UN    #MinAusSperre; 
      U     #FRG; 
      =     #Q_PUMP; 
      =     #PUMP; 
NETWORK
TITLE =Pumpensignal auch auf ENO-Ausgang

      U     #Q_PUMP; 
      SAVE  ; 

END_FUNCTION_BLOCK

FUNCTION "m7b_RP_BIT_WRITE" : VOID
TITLE =Ringpuffer schreiben BIT (0..255) (32 Bytes)
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 05/2003
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//09.10.2010   S.Maag          Aufnahme des Bausteins in Maagic7
//                             von DBNr auf BlockDB umgestellt
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  DB_RP : BLOCK_DB ;	//Datenbaustein Ringpuffer
  StartAdrByte : INT ;	//Startadresse Byte des Ringpuffers im DB
  SIGNAL : BOOL ;	//Eingang des zu speichernden Signals
  FLKp : BOOL ;	//positive Flanke Schreibtakt
  FLKn : BOOL ;	//negative Flanke Schreibtakt
END_VAR
VAR_IN_OUT
  RP_POINTER : INT ;	
END_VAR
VAR_TEMP
  tmpDB : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =

      U     #FLKp; // positive Flanke Schreibsignal
      SPB   P; 

      U     #FLKn; // negative Flanke Schreibsignal
      SPB   N; 

      CLR   ; // ENO = FALSE, => keine Verarbeitung
      SAVE  ; 
      BEA   ; 

P:    L     #RP_POINTER; // Pointer vorwärts zählen
      INC   1; // INC: Bytebefehl 0..255
      SPA   save; 

N:    L     #RP_POINTER; // Pointer rückwärts zählen
      DEC   1; // DEC: Bytebefehl 0..255

save: T     #RP_POINTER; // neuen Pointer speichern
      SET   ; 
      SAVE  ; // ENO = TRUE, => Verarbeitung
      CLR   ; 


NETWORK
TITLE =DB öffnen und Pointer auf aktuelles Bit in AR1 
//Adressregister 1 retten ist nöchtig, da dies automatisch bei Bausteinaufrufen 
//mit CALL geschieht (UC Aufrufe sichern nicht!)
      AUF   #DB_RP; 

      L     #StartAdrByte; // StartAdr. ins BitPointerFormat
      SLD   3; 
      L     #RP_POINTER; // Nr des akt. Bits
      +D    ; // Pointer auf aktuelles Bit
      L     P#0.0; // Nullpointer addieren für Pointerkennung
      +D    ; 
      LAR1  ; 
NETWORK
TITLE =Signalzustand in Ringpuffer schreiben

      U     #SIGNAL; 
      =     DBX [AR1,P#0.0]; // Pointer auf aktuelles Bit

END_FUNCTION

FUNCTION "m7b_RB_BIT_READ" : VOID
TITLE =Ringpuffer lesen BIT (0..255) (32 Bytes)
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 05/2003
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//09.10.2010   S.Maag          Aufnahme des Bausteins in Maagic7
//                             von DBNr auf BlockDB umgestellt
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  DB_RP : BLOCK_DB ;	//Datenbaustein Ringpuffer
  StartAdrByte : INT ;	//StartAdresseByte des RingPuffers (Länge = 32 Byte)
  RP_POINTER : INT ;	//aktueller RingpufferPointer
  DISTANZ : INT ;	//Distanz des auszulesenden Wertes
END_VAR
VAR_OUTPUT
  BIT : BOOL ;	
END_VAR
VAR_TEMP
  AR1 : DWORD ;	
END_VAR
BEGIN
NETWORK
TITLE =DB öffnen und Pointer auf aktuelles Bit in AR1 

      TAR1  #AR1; // Adressregister 1 sichern

      AUF   #DB_RP; 

      L     #RP_POINTER; // Nr des akt. Bits
      L     #DISTANZ; // Auslesedistanz
      -I    ; // Auslesepositon berechnen
      L     255; // Berechnung auf ByteFormat
      UW    ; // begrenzen (geht leider nicht mit DEC)
      L     #StartAdrByte; // StartAdr. ins Pointerformat
      SLD   3; 
      +D    ; // Pointer auf aktuelles Bit
      L     P#0.0; // Nullpointer addieren für Pointerkennung
      +D    ; 
      LAR1  ; 
NETWORK
TITLE =Signalzustand aus Ringpuffer lesen

      U     DBX [AR1,P#0.0]; // Pointer auf aktuelles Bit
      =     #BIT; 

      TAR1  #AR1; // Adressregister 1 sichern
END_FUNCTION

FUNCTION "m7b_RingBuffer_ptr_INC" : INT
TITLE =Ringpuffer Pointer addieren (Pointeroffset und Auslesepos.)
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 07/2010
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  RP_POINTER : INT ;	//Pointer Ringpuffer 0..255
  RP_OFFSET : INT ;	//Pointer Rinpuffer Offset (0.255)
END_VAR
BEGIN
NETWORK
TITLE =

      SET   ; 
      SAVE  ; 
      CLR   ; 

NETWORK
TITLE =

      L     #RP_POINTER; // Pointer 1 Ringpuffer
      L     #RP_OFFSET; // Pointer Offset bzw. Pointer 2
      +I    ; // Pointer addieren
      L     255; // auf Byte begrenzen
      UW    ; 
      T     #RET_VAL; // Summe Pointer 0..255


END_FUNCTION

FUNCTION "m7b_RingBuffer_ptr_DEC" : INT
TITLE =Ringpuffer Pointer subtrahieren (Pointeroffset und Auslesepos.)
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 07/2010
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  RP_POINTER : INT ;	//Pointer Ringpuffer 0..255
  RP_OFFSET : INT ;	//Pointer Rinpuffer Offset (0.255)
END_VAR
BEGIN
NETWORK
TITLE =

      SET   ; 
      SAVE  ; 
      CLR   ; 

NETWORK
TITLE =

      L     #RP_POINTER; // Pointer 1 Ringpuffer
      L     #RP_OFFSET; // Pointer Offset bzw. Pointer 2
      -I    ; // Pointer subtrahieren
      L     255; // auf Byte begrenzen
      UW    ; 
      T     #RET_VAL; // Summe Pointer 0..255


END_FUNCTION

FUNCTION "m7b_X_SWITCH_BIT" : VOID
TITLE =Cross Swtich for Bit's
//Cross Switch for BIT's
//
//[IN]
//X     : Switch command: LO: 1:1 D1_1=DO1; HI: 1X1 DI_1=DO_2
//DI_1  : Digitial IN 1
//DI_2  : Digitial IN 2
//
//[OUT]
//DO_1  : Digital Out 1
//DO_2  : Digital Out 2
//
//[FC-ENO]  : 
//
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 6/2012
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  X : BOOL ;	//Switch command: LO: 1:1 D1_1=DO1; HI: DI_1=DO_2
  DI_1 : BOOL ;	//Digitial IN 1
  DI_2 : BOOL ;	//Digitial IN 2
END_VAR
VAR_OUTPUT
  DO_1 : BOOL ;	//Digital Out 1
  DO_2 : BOOL ;	//Digital Out 2
END_VAR
BEGIN
NETWORK
TITLE =

      SET   ; 
      SAVE  ; 
      CLR   ; 

NETWORK
TITLE =

      U     #X; 
      SPB   xed; 

      U     #DI_1; 
      =     #DO_1; 

      U     #DI_2; 
      =     #DO_2; 
      BEA   ; 

xed:  U     #DI_1; 
      =     #DO_2; 

      U     #DI_2; 
      =     #DO_1; 


END_FUNCTION

FUNCTION "m7d_TimeEventDay_DEZ" : VOID
TITLE =TimeEventDay
//Funktion zum Erzeugen eines Ereignisses zu einer bestimmten Zeit. Der 
//Ereignismerker muß nach der Verarbeitung extern zurückgesetzt werden.
//Durch die Verwendung eines Hilfsmerkers wird garantiert, daß das Ereignis 
//bei sofortiger Verarbeitung und rücksetzen des Ereignismerkers, nicht direkt
//wieder ausgelöst wird.
//
//[IN]
//HOUR : Stunde
//MIN  : Minute
//SEC  : Sekunde
//
//[INOUT]
//EVENT    : Ereignismerker (muß nach Verarbeitung extern gelöscht werden)
//HM_EVENT : benötigter Hilfsmerker
//BENÖTIGTE SFCs: SFC1 - READ_CLK
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 9/2004
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  HOUR : INT ;	
  MIN : INT ;	
  SEC : INT ;	
END_VAR
VAR_IN_OUT
  EVENT : BOOL ;	//Ereignis-Merker (wird gesetzt)
  HM : BOOL ;	//Hilfsmerker
END_VAR
VAR_TEMP
  DATE_TIME : DATE_AND_TIME ;	
  ERR_CODE : INT ;	
  m_STD : INT ;	
  m_MIN : INT ;	
  m_SEC : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =Zeit in temporäreren Variablenbereich einlesen

      CALL "READ_CLK" (
           RET_VAL                  := #ERR_CODE,
           CDT                      := #DATE_TIME);
      NOP   0; 
NETWORK
TITLE =Stunden, Minuten und Sekunden aus DATE_AND_TIME extrahieren
//Das DATE_AND_TIME Format benötigt 8 Byte im BCD-Format
//Der Wertebereich geht von DT#1990-1-1-0:0:0.0 bis DT#2089-12-31-23:59:59.999 
//
//BYTE 0:  Jahr
//BYTE 1:  Monat
//BYTE 2:  Tag
//BYTE 3:  Stunde
//BYTE 4:  Minute
//BYTE 5:  Sekunde
//BYTE 6:  100er und 10er Stelle von Millisekunden
//BYTE 7:  Bit 4..7: 1er  Stelle von Millisekunden
//BYTE 7:  Bit 0..3: Wochentag (1=Sonntag, 2=Montag, ..., 7=Samstag)
      L     LB     3; // Stunde
      BTI   ; 
      T     #m_STD; 

      L     LB     4; // Minute
      BTI   ; 
      T     #m_MIN; 

      L     LB     5; // Sekunde
      BTI   ; 
      T     #m_SEC; 


NETWORK
TITLE =Zeit prüfen und Event erzeugen


      L     #HOUR; 
      L     #m_STD; 
      <>I   ; // Stunde stimmt nicht, dann Ende
      SPB   END; 

      L     #MIN; 
      L     #m_MIN; 
      <>I   ; // Minute stimmt nicht
      R     #HM; // HM wieder löschen
      SPB   END; 

      L     #SEC; // Wenn die Sekunden erreicht bzw. überschritten sind,
      L     #m_SEC; // dann Ereignis auslösen
      >=I   ; 
      UN    #HM; 
      S     #HM; 
      S     #EVENT; 
      SPA   END; 

END:  U     #EVENT; // Ereignis als FC_ENO ausgeben, für direkte Weiterverschaltung und Status
      SAVE  ; 
      CLR   ; 
END_FUNCTION

FUNCTION_BLOCK "m7b_SRK_AUSRICHTEN"
TITLE =Standardablauf für Ausrichtfunktion mit Zylinder
//- Ausfahren bis Endstellung
//- Zeit warte
//- Einfahren bis Grundstellung
//- READY
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  START : BOOL ;	
  RESET : BOOL ;	
  POS_AST : BOOL ;	
  POS_GST : BOOL ;	
  timDelayAST : TIME ;	
END_VAR
VAR_OUTPUT
  CMD_AST : BOOL ;	
  CMD_GST : BOOL ;	
  MSG_RUN : BOOL ;	
  MSG_READY : BOOL ;	
  DSP_SNR : INT ;	
END_VAR
VAR
  SNR : INT ;	
  timTimer : TIME ;	
  TON_TIMER : "TON";	
  Q_TIMER : BOOL ;	
  START_TIMER : BOOL ;	
  HM_FP_START : BOOL ;	
END_VAR
VAR_TEMP
  tmpDSP_TIMER : TIME ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =Timer auf mindestens 1ms begrenzen, sonst startet Zeit nicht!

      L     #timTimer; 
      L     T#1MS; 
      >=D   ; 
      SPB   ne2; 
      T     #timTimer; 
ne2:  NOP   0; 
NETWORK
TITLE =Timer für Verzögerungen

      CALL #TON_TIMER (
           IN                       := #START_TIMER,
           PT                       := #timTimer,
           Q                        := #Q_TIMER,
           ET                       := #tmpDSP_TIMER);

NETWORK
TITLE =Schrittablauf clr

      U     #RESET; // Schrittabläufe clr
      SPBNB _001; 
      L     0; 
      T     #SNR; 
_001: NOP   0; 
NETWORK
TITLE =Standard Ablaufsteuerung mit INIT und CLR-Zweig


      L     #SNR; // Schrittnummer
      SPL   CLR; // Sprungziel bei SNR>max
      SPA   INIT; // 0-Schritt, Initialisierung
      SPA   S1; // Startschritt
      SPA   S2; 
      SPA   S3; 
      SPA   S4; 
//      SPA   S5
//      SPA   S6

CLR:  SET   ; // CLR Aktionsmerker die über das Ende der Schrittkette nicht mehr benötigt werden
      R     #START_TIMER; 
      R     #MSG_RUN; 

      L     1; // Schrittnummer 
      T     #SNR; // auf Startschritt stellen
      T     #DSP_SNR; // Schrittnummer Anzeige
      SPA   END; 

INIT: SET   ; // Initalisierung
      R     #MSG_READY; 

// hier die bei INIT zu löschenden Merker eintragen
// z.B. Aktionsmerker die über das Ende der Schrittkette weiterhin benötigt werden
// wird bei verketteten oder mehrstufigen Schrittabläufen benötigt
      CLR   ; 
      SPA   CLR; 
      SPA   SET; // wird nur benötigt, damit die Entwicklungsumgebung die Sprungmarke nicht löscht


NETWORK
TITLE =Schrittweiterschaltung, bzw. Bausteinende

NEXT: L     #SNR; // NEXT : Schrittnummer auf nächsten
      +     1; // Schritt
SET:  T     #SNR; // Ablauf auf Schritt mit Nr. in Akku 1 setzen

END:  L     #SNR; // Sprungmarke für Baustein ENDE
      T     #DSP_SNR; // Schrittnummer Anzeige
      L     1; // Wenn Ablauf läuft, dann ENO-Ausgang = 1
      >I    ; 
      SAVE  ; 
      CLR   ; 
      BEA   ; 

NETWORK
TITLE =Startschritt

S1:   U     #START; // Start ausrichten
      FP    #HM_FP_START; 
      S     #MSG_RUN; 
      R     #MSG_READY; 
      S     #CMD_AST; 
      R     #CMD_GST; 
      SPB   NEXT; 
      SPA   END; 
NETWORK
TITLE =Schritt 2: Enstellung erreicht? Timer starten!

S2:   U     #POS_AST; 
      SPBN  END; 

      S     #START_TIMER; // Timer starten
      L     #timDelayAST; // Zeit für Timer
      T     #timTimer; 

      SPA   NEXT; 

NETWORK
TITLE =Schritt 3: Timer abgelaufen? zu Grundstellung!

S3:   U     #Q_TIMER; // Timer abgelaufen
      R     #START_TIMER; 
      R     #CMD_AST; 
      S     #CMD_GST; 
      SPB   NEXT; 
      SPA   END; 

NETWORK
TITLE =Schritt 4: Grundstellung erreicht? READY!

S4:   U     #POS_GST; 
      S     #MSG_READY; 
      SPB   NEXT; 
      SPA   END; 

END_FUNCTION_BLOCK

FUNCTION "m7b_TOL_HYS_INT" : VOID
TITLE =Position mit Toleranzen und Hysteres prüfen [INT]
//Anwendung:
//Toleranzprüfungen bei welchen das ok-Signal erst bei überschreiten
//einer größeren Toleranz wieder gelöscht werden soll
//
//z.B. Positionieranwendungen: nachpositionieren erst wenn Hysterseschwelle
//der Toleranz überschritten ist
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 01/2015
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  IST : INT ;	//Istwert Achse
  SOLL : INT ;	//Sollwert
  TOL : INT ;	//Toleranz Posiitionierung Achse Stop
  HYS : INT ;	//Hysterese, Position nicht mehr o.k.
END_VAR
VAR_IN_OUT
  io_OK : BOOL ;	
END_VAR
VAR_TEMP
  TOL_HYS : INT ;	
  TOL_1_OK : BOOL ;	
  TOL_2_OK : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =Position mit Toleranzen und Hysterese prüfen

      L     #TOL; // Toleranz
      L     #HYS; // Hysteres
      +I    ; 
      T     #TOL_HYS; // Toleranz, Hystereseschwelle

      L     #SOLL; // aktuelle Sollposition
      L     #IST; // aktuelle Istposition
      -I    ; // Positionierdifferenz
      SPP   PLUS; 
      NEGI  ; // nach positiv

PLUS: L     #TOL; // Toleranz für Position ok
      <=I   ; 
      S     #io_OK; // Ausgang Position ok
      TAK   ; // Positionsdifferenz in AKKU1
      L     #TOL_HYS; // Toleranz für Positionierung
      >I    ; 
      R     #io_OK; // Ausgang Position ok

      U     #io_OK; 
      SAVE  ; 
      CLR   ; 


END_FUNCTION

FUNCTION "m7b_AVG_MIN_MAX_4xINT" : VOID
TITLE =MIN, MAX, AVERAGE from activated channels (CH1,CH2,CH3,CH4)
//Give back the minimum, maximum and average value of 4 values (channels)
//
//INPUT:
//iCH1      : value channel 1
//iCH2      : value channel 2
//iCH3      : value channel 3
//iCH4      : value channel 4
//iCH_OFF   : value is all channels are deactivated (OFF) 
//
//CH1_active: FLASE: channel is deactivated (not included in calcuation)
//.           TRUE : channel is activated (included in calculation)
//. 
//CH4_active:
//
//---------------------------------------------------------
//OUTPUT:
//AVG       : AVERAGE(CH1,CH2,CH3,CH4) or CH_off if all channels deactivated
//MIN       : MINIMUM(CH1,CH2,CH3,CH4) or CH_off if all channels deactivated
//MAX       : MAXIMUM(CH1,CH2,CH3,CH4) or CH_off if all channels deactivated
//NoCH_min  : Channel No. of minimum value; 0 if all channels deactivated
//NoCH_max  : Channel No. of maximum value; 0 if all channels deactivated
//NoOfActCH : Number of activated channels [0..4]
//FC-ENO    : FALSE: alle channels are disactivated; CH_OFF is selected
//            TRUE : at least 1 channel is activated; Min/Max is selected
//
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2018
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME      AENDERUNG
//--------------------------------------------------------------------------------
//06.08.2018   S.Maag    created by editing FC233 m7b_AVG_MIN_MAX_4xREAL
//24.09.2015   S.Maag    Function tested i.o.
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  iCH1 : INT ;	//Value channel 1
  iCH2 : INT ;	//Value channel 2
  iCH3 : INT ;	//Value channel 3
  iCH4 : INT ;	//Value channel 4
  iCH_OFF : INT ;	//Value if all channels are deactivated
  CH1_active : BOOL ;	//TRUE activates channel l 
  CH2_active : BOOL ;	//TRUE activates channel 2 
  CH3_active : BOOL ;	//TRUE activates channel 3 
  CH4_active : BOOL ;	//TRUE activates channel 4
END_VAR
VAR_OUTPUT
  iAVG : INT ;	//Average value
  iMIN : INT ;	//Minimum value
  iMAX : INT ;	//Maximum value
  iNoCH_min : INT ;	//Channel No of Min Value (1..3) or 0 if all channels are OFF
  iNoCH_max : INT ;	//Channel No of Max Value (1..3) or 0 if all channels are OFF
  iNoOfActCH : INT ;	//Number of activated channel [0..4]
END_VAR
VAR_TEMP
  off : BOOL ;	
  tmpNoOfCHs : INT ;	
  ARY : ARRAY  [1 .. 4 ] OF STRUCT 	
   iVAL : INT ;	
   iCH : INT ;	
   CHisActive : BOOL ;	
  END_STRUCT ;	
  tmpMin : STRUCT 	
   iVAL : INT ;	
   iCH : INT ;	
   IsValid : BOOL ;	
  END_STRUCT ;	
  tmpMax : STRUCT 	
   iVAL : INT ;	
   iCH : INT ;	
   IsValid : BOOL ;	
  END_STRUCT ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =move activated channels to a temp. ARRAY & count active channels
//if a channel is not activated, it's temporary variable will be 0.0
      L     0; // clear temporary channel variables
      T     #ARY[1].iVAL; 
      T     #ARY[2].iVAL; 
      T     #ARY[3].iVAL; 
      T     #ARY[4].iVAL; 

      L     0; // clear the channel no.
      T     #tmpNoOfCHs; 
      T     #ARY[1].iCH; 
      T     #ARY[2].iCH; 
      T     #ARY[3].iCH; 
      T     #ARY[4].iCH; 

      CLR   ; 
      =     #ARY[1].CHisActive; 
      =     #ARY[2].CHisActive; 
      =     #ARY[3].CHisActive; 
      =     #ARY[4].CHisActive; 

      UN    #CH1_active; // copy CH1 if activated
      SPB   chk2; 

      S     #ARY[1].CHisActive; 
      L     #iCH1; 
      T     #ARY[1].iVAL; 
      L     1; 
      T     #ARY[1].iCH; 

      L     #tmpNoOfCHs; 
      INC   1; 
      T     #tmpNoOfCHs; 

chk2: UN    #CH2_active; // copy CH2 if activated
      SPB   chk3; 

      S     #ARY[2].CHisActive; 
      L     #iCH2; 
      T     #ARY[2].iVAL; 
      L     2; 
      T     #ARY[2].iCH; 

      L     #tmpNoOfCHs; 
      INC   1; 
      T     #tmpNoOfCHs; 


chk3: UN    #CH3_active; // copy CH3 if activated
      SPB   chk4; 

      S     #ARY[3].CHisActive; 
      L     #iCH3; 
      T     #ARY[3].iVAL; 
      L     3; 
      T     #ARY[3].iCH; 

      L     #tmpNoOfCHs; 
      INC   1; 
      T     #tmpNoOfCHs; 


chk4: UN    #CH4_active; // copy CH4 if activated
      SPB   ne3; 

      S     #ARY[4].CHisActive; 
      L     #iCH4; 
      T     #ARY[4].iVAL; 
      L     4; 
      T     #ARY[4].iCH; 

      L     #tmpNoOfCHs; 
      INC   1; 
      T     #tmpNoOfCHs; 

ne3:  NOP   0; 
NETWORK
TITLE =Check: all channels OFF

      L     #tmpNoOfCHs; 
      T     #iNoOfActCH; // FC Output: Number of active channels
      L     0; 
      ==I   ; 
      =     #off; 
      NOT   ; 
      SAVE  ; // ENO=FALSE if all channels are deactivated
      CLR   ; 

NETWORK
TITLE =AVAERAGE (CH1, CH2, CH3, CH4)
//calculate the average of CH1..4
      L     #iCH_OFF; // if all channels are deactivated,
      U     #off; // the average value is 0.0
      SPB   sAvg; // save the avarage value

      L     #ARY[1].iVAL; // building the sum of all channels
      L     #ARY[2].iVAL; // if channel is deactivated, tmp_CH-Value is 0.0
      +I    ; 
      L     #ARY[3].iVAL; 
      +I    ; 
      L     #ARY[4].iVAL; 
      +I    ; // = CH1+CH2+CH3+CH4
      L     #tmpNoOfCHs; // number of activated channels
      /I    ; 
sAvg: T     #iAVG; // the AVERAGE value of all activated channels 


NETWORK
TITLE =COPY first Element of ARY to tmpMin and tmpMax
//to start min/max check with first element of CH-Array, the first Array-Element 
//is copied to to the tmpMin and tmpMax structure
      L     #ARY[1].iVAL; 
      T     #tmpMin.iVAL; 
      T     #tmpMax.iVAL; 

      L     #ARY[1].iCH; 
      T     #tmpMin.iCH; 
      T     #tmpMax.iCH; 

      U     #ARY[1].CHisActive; 
      =     #tmpMin.IsValid; 
      =     #tmpMax.IsValid; 

NETWORK
TITLE =Get the MINIMUM value
//     
//
      L     #tmpMin.iVAL; // tempMin.Val
      L     #ARY[2].iVAL; // CH2.Val
      >I    ; // IF CH2.Val < tmpMin
      U     #ARY[2].CHisActive; //    AND CH2.IsActivated
      ON    #tmpMin.IsValid; //    OR  NOT tmpMin.IsValid
      SPBN  mn3; // ELSE continue with CH3

      L     #ARY[2].iVAL; // THEN COPY CH2->tmpMin, because CH2 is the
      T     #tmpMin.iVAL; // act. minimum or tmpMin is not valid

      L     #ARY[2].iCH; 
      T     #tmpMin.iCH; 

      U     #ARY[2].CHisActive; // (if CH2 is not activated
      =     #tmpMin.IsValid; //  then tmpMin is not valid)

mn3:  L     #tmpMin.iVAL; // Channel 3 !see above documentation CH2!
      L     #ARY[3].iVAL; 
      >I    ; 
      U     #ARY[3].CHisActive; 
      ON    #tmpMin.IsValid; 
      SPBN  mn4; 

      L     #ARY[3].iVAL; 
      T     #tmpMin.iVAL; 

      L     #ARY[3].iCH; 
      T     #tmpMin.iCH; 

      U     #ARY[3].CHisActive; 
      =     #tmpMin.IsValid; 

mn4:  L     #tmpMin.iVAL; // Channel 4
      L     #ARY[4].iVAL; 
      >I    ; 
      U     #ARY[4].CHisActive; 
      ON    #tmpMin.IsValid; 
      SPBN  mn5; 

      L     #ARY[4].iVAL; 
      T     #tmpMin.iVAL; 

      L     #ARY[4].iCH; 
      T     #tmpMin.iCH; 

      U     #ARY[4].CHisActive; 
      =     #tmpMin.IsValid; 

mn5:  L     #tmpMin.iVAL; // If tmpMin.Val IsValid
      U     #tmpMin.IsValid; 
      SPB   smin; // THEN copy the min. to FC-Out

      L     0; // ELSE copy 0 to FC-Out
      T     #tmpMin.iCH; 
      L     #iCH_OFF; 

smin: T     #iMIN; // copy the min. to FC-Out
      L     #tmpMin.iCH; // channel no. with minimum
      T     #iNoCH_min; 


NETWORK
TITLE =Get the MAXIUM value

      L     #tmpMax.iVAL; // tempMax.Val
      L     #ARY[2].iVAL; // CH2.Val
      <I    ; // IF CH2.Val > tmpMin
      U     #ARY[2].CHisActive; //    AND CH2.IsActivated
      ON    #tmpMin.IsValid; //    OR NOT tmpMax.IsValid
      SPBN  mx3; // ELSE continue with CH3

      L     #ARY[2].iVAL; // THEN COPY CH2->tmpMax, because CH2 is the
      T     #tmpMax.iVAL; // act. maximum or tmpMax is not valid

      L     #ARY[2].iCH; 
      T     #tmpMax.iCH; 

      U     #ARY[2].CHisActive; // (if CH2 is not activated
      =     #tmpMax.IsValid; //  then tmpMax is not valid)

mx3:  L     #tmpMax.iVAL; // Channel 3 !see above documentation CH2!
      L     #ARY[3].iVAL; 
      <I    ; 
      U     #ARY[3].CHisActive; 
      ON    #tmpMax.IsValid; 
      SPBN  mx4; 

      L     #ARY[3].iVAL; 
      T     #tmpMax.iVAL; 

      L     #ARY[3].iCH; 
      T     #tmpMax.iCH; 

      U     #ARY[3].CHisActive; 
      =     #tmpMax.IsValid; 

mx4:  L     #tmpMax.iVAL; // Channel 4
      L     #ARY[4].iVAL; 
      <I    ; 
      U     #ARY[4].CHisActive; 
      ON    #tmpMax.IsValid; 
      SPBN  mx5; 

      L     #ARY[4].iVAL; 
      T     #tmpMax.iVAL; 

      L     #ARY[4].iCH; 
      T     #tmpMax.iCH; 

      U     #ARY[4].CHisActive; 
      =     #tmpMax.IsValid; 

mx5:  L     #tmpMax.iVAL; // If tmpMax.Val IsValid
      U     #tmpMax.IsValid; 
      SPB   smax; // THEN copy the max to FC-Out

      L     0; // ELSE copy 0 to FC-Out
      T     #tmpMax.iCH; 
      L     #iCH_OFF; 

smax: T     #iMAX; // copy the max. to FC-Out
      L     #tmpMax.iCH; // channel no. with maximum
      T     #iNoCH_max; 


END_FUNCTION

FUNCTION "m7b_Weiche_x4_INT" : VOID
TITLE =4-fach Weiche INT
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2018
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//15.08.2018   S.Maag      enstanden aus MUXx4xINT
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 2.0


VAR_INPUT
  CH1 : BOOL ;	
  CH2 : BOOL ;	
  CH3 : BOOL ;	
  CH4 : BOOL ;	
  ENABLE : BOOL ;	
  iValue : INT ;	
END_VAR
VAR_OUTPUT
  DSP_CHANNEL : INT ;	//Displays the activated channel
END_VAR
VAR_IN_OUT
  ioINT1 : INT ;	
  ioINT2 : INT ;	
  ioINT3 : INT ;	
  ioINT4 : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =

      UN    #ENABLE; // keine Freigabe, dann 0 ausgeben
      SPB   OFF; 

      L     #iValue; 

      U     #CH1; 
      SPB   CH1; 
      U     #CH2; 
      SPB   CH2; 
      U     #CH3; 
      SPB   CH3; 
      U     #CH4; 
      SPB   CH4; 

      SPA   OFF; 

CH1:  T     #ioINT1; 
      L     1; // Wert für Kanalanzeige
      SPA   SAVE; 

CH2:  T     #ioINT2; 
      L     2; 
      SPA   SAVE; 

CH3:  T     #ioINT3; 
      L     3; 
      SPA   SAVE; 

CH4:  T     #ioINT4; 
      L     4; 
      SPA   SAVE; 

OFF:  L     0; 
      CLR   ; // EN0-Ausgang =0, da Stopp

SAVE: SAVE  ; 
      T     #DSP_CHANNEL; // Anzeige aktiver Kanal

END_FUNCTION

FUNCTION "m7b_RAMP_UpDwn_INT" : VOID
TITLE =RAMP Up/Down INT
//Pro Aufruf des FC wird iUP addiert bzw. iDOWN abgezogen
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 11/2012
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME      AENDERUNG
//--------------------------------------------------------------------------------
//17.04.2020   S.Maag    in Library aufgenommen
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  iVALUE : INT ;	
  iUP : INT ;	
  iDOWN : INT ;	
  TAKT : BOOL ;	
  RESET : BOOL ;	
END_VAR
VAR_IN_OUT
  memVAL : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =

      SET   ; 
      SAVE  ; 
      CLR   ; 
NETWORK
TITLE =Reset

      UN    #RESET; 
      SPB   ne1; 
      L     #iVALUE; 
      T     #memVAL; 
      BEA   ; 

ne1:  UN    #TAKT; 
      BEB   ; 

NETWORK
TITLE =Rampe maximal up/down to iValue

      L     #iVALUE; 
      L     #memVAL; 
      >I    ; 
      SPB   up; 
      <I    ; 
      SPB   dwn; 
      BEA   ; 

up:   L     #memVAL; 
      L     #iUP; 
      +I    ; 
      L     #iVALUE; 
      >I    ; 
      SPB   save; 
      TAK   ; 
      SPA   save; 

dwn:  L     #memVAL; 
      L     #iDOWN; 
      -I    ; 
      L     #iVALUE; 
      <I    ; 
      SPB   save; 
      TAK   ; 

save: T     #memVAL; 

END_FUNCTION

FUNCTION "m7b_RP_Vortrag_INT" : VOID
TITLE =Ringpuffer Vortrag um n-Werte
//Trägt Wert in Ringpuffer von n-Werten vor. Der aktuelle Index des Puffers darf 
//dabei nicht verändert werden. (ACHTUNG: Vortrag im RP ist rückwärts schreiben 
//mit DEC INDEX.
//
//Dies hat den Effekt, als wäre das Produkt bereits etwas früher erfasst worden.
//Die Werte im Datenpuffer laufen dem Produkt bereits etwas voraus, was eine 
//korrekte Zuordung erleichtert.
//Praktisch kombiniet man das mit freier Wegstrecke, auf dem Folgetransport.
//Unbedingt erforderlich ist der Wertevortrag, wenn z.B. mit höherer 
//Geschwindigkeit auf Freilaufrollen des Folgetransports geschoben wird. Das 
//Produkt würde sonst wegen der Differenzgeschwindigkeit vor den Werten herlaufen.
//Eine korrekte Zuordung der Daten wäre somit nicht möglich.
//
//iMaxLimmit begrenzt die Anzahl der vorgetragenen Werte. Somit kann man 
//iNoOfValues die freie Wegstrecke nach dem Anfangssensor Transport übergeben
//und der Vortrag wird auf iMaxLimit begrenzt, falls freie Wegstrecke größer.
//
//mit iMaxLimit = iNoOfValues = 256, wird der komplette Rinpuffer mit iFillValue 
//überschrieben
//
//                                              v (25=act Index)
//10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33
// 0  a  a  a  a  a  a  o  o  o  o  o  o  o  o  o
// 0  a  a  a  a  a  a  o  o  o  o  b  b  b  b  b  (Vortrag von Prod. b um 5)
//    |Vorderkante   |Hinterkante
//
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 1/2018
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  DB_RP : BLOCK_DB ;	//Block DB: RingBuffer
  iFillValue : INT ;	//Write this value (start at act. RP_IDX)
  iNoOfValues : INT ;	//No of values to fill [0..256]
  iMaxLimit : INT ;	//Limits the NoOfValues to fill [0..256]
END_VAR
VAR_IN_OUT
  RP_IDX : INT ;	//Indexwert Ringpuffer 0..255
END_VAR
VAR_TEMP
  LoopCNT : INT ;	
  tmpPTR : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =

      SET   ; 
      SAVE  ; 
      CLR   ; 
NETWORK
TITLE =

      L     #RP_IDX; // actual index of Ring-Buffer
      INC   1; // INC 1 because of effective LOOP, DEC 1 will be operated first
      T     #tmpPTR; 
      AUF   #DB_RP; // opens Ring-Buffer DB
NETWORK
TITLE =Min/Max Limit NoOfValues

      L     #iNoOfValues; 
      L     #iMaxLimit; // MaxLimit of iNoOfValues
      >I    ; 
      SPB   max; 
      TAK   ; // #iNoOfValues  back to AKKU
max:  L     256; // max 256
      >I    ; 
      SPB   Loop; 
      TAK   ; // #iNoOfValues  back to AKKU
      L     0; 
      <=I   ; 
      BEB   ; // End if iNoOfValues <=0
      TAK   ; // #iNoOfValues back to AKKU
NETWORK
TITLE =LOOP to write the Values

Loop: T     #LoopCNT; 
      L     #tmpPTR; // Indexwert Ringpuffer 0..255
      DEC   1; 
      T     #tmpPTR; // Indexwert Ringpuffer 0..255
      SLD   4; // SLD 1 wegen DINT-Werten=>Byte + SLD 3 wegen Pointer
      L     P#0.0; // 0-Pointer addieren
      +D    ; // Pointer auf Daten erzeugen
      LAR1  ; // in Adressregister 1 laden
      L     #iFillValue; // Eingangswert laden
      T     DBW [AR1,P#0.0]; // in DB speichern
      L     #LoopCNT; 
      LOOP  Loop; // Loop UP
END_FUNCTION

FUNCTION "m7b_TOL_HYS_DINT" : VOID
TITLE =Position mit Toleranzen und Hysteres prüfen [DINT]
//Anwendung:
//Toleranzprüfungen bei welchen das ok-Signal erst bei überschreiten
//einer größeren Toleranz wieder gelöscht werden soll
//
//z.B. Positionieranwendungen: nachpositionieren erst wenn Hysterseschwelle
//der Toleranz überschritten ist
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 01/2015
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  IST : DINT ;	//Istwert Achse
  SOLL : DINT ;	//Sollwert
  TOL : DINT ;	//Toleranz Posiitionierung Achse Stop
  HYS : DINT ;	//Hysterese, Position nicht mehr o.k.
END_VAR
VAR_IN_OUT
  io_OK : BOOL ;	
END_VAR
VAR_TEMP
  TOL_HYS : DINT ;	
  TOL_1_OK : BOOL ;	
  TOL_2_OK : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =Position mit Toleranzen und Hysterese prüfen

      L     #TOL; // Toleranz
      L     #HYS; // Hysteres
      +D    ; 
      T     #TOL_HYS; // Toleranz, Hystereseschwelle

      L     #SOLL; // aktuelle Sollposition
      L     #IST; // aktuelle Istposition
      -D    ; // Positionierdifferenz
      SPP   PLUS; 
      NEGD  ; // nach positiv

PLUS: L     #TOL; // Toleranz für Position ok
      <=D   ; 
      S     #io_OK; // Ausgang Position ok
      TAK   ; // Positionsdifferenz in AKKU1
      L     #TOL_HYS; // Toleranz für Positionierung
      >D    ; 
      R     #io_OK; // Ausgang Position ok

      U     #io_OK; 
      SAVE  ; 
      CLR   ; 


END_FUNCTION

FUNCTION "m7b_AVG_MIN_MAX_4xDINT" : VOID
TITLE =MIN, MAX, AVERAGE from activated channels (CH1,CH2,CH3,CH4)
//Give back the minimum, maximum and average value of 4 values (channels)
//
//INPUT:
//iCH1      : value channel 1
//iCH2      : value channel 2
//iCH3      : value channel 3
//iCH4      : value channel 4
//iCH_OFF   : value is all channels are deactivated (OFF) 
//
//CH1_active: FLASE: channel is deactivated (not included in calcuation)
//.           TRUE : channel is activated (included in calculation)
//. 
//CH4_active:
//
//---------------------------------------------------------
//OUTPUT:
//AVG       : AVERAGE(CH1,CH2,CH3,CH4) or CH_off if all channels deactivated
//MIN       : MINIMUM(CH1,CH2,CH3,CH4) or CH_off if all channels deactivated
//MAX       : MAXIMUM(CH1,CH2,CH3,CH4) or CH_off if all channels deactivated
//NoCH_min  : Channel No. of minimum value; 0 if all channels deactivated
//NoCH_max  : Channel No. of maximum value; 0 if all channels deactivated
//NoOfActCH : Number of activated channels [0..4]
//FC-ENO    : FALSE: alle channels are disactivated; CH_OFF is selected
//            TRUE : at least 1 channel is activated; Min/Max is selected
//
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2018
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME      AENDERUNG
//--------------------------------------------------------------------------------
//06.08.2018   S.Maag    created by editing FC233 m7b_AVG_MIN_MAX_4xREAL
//24.09.2015   S.Maag    Function tested i.o.
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  dCH1 : DINT ;	//Value channel 1
  dCH2 : DINT ;	//Value channel 2
  dCH3 : DINT ;	//Value channel 3
  dCH4 : DINT ;	//Value channel 4
  dCH_OFF : DINT ;	//Value if all channels are deactivated
  CH1_active : BOOL ;	//TRUE activates channel l 
  CH2_active : BOOL ;	//TRUE activates channel 2 
  CH3_active : BOOL ;	//TRUE activates channel 3 
  CH4_active : BOOL ;	//TRUE activates channel 4
END_VAR
VAR_OUTPUT
  dAVG : DINT ;	//Average value
  dMIN : DINT ;	//Minimum value
  dMAX : DINT ;	//Maximum value
  iNoCH_min : INT ;	//Channel No of Min Value (1..3) or 0 if all channels are OFF
  iNoCH_max : INT ;	//Channel No of Max Value (1..3) or 0 if all channels are OFF
  iNoOfActCH : INT ;	//Number of activated channel [0..4]
END_VAR
VAR_TEMP
  off : BOOL ;	
  tmpNoOfCHs : INT ;	
  ARY : ARRAY  [1 .. 4 ] OF STRUCT 	
   dVAL : DINT ;	
   iCH : INT ;	
   CHisActive : BOOL ;	
  END_STRUCT ;	
  tmpMin : STRUCT 	
   dVAL : DINT ;	
   iCH : INT ;	
   IsValid : BOOL ;	
  END_STRUCT ;	
  tmpMax : STRUCT 	
   dVAL : DINT ;	
   iCH : INT ;	
   IsValid : BOOL ;	
  END_STRUCT ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =move activated channels to a temp. ARRAY & count active channels
//if a channel is not activated, it's temporary variable will be 0.0
      L     L#0; // clear temporary channel variables
      T     #ARY[1].dVAL; 
      T     #ARY[2].dVAL; 
      T     #ARY[3].dVAL; 
      T     #ARY[4].dVAL; 

      L     0; // clear the channel no.
      T     #tmpNoOfCHs; 
      T     #ARY[1].iCH; 
      T     #ARY[2].iCH; 
      T     #ARY[3].iCH; 
      T     #ARY[4].iCH; 

      CLR   ; 
      =     #ARY[1].CHisActive; 
      =     #ARY[2].CHisActive; 
      =     #ARY[3].CHisActive; 
      =     #ARY[4].CHisActive; 

      UN    #CH1_active; // copy CH1 if activated
      SPB   chk2; 

      S     #ARY[1].CHisActive; 
      L     #dCH1; 
      T     #ARY[1].dVAL; 
      L     1; 
      T     #ARY[1].iCH; 

      L     #tmpNoOfCHs; 
      INC   1; 
      T     #tmpNoOfCHs; 

chk2: UN    #CH2_active; // copy CH2 if activated
      SPB   chk3; 

      S     #ARY[2].CHisActive; 
      L     #dCH2; 
      T     #ARY[2].dVAL; 
      L     2; 
      T     #ARY[2].iCH; 

      L     #tmpNoOfCHs; 
      INC   1; 
      T     #tmpNoOfCHs; 


chk3: UN    #CH3_active; // copy CH3 if activated
      SPB   chk4; 

      S     #ARY[3].CHisActive; 
      L     #dCH3; 
      T     #ARY[3].dVAL; 
      L     3; 
      T     #ARY[3].iCH; 

      L     #tmpNoOfCHs; 
      INC   1; 
      T     #tmpNoOfCHs; 


chk4: UN    #CH4_active; // copy CH4 if activated
      SPB   ne3; 

      S     #ARY[4].CHisActive; 
      L     #dCH4; 
      T     #ARY[4].dVAL; 
      L     4; 
      T     #ARY[4].iCH; 

      L     #tmpNoOfCHs; 
      INC   1; 
      T     #tmpNoOfCHs; 

ne3:  NOP   0; 
NETWORK
TITLE =Check: all channels OFF

      L     #tmpNoOfCHs; 
      T     #iNoOfActCH; // FC Output: Number of active channels
      L     0; 
      ==I   ; 
      =     #off; 
      NOT   ; 
      SAVE  ; // ENO=FALSE if all channels are deactivated
      CLR   ; 

NETWORK
TITLE =AVAERAGE (CH1, CH2, CH3, CH4)
//calculate the average of CH1..4
      L     #dCH_OFF; // if all channels are deactivated,
      U     #off; // the average value is 0.0
      SPB   sAvg; // save the avarage value

      L     #ARY[1].dVAL; // building the sum of all channels
      L     #ARY[2].dVAL; // if channel is deactivated, tmp_CH-Value is 0.0
      +D    ; 
      L     #ARY[3].dVAL; 
      +D    ; 
      L     #ARY[4].dVAL; 
      +D    ; // = CH1+CH2+CH3+CH4
      L     #tmpNoOfCHs; // number of activated channels
      /D    ; 
sAvg: T     #dAVG; // the AVERAGE value of all activated channels 


NETWORK
TITLE =COPY first Element of ARY to tmpMin and tmpMax
//to start min/max check with first element of CH-Array, the first Array-Element 
//is copied to to the tmpMin and tmpMax structure
      L     #ARY[1].dVAL; 
      T     #tmpMin.dVAL; 
      T     #tmpMax.dVAL; 

      L     #ARY[1].iCH; 
      T     #tmpMin.iCH; 
      T     #tmpMax.iCH; 

      U     #ARY[1].CHisActive; 
      =     #tmpMin.IsValid; 
      =     #tmpMax.IsValid; 

NETWORK
TITLE =Get the MINIMUM value
//     
//
      L     #tmpMin.dVAL; // tempMin.Val
      L     #ARY[2].dVAL; // CH2.Val
      >D    ; // IF CH2.Val < tmpMin
      U     #ARY[2].CHisActive; //    AND CH2.IsActivated
      ON    #tmpMin.IsValid; //    OR  NOT tmpMin.IsValid
      SPBN  mn3; // ELSE continue with CH3

      L     #ARY[2].dVAL; // THEN COPY CH2->tmpMin, because CH2 is the
      T     #tmpMin.dVAL; // act. minimum or tmpMin is not valid

      L     #ARY[2].iCH; 
      T     #tmpMin.iCH; 

      U     #ARY[2].CHisActive; // (if CH2 is not activated
      =     #tmpMin.IsValid; //  then tmpMin is not valid)

mn3:  L     #tmpMin.dVAL; // Channel 3 !see above documentation CH2!
      L     #ARY[3].dVAL; 
      >D    ; 
      U     #ARY[3].CHisActive; 
      ON    #tmpMin.IsValid; 
      SPBN  mn4; 

      L     #ARY[3].dVAL; 
      T     #tmpMin.dVAL; 

      L     #ARY[3].iCH; 
      T     #tmpMin.iCH; 

      U     #ARY[3].CHisActive; 
      =     #tmpMin.IsValid; 

mn4:  L     #tmpMin.dVAL; // Channel 4
      L     #ARY[4].dVAL; 
      >D    ; 
      U     #ARY[4].CHisActive; 
      ON    #tmpMin.IsValid; 
      SPBN  mn5; 

      L     #ARY[4].dVAL; 
      T     #tmpMin.dVAL; 

      L     #ARY[4].iCH; 
      T     #tmpMin.iCH; 

      U     #ARY[4].CHisActive; 
      =     #tmpMin.IsValid; 

mn5:  L     #tmpMin.dVAL; // If tmpMin.Val IsValid
      U     #tmpMin.IsValid; 
      SPB   smin; // THEN copy the min. to FC-Out

      L     0; // ELSE copy 0 to FC-Out
      T     #tmpMin.iCH; 
      L     #dCH_OFF; 

smin: T     #dMIN; // copy the min. to FC-Out
      L     #tmpMin.iCH; // channel no. with minimum
      T     #iNoCH_min; 


NETWORK
TITLE =Get the MAXIUM value

      L     #tmpMax.dVAL; // tempMax.Val
      L     #ARY[2].dVAL; // CH2.Val
      <D    ; // IF CH2.Val > tmpMin
      U     #ARY[2].CHisActive; //    AND CH2.IsActivated
      ON    #tmpMin.IsValid; //    OR NOT tmpMax.IsValid
      SPBN  mx3; // ELSE continue with CH3

      L     #ARY[2].dVAL; // THEN COPY CH2->tmpMax, because CH2 is the
      T     #tmpMax.dVAL; // act. maximum or tmpMax is not valid

      L     #ARY[2].iCH; 
      T     #tmpMax.iCH; 

      U     #ARY[2].CHisActive; // (if CH2 is not activated
      =     #tmpMax.IsValid; //  then tmpMax is not valid)

mx3:  L     #tmpMax.dVAL; // Channel 3 !see above documentation CH2!
      L     #ARY[3].dVAL; 
      <D    ; 
      U     #ARY[3].CHisActive; 
      ON    #tmpMax.IsValid; 
      SPBN  mx4; 

      L     #ARY[3].dVAL; 
      T     #tmpMax.dVAL; 

      L     #ARY[3].iCH; 
      T     #tmpMax.iCH; 

      U     #ARY[3].CHisActive; 
      =     #tmpMax.IsValid; 

mx4:  L     #tmpMax.dVAL; // Channel 4
      L     #ARY[4].dVAL; 
      <D    ; 
      U     #ARY[4].CHisActive; 
      ON    #tmpMax.IsValid; 
      SPBN  mx5; 

      L     #ARY[4].dVAL; 
      T     #tmpMax.dVAL; 

      L     #ARY[4].iCH; 
      T     #tmpMax.iCH; 

      U     #ARY[4].CHisActive; 
      =     #tmpMax.IsValid; 

mx5:  L     #tmpMax.dVAL; // If tmpMax.Val IsValid
      U     #tmpMax.IsValid; 
      SPB   smax; // THEN copy the max to FC-Out

      L     0; // ELSE copy 0 to FC-Out
      T     #tmpMax.iCH; 
      L     #dCH_OFF; 

smax: T     #dMAX; // copy the max. to FC-Out
      L     #tmpMax.iCH; // channel no. with maximum
      T     #iNoCH_max; 


END_FUNCTION

FUNCTION "m7b_Weiche_x4_DINT" : VOID
TITLE =4-fach Weiche DINT 
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2018
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//15.08.2018   S.Maag      enstanden aus Weiche4x_INT
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 2.0


VAR_INPUT
  CH1 : BOOL ;	
  CH2 : BOOL ;	
  CH3 : BOOL ;	
  CH4 : BOOL ;	
  ENABLE : BOOL ;	
  dValue : DINT ;	
END_VAR
VAR_OUTPUT
  DSP_CHANNEL : INT ;	//Displays the activated channel
END_VAR
VAR_IN_OUT
  ioDINT1 : DINT ;	
  ioDINT2 : DINT ;	
  ioDINT3 : DINT ;	
  ioDINT4 : DINT ;	
END_VAR
BEGIN
NETWORK
TITLE =

      UN    #ENABLE; // keine Freigabe, dann 0 ausgeben
      SPB   OFF; 

      L     #dValue; 

      U     #CH1; 
      SPB   CH1; 
      U     #CH2; 
      SPB   CH2; 
      U     #CH3; 
      SPB   CH3; 
      U     #CH4; 
      SPB   CH4; 

      SPA   OFF; 

CH1:  T     #ioDINT1; 
      L     1; // Wert für Kanalanzeige
      SPA   SAVE; 

CH2:  T     #ioDINT2; 
      L     2; 
      SPA   SAVE; 

CH3:  T     #ioDINT3; 
      L     3; 
      SPA   SAVE; 

CH4:  T     #ioDINT4; 
      L     4; 
      SPA   SAVE; 

OFF:  L     0; 
      CLR   ; // EN0-Ausgang =0, da Stopp

SAVE: SAVE  ; 
      T     #DSP_CHANNEL; // Anzeige aktiver Kanal

END_FUNCTION

FUNCTION "m7b_RAMP_UpDwn_DINT" : VOID
TITLE =RAMP Up/Down INT
//Pro Aufruf des FC wird iUP addiert bzw. iDOWN abgezogen
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 11/2012
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME      AENDERUNG
//--------------------------------------------------------------------------------
//17.04.2020   S.Maag    in Library aufgenommen
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  dVALUE : DINT ;	
  dUP : DINT ;	
  dDOWN : DINT ;	
  TAKT : BOOL ;	
  RESET : BOOL ;	
END_VAR
VAR_IN_OUT
  memVAL : DINT ;	
END_VAR
BEGIN
NETWORK
TITLE =

      SET   ; 
      SAVE  ; 
      CLR   ; 
NETWORK
TITLE =Reset

      UN    #RESET; 
      SPB   ne1; 
      L     #dVALUE; 
      T     #memVAL; 
      BEA   ; 

ne1:  UN    #TAKT; 
      BEB   ; 

NETWORK
TITLE =Rampe maximal up/down to iValue

      L     #dVALUE; 
      L     #memVAL; 
      >D    ; 
      SPB   up; 
      <D    ; 
      SPB   dwn; 
      BEA   ; 

up:   L     #memVAL; 
      L     #dUP; 
      +D    ; 
      L     #dVALUE; 
      >D    ; 
      SPB   save; 
      TAK   ; 
      SPA   save; 

dwn:  L     #memVAL; 
      L     #dDOWN; 
      -D    ; 
      L     #dVALUE; 
      <D    ; 
      SPB   save; 
      TAK   ; 

save: T     #memVAL; 

END_FUNCTION

FUNCTION "m7b_MIN_MAX_TEST_DINT" : VOID
TITLE =Test Wert auf <Min, >Max oder o.k.
//Vergleicht Wert mit Grenzen und gibt aus, wo wert liegt
//<Min, zwischen Min&Max; >Max
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 09/2013
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE: 14.03.2020 in Library aufgenommen
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  VALUE : DINT ;	//Zu prüfender Wert
  MIN : DINT ;	//Zulässiger Minimalwert
  MAX : DINT ;	//Zulässiger Maximalwert
END_VAR
VAR_OUTPUT
  MSG_MIN : BOOL ;	//VALUE < MIN
  MSG_OK : BOOL ;	//MIN <= VALUE <= MAX
  MSG_MAX : BOOL ;	//VALUE > MAX
END_VAR
BEGIN
NETWORK
TITLE =ENO := TRUE

      SET   ; 
      SAVE  ; 
      CLR   ; 

NETWORK
TITLE =

      L     #VALUE; 
      L     #MIN; 
      <R    ; 
      =     #MSG_MIN; 
      TAK   ; 
      L     #MAX; 
      >R    ; 
      =     #MSG_MAX; 

      UN    #MSG_MIN; 
      UN    #MSG_MAX; 
      =     #MSG_OK; 


END_FUNCTION

FUNCTION "m7b_INTEGRATOR_REAL" : VOID
TITLE =Integrator für REAL
//TAKT: Taktgeber 
//
//ENO : Zählimpuls: mit diesem Impuls den I/0-Wert 'rINTEGRAL' kopieren
//      dieser enthält zu diesem Zeitpukt den summierten Wert. Beim
//      nächsten TAKT wird dieser wieder gelöscht.
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 09/2013
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  TAKT : BOOL ;	//Taktgeber: (Flankenauswertung erfolgt im FC)
  RESET : BOOL ;	//RESET: Zähler rücksetzen
  VALUE : REAL ;	//Zu integrierender WERT
  NoOfCounts : DINT ;	//Anzahl zu integrierender Werte
END_VAR
VAR_IN_OUT
  rINTEGRAL : REAL ;	//Integralwert
  dCOUNT : DINT ;	//Zähler
  memByte : BYTE ;	//statisches Hifls-Byte
END_VAR
VAR_TEMP
  lb0_Impuls : BOOL ;	//Lokaler Speicher:  
  lb1_HM_FP_TAKT : BOOL ;	//Lokaler Speicher:  
  lb2 : BOOL ;	//Lokaler Speicher:  
  lb3 : BOOL ;	//Lokaler Speicher:  
  lb4 : BOOL ;	//Lokaler Speicher
  lb5 : BOOL ;	//Lokaler Speicher
  lb6 : BOOL ;	//Lokaler Speicher 
  lb7 : BOOL ;	//Lokaler Speicher
  tmpTAKT : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =statisches Hilfsbyte in temporäre Bits

      L     #memByte; 
      T     LB     0; 
      NOP   0; 

NETWORK
TITLE =Impulsmerker wieder löschen, falls aktiv

      U     #lb0_Impuls; 
      R     #lb0_Impuls; 

NETWORK
TITLE =RESET

      UN    #RESET; 
      SPB   ne4; 

      L     L#0; 
      T     #dCOUNT; 

      L     0.000000e+000; 
      T     #rINTEGRAL; 

ne4:  NOP   0; 
NETWORK
TITLE =Zählen

      U     #TAKT; 
      FP    #lb1_HM_FP_TAKT; 
      =     #tmpTAKT; 

      ON    #tmpTAKT; 
      O     #RESET; 
      SPB   ne5; 

      L     #dCOUNT; // Wenn Anzahl der Zählungen abgelaufen,
      L     #NoOfCounts; // dann Zähler rücksetzen
      <D    ; 
      SPB   weit; 

      L     L#0; // Zähler rücksetzten
      T     #dCOUNT; 
      L     0.000000e+000; 
      T     #rINTEGRAL; 

weit: L     #VALUE; // Zählen
      L     #NoOfCounts; 
      DTR   ; 
      /R    ; 
      L     #rINTEGRAL; 
      +R    ; 
      T     #rINTEGRAL; 

      L     #dCOUNT; // Anzahl Zählungen
      +     1; 
      T     #dCOUNT; 

      L     #NoOfCounts; // Wenn Zählungen erreicht, dann
      >=D   ; // Impuls ausgeben
      S     #lb0_Impuls; 
      SPA   ne5; 

ne5:  NOP   0; 

NETWORK
TITLE =FC-ENO-Ausgang = Zählimpuls

      U     #lb0_Impuls; 
      SAVE  ; 
      CLR   ; 
NETWORK
TITLE =temporäre Bits zurück in statisches Hilfsbyte

      L     LB     0; 
      T     #memByte; 
      NOP   0; 

END_FUNCTION

FUNCTION "m7b_IMPULS_REAL" : VOID
TITLE =Integrator mit Impuls nach Sollwert für REAL
//aufsummieren von Sensorsignalen (z.B.) kW und erzeugen eines Impulses alle
//x kWh.
//Bei z.B. einem Stromzähler der als Analogsignal die aktuelle kW-Zahl liefert,
//am besten im Takt von 1sec und NoOfCounts 3600 aufaddieren. Als Summe werden
//dann kWh geliefert. Mit rSollImpuls (z.B. 100) dann alle 100kWh einen Impuls 
//ausgeben.
//
//ENO : Zählimpuls: mit diesem Impuls den I/0-Wert 'rINTEGRAL' kopieren
//      dieser enthält zu diesem Zeitpukt den summierten Wert. Beim
//      nächsten TAKT wird dieser wieder gelöscht.
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 09/2013
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  TAKT : BOOL ;	//Taktgeber: (Flankenauswertung erfolgt im FC)
  RESET : BOOL ;	//RESET: Zähler rücksetzen
  VALUE : REAL ;	//Zu integrierender WERT
  dNoOfCounts : DINT ;	//Anzahl zu integrierender Werte
  rSollImpuls : REAL ;	//Sollwert: 1 Impuls alle 'rSollImpuls'; Sollwert bei dem 1 Impuls ausgelöst wird
END_VAR
VAR_IN_OUT
  mem_rINTEGRAL : REAL ;	//Integralwert
  memByte : BYTE ;	//statisches Hifls-Byte
END_VAR
VAR_TEMP
  lb0_Impuls : BOOL ;	//Lokaler Speicher:  
  lb1_HM_FP_TAKT : BOOL ;	//Lokaler Speicher:  
  lb2 : BOOL ;	//Lokaler Speicher:  
  lb3 : BOOL ;	//Lokaler Speicher:  
  lb4 : BOOL ;	//Lokaler Speicher
  lb5 : BOOL ;	//Lokaler Speicher
  lb6 : BOOL ;	//Lokaler Speicher 
  lb7 : BOOL ;	//Lokaler Speicher
  tmpTAKT : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =statisches Hilfsbyte in temporäre Bits

      L     #memByte; 
      T     LB     0; 
      NOP   0; 

NETWORK
TITLE =Impulsmerker wieder löschen, falls aktiv

      U     #lb0_Impuls; 
      R     #lb0_Impuls; 

NETWORK
TITLE =RESET

      UN    #RESET; 
      SPB   ne4; 

      L     0.000000e+000; 
      T     #mem_rINTEGRAL; 

ne4:  NOP   0; 
NETWORK
TITLE =Zählen
//Bei Sollwert erreicht wird erst beim nächsten Takt der Integralwert 
//zurückgesetzt, somit kann mit dem IMPULS der aktuelle Integralwert
//für die weitere Verarbeitung noch zur Verfügung gestellt werden.
//
      U     #TAKT; 
      FP    #lb1_HM_FP_TAKT; 
      =     #tmpTAKT; 

      ON    #tmpTAKT; 
      O     #RESET; 
      SPB   ne5; 

      L     #mem_rINTEGRAL; 
      L     #rSollImpuls; 
      <R    ; 
      SPB   weit; 

      L     #mem_rINTEGRAL; // Sollwert von Integral abziehen,
      L     #rSollImpuls; // wenn Sollwert erreicht war
      -R    ; 
      T     #mem_rINTEGRAL; 

weit: L     #VALUE; // Zählen
      L     #dNoOfCounts; 
      DTR   ; 
      /R    ; 
      L     #mem_rINTEGRAL; 
      +R    ; 
      T     #mem_rINTEGRAL; 
      L     #rSollImpuls; 
      >=R   ; 
      S     #lb0_Impuls; // Impuls Sollwert erreicht
      SPA   ne5; 

ne5:  NOP   0; 

NETWORK
TITLE =FC-ENO-Ausgang = Zählimpuls

      U     #lb0_Impuls; 
      SAVE  ; 
      CLR   ; 
NETWORK
TITLE =temporäre Bits zurück in statisches Hilfsbyte

      L     LB     0; 
      T     #memByte; 
      NOP   0; 

END_FUNCTION

FUNCTION "m7b_TOL_HYS_REAL" : VOID
TITLE =Position mit Toleranzen und Hysteres prüfen [REAL]
//Anwendung:
//Toleranzprüfungen bei welchen das ok-Signal erst bei überschreiten
//einer größeren Toleranz wieder gelöscht werden soll
//
//z.B. Positionieranwendungen: nachpositionieren erst wenn Hysterseschwelle
//der Toleranz überschritten ist
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 01/2015
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  IST : DINT ;	//Istwert Achse
  SOLL : DINT ;	//Sollwert
  TOL : DINT ;	//Toleranz Posiitionierung Achse Stop
  HYS : DINT ;	//Hysterese, Position nicht mehr o.k.
END_VAR
VAR_IN_OUT
  io_OK : BOOL ;	
END_VAR
VAR_TEMP
  TOL_HYS : DINT ;	
  TOL_1_OK : BOOL ;	
  TOL_2_OK : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =Position mit Toleranzen und Hysterese prüfen

      L     #TOL; // Toleranz
      L     #HYS; // Hysteres
      +R    ; 
      T     #TOL_HYS; // Toleranz, Hystereseschwelle

      L     #SOLL; // aktuelle Sollposition
      L     #IST; // aktuelle Istposition
      -R    ; // Positionierdifferenz
      SPP   PLUS; 
      NEGR  ; // nach positiv

PLUS: L     #TOL; // Toleranz für Position ok
      <=R   ; 
      S     #io_OK; // Ausgang Position ok
      TAK   ; // Positionsdifferenz in AKKU1
      L     #TOL_HYS; // Toleranz für Positionierung
      >R    ; 
      R     #io_OK; // Ausgang Position ok

      U     #io_OK; 
      SAVE  ; 
      CLR   ; 


END_FUNCTION

FUNCTION "m7b_AVG_MIN_MAX_4xREAL" : VOID
TITLE =MIN, MAX, AVERAGE from activated channels (CH1,CH2,CH3,CH4)
//Give back the minimum, maximum and average value of 4 values (channels)
//
//INPUT:
//rCH1      : value channel 1
//rCH2      : value channel 2
//rCH3      : value channel 3
//rCH4      : value channel 4
//rCH_OFF   : value is all channels are deactivated (OFF) 
//
//CH1_active: FLASE: channel is deactivated (not included in calcuation)
//.           TRUE : channel is activated (included in calculation)
//. 
//CH4_active:
//
//---------------------------------------------------------
//OUTPUT:
//AVG       : AVERAGE(CH1,CH2,CH3,CH4) or CH_off if all channels deactivated
//MIN       : MINIMUM(CH1,CH2,CH3,CH4) or CH_off if all channels deactivated
//MAX       : MAXIMUM(CH1,CH2,CH3,CH4) or CH_off if all channels deactivated
//NoCH_min  : Channel No. of minimum value; 0 if all channels deactivated
//NoCH_max  : Channel No. of maximum value; 0 if all channels deactivated
//NoOfActCH : Number of activated channels [0..4]
//FC-ENO    : FALSE: alle channels are disactivated; CH_OFF is selected
//            TRUE : at least 1 channel is activated; Min/Max is selected
//
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 9/2015
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME      AENDERUNG
//--------------------------------------------------------------------------------
//24.09.2015   S.Maag    Function tested i.o.
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  rCH1 : REAL ;	//Value channel 1
  rCH2 : REAL ;	//Value channel 2
  rCH3 : REAL ;	//Value channel 3
  rCH4 : REAL ;	//Value channel 4
  rCH_OFF : REAL ;	//Value if all channels are deactivated
  CH1_active : BOOL ;	//TRUE activates channel l 
  CH2_active : BOOL ;	//TRUE activates channel 2 
  CH3_active : BOOL ;	//TRUE activates channel 3 
  CH4_active : BOOL ;	//TRUE activates channel 4
END_VAR
VAR_OUTPUT
  rAVG : REAL ;	//Average value
  rMIN : REAL ;	//Minimum value
  rMAX : REAL ;	//Maximum value
  iNoCH_min : INT ;	//Channel No of Min Value (1..3) or 0 if all channels are OFF
  iNoCH_max : INT ;	//Channel No of Max Value (1..3) or 0 if all channels are OFF
  iNoOfActCH : INT ;	//Number of activated channel [0..4]
END_VAR
VAR_TEMP
  off : BOOL ;	
  tmpNoOfCHs : INT ;	
  ARY : ARRAY  [1 .. 4 ] OF STRUCT 	
   rVAL : REAL ;	
   iCH : INT ;	
   CHisActive : BOOL ;	
  END_STRUCT ;	
  tmpMin : STRUCT 	
   rVAL : REAL ;	
   iCH : INT ;	
   IsValid : BOOL ;	
  END_STRUCT ;	
  tmpMax : STRUCT 	
   rVAL : REAL ;	
   iCH : INT ;	
   IsValid : BOOL ;	
  END_STRUCT ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =move activated channels to a temp. ARRAY & count active channels
//if a channel is not activated, it's temporary variable will be 0.0
      L     0.000000e+000; // clear temporary channel variables
      T     #ARY[1].rVAL; 
      T     #ARY[2].rVAL; 
      T     #ARY[3].rVAL; 
      T     #ARY[4].rVAL; 

      L     0; // clear the channel no.
      T     #tmpNoOfCHs; 
      T     #ARY[1].iCH; 
      T     #ARY[2].iCH; 
      T     #ARY[3].iCH; 
      T     #ARY[4].iCH; 

      CLR   ; 
      =     #ARY[1].CHisActive; 
      =     #ARY[2].CHisActive; 
      =     #ARY[3].CHisActive; 
      =     #ARY[4].CHisActive; 

      UN    #CH1_active; // copy CH1 if activated
      SPB   chk2; 

      S     #ARY[1].CHisActive; 
      L     #rCH1; 
      T     #ARY[1].rVAL; 
      L     1; 
      T     #ARY[1].iCH; 

      L     #tmpNoOfCHs; 
      INC   1; 
      T     #tmpNoOfCHs; 

chk2: UN    #CH2_active; // copy CH2 if activated
      SPB   chk3; 

      S     #ARY[2].CHisActive; 
      L     #rCH2; 
      T     #ARY[2].rVAL; 
      L     2; 
      T     #ARY[2].iCH; 

      L     #tmpNoOfCHs; 
      INC   1; 
      T     #tmpNoOfCHs; 


chk3: UN    #CH3_active; // copy CH3 if activated
      SPB   chk4; 

      S     #ARY[3].CHisActive; 
      L     #rCH3; 
      T     #ARY[3].rVAL; 
      L     3; 
      T     #ARY[3].iCH; 

      L     #tmpNoOfCHs; 
      INC   1; 
      T     #tmpNoOfCHs; 


chk4: UN    #CH4_active; // copy CH4 if activated
      SPB   ne3; 

      S     #ARY[4].CHisActive; 
      L     #rCH4; 
      T     #ARY[4].rVAL; 
      L     4; 
      T     #ARY[4].iCH; 

      L     #tmpNoOfCHs; 
      INC   1; 
      T     #tmpNoOfCHs; 

ne3:  NOP   0; 
NETWORK
TITLE =Check: all channels OFF

      L     #tmpNoOfCHs; 
      T     #iNoOfActCH; // FC Output: Number of active channels
      L     0; 
      ==I   ; 
      =     #off; 
      NOT   ; 
      SAVE  ; // ENO=FALSE if all channels are deactivated
      CLR   ; 

NETWORK
TITLE =AVAERAGE (CH1, CH2, CH3, CH4)
//calculate the average of CH1..4
      L     #rCH_OFF; // if all channels are deactivated,
      U     #off; // the average value is 0.0
      SPB   sAvg; // save the avarage value

      L     #ARY[1].rVAL; // building the sum of all channels
      L     #ARY[2].rVAL; // if channel is deactivated, tmp_CH-Value is 0.0
      +R    ; 
      L     #ARY[3].rVAL; 
      +R    ; 
      L     #ARY[4].rVAL; 
      +R    ; // = CH1+CH2+CH3+CH4
      L     #tmpNoOfCHs; // number of activated channels
      ITD   ; 
      DTR   ; 
      /R    ; 
sAvg: T     #rAVG; // the AVERAGE value of all activated channels 


NETWORK
TITLE =COPY first Element of ARY to tmpMin and tmpMax
//to start min/max check with first element of CH-Array, the first Array-Element 
//is copied to to the tmpMin and tmpMax structure
      L     #ARY[1].rVAL; 
      T     #tmpMin.rVAL; 
      T     #tmpMax.rVAL; 

      L     #ARY[1].iCH; 
      T     #tmpMin.iCH; 
      T     #tmpMax.iCH; 

      U     #ARY[1].CHisActive; 
      =     #tmpMin.IsValid; 
      =     #tmpMax.IsValid; 

NETWORK
TITLE =Get the MINIMUM value
//     
//
      L     #tmpMin.rVAL; // tempMin.Val
      L     #ARY[2].rVAL; // CH2.Val
      >R    ; // IF CH2.Val < tmpMin
      U     #ARY[2].CHisActive; //    AND CH2.IsActivated
      ON    #tmpMin.IsValid; //    OR  NOT tmpMin.IsValid
      SPBN  mn3; // ELSE continue with CH3

      L     #ARY[2].rVAL; // THEN COPY CH2->tmpMin, because CH2 is the
      T     #tmpMin.rVAL; // act. minimum or tmpMin is not valid

      L     #ARY[2].iCH; 
      T     #tmpMin.iCH; 

      U     #ARY[2].CHisActive; // (if CH2 is not activated
      =     #tmpMin.IsValid; //  then tmpMin is not valid)

mn3:  L     #tmpMin.rVAL; // Channel 3 !see above documentation CH2!
      L     #ARY[3].rVAL; 
      >R    ; 
      U     #ARY[3].CHisActive; 
      ON    #tmpMin.IsValid; 
      SPBN  mn4; 

      L     #ARY[3].rVAL; 
      T     #tmpMin.rVAL; 

      L     #ARY[3].iCH; 
      T     #tmpMin.iCH; 

      U     #ARY[3].CHisActive; 
      =     #tmpMin.IsValid; 

mn4:  L     #tmpMin.rVAL; // Channel 4
      L     #ARY[4].rVAL; 
      >R    ; 
      U     #ARY[4].CHisActive; 
      ON    #tmpMin.IsValid; 
      SPBN  mn5; 

      L     #ARY[4].rVAL; 
      T     #tmpMin.rVAL; 

      L     #ARY[4].iCH; 
      T     #tmpMin.iCH; 

      U     #ARY[4].CHisActive; 
      =     #tmpMin.IsValid; 

mn5:  L     #tmpMin.rVAL; // If tmpMin.Val IsValid
      U     #tmpMin.IsValid; 
      SPB   smin; // THEN copy the min. to FC-Out

      L     0; // ELSE copy 0 to FC-Out
      T     #tmpMin.iCH; 
      L     #rCH_OFF; 

smin: T     #rMIN; // copy the min. to FC-Out
      L     #tmpMin.iCH; // channel no. with minimum
      T     #iNoCH_min; 


NETWORK
TITLE =Get the MAXIUM value

      L     #tmpMax.rVAL; // tempMax.Val
      L     #ARY[2].rVAL; // CH2.Val
      <R    ; // IF CH2.Val > tmpMin
      U     #ARY[2].CHisActive; //    AND CH2.IsActivated
      ON    #tmpMin.IsValid; //    OR NOT tmpMax.IsValid
      SPBN  mx3; // ELSE continue with CH3

      L     #ARY[2].rVAL; // THEN COPY CH2->tmpMax, because CH2 is the
      T     #tmpMax.rVAL; // act. maximum or tmpMax is not valid

      L     #ARY[2].iCH; 
      T     #tmpMax.iCH; 

      U     #ARY[2].CHisActive; // (if CH2 is not activated
      =     #tmpMax.IsValid; //  then tmpMax is not valid)

mx3:  L     #tmpMax.rVAL; // Channel 3 !see above documentation CH2!
      L     #ARY[3].rVAL; 
      <R    ; 
      U     #ARY[3].CHisActive; 
      ON    #tmpMax.IsValid; 
      SPBN  mx4; 

      L     #ARY[3].rVAL; 
      T     #tmpMax.rVAL; 

      L     #ARY[3].iCH; 
      T     #tmpMax.iCH; 

      U     #ARY[3].CHisActive; 
      =     #tmpMax.IsValid; 

mx4:  L     #tmpMax.rVAL; // Channel 4
      L     #ARY[4].rVAL; 
      <R    ; 
      U     #ARY[4].CHisActive; 
      ON    #tmpMax.IsValid; 
      SPBN  mx5; 

      L     #ARY[4].rVAL; 
      T     #tmpMax.rVAL; 

      L     #ARY[4].iCH; 
      T     #tmpMax.iCH; 

      U     #ARY[4].CHisActive; 
      =     #tmpMax.IsValid; 

mx5:  L     #tmpMax.rVAL; // If tmpMax.Val IsValid
      U     #tmpMax.IsValid; 
      SPB   smax; // THEN copy the max to FC-Out

      L     0; // ELSE copy 0 to FC-Out
      T     #tmpMax.iCH; 
      L     #rCH_OFF; 

smax: T     #rMAX; // copy the max. to FC-Out
      L     #tmpMax.iCH; // channel no. with maximum
      T     #iNoCH_max; 


END_FUNCTION

FUNCTION "m7b_Weiche_x4_REAL" : VOID
TITLE =4-fach Weiche REAL 
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2018
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//15.08.2018   S.Maag      enstanden aus Weiche4x_INT
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 2.0


VAR_INPUT
  CH1 : BOOL ;	
  CH2 : BOOL ;	
  CH3 : BOOL ;	
  CH4 : BOOL ;	
  ENABLE : BOOL ;	
  rValue : DINT ;	
END_VAR
VAR_OUTPUT
  DSP_CHANNEL : INT ;	//Displays the activated channel
END_VAR
VAR_IN_OUT
  ioREAL1 : REAL ;	
  ioREAL2 : REAL ;	
  ioREAL3 : REAL ;	
  ioREAL4 : REAL ;	
END_VAR
BEGIN
NETWORK
TITLE =

      UN    #ENABLE; // keine Freigabe, dann 0 ausgeben
      SPB   OFF; 

      L     #rValue; 

      U     #CH1; 
      SPB   CH1; 
      U     #CH2; 
      SPB   CH2; 
      U     #CH3; 
      SPB   CH3; 
      U     #CH4; 
      SPB   CH4; 

      SPA   OFF; 

CH1:  T     #ioREAL1; 
      L     1; // Wert für Kanalanzeige
      SPA   SAVE; 

CH2:  T     #ioREAL2; 
      L     2; 
      SPA   SAVE; 

CH3:  T     #ioREAL3; 
      L     3; 
      SPA   SAVE; 

CH4:  T     #ioREAL4; 
      L     4; 
      SPA   SAVE; 

OFF:  L     0; 
      CLR   ; // EN0-Ausgang =0, da Stopp

SAVE: SAVE  ; 
      T     #DSP_CHANNEL; // Anzeige aktiver Kanal

END_FUNCTION

FUNCTION "m7b_RAMP_UpDwn_REAL" : VOID
TITLE =RAMP Up/Down REAL
//Pro Aufruf des FC wird rUP addiert bzw. rDOWN abgezogen
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 11/2012
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME      AENDERUNG
//--------------------------------------------------------------------------------
//17.04.2020   S.Maag    in Library aufgenommen
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  rVALUE : REAL ;	
  rUP : REAL ;	
  rDOWN : REAL ;	
  TAKT : BOOL ;	
  RESET : BOOL ;	
END_VAR
VAR_IN_OUT
  memVAL : REAL ;	
END_VAR
BEGIN
NETWORK
TITLE =

      SET   ; 
      SAVE  ; 
      CLR   ; 
NETWORK
TITLE =Reset

      UN    #RESET; 
      SPB   ne1; 
      L     #rVALUE; 
      T     #memVAL; 
      BEA   ; 

ne1:  UN    #TAKT; 
      BEB   ; 

NETWORK
TITLE =Rampe maximal up/down to rValue

      L     #rVALUE; 
      L     #memVAL; 
      >R    ; 
      SPB   up; 
      <R    ; 
      SPB   dwn; 
      BEA   ; 

up:   L     #memVAL; 
      L     #rUP; 
      +R    ; 
      L     #rVALUE; 
      >R    ; 
      SPB   save; 
      TAK   ; 
      SPA   save; 

dwn:  L     #memVAL; 
      L     #rDOWN; 
      -R    ; 
      L     #rVALUE; 
      <R    ; 
      SPB   save; 
      TAK   ; 

save: T     #memVAL; 

END_FUNCTION

FUNCTION "m7b_RoundReal" : REAL
TITLE =Round a REAL to No of digits / Runden auf Anzahl Kommastellen
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 3/2017
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  rIN : REAL ;	//REAL Value to round
  iNoOfDigits : INT ;	//No of digits after the dot / Nachkommastellen
END_VAR
BEGIN
NETWORK
TITLE =
//How to round a REAL to No of digits after the komma.
//
//ROUNDED_REAL = DINT_TO_REAL (REAL_TO_DINT (IN_REAL * Factor)) / Factor
//Factor for 1 digit = 10, for 2 digits = 100 ...
//
//1. Create a factor from No of digits 
//   
//   Digits  Factor
//      0             1
//      1            10
//      2           100
//      3         1.000
//      4        10.000
//      5       100.000  This is the possible maximum
//                       because S7-REAL has 6 digits max.
//
//   We start with creating the factor as BCD No, so we have to shift left
//   the BCD No '1' iNoOfDigits
//   Each BCD No has 4 Btis, so we have to Shift Bits := iNoOfDigits * 4
//  
//      L     #iNoOfDigits                // No. of digits after komma
//      SLW   2                           // *4 Bits per BCD No.
//      L     1                           // Load a BCD 1 to Akku 
//      SLD           
//
//After this we get a BCD No:  1/10/100/1000 ...
//
//Wit BTD we convert this to a INT, with DTR to our REAL Factor for digits
//
//2. We cut unneeded digits 
//   IN_REAL * Factor
//   REAL_TO_DINT        // cut the unneeded digits
//   DINT_TO_REAL        // back to REAL
//   / Factor
//   = Rounded REAL
      L     #iNoOfDigits; // No. of digits after komma
      L     5; // maximum of possible digits
      >I    ; 
      SPB   err; // If iNoOfDigits >5 THEN err
      TAK   ; 
      L     0; // If iNoOfDigits <0 THEN err
      <I    ; 
      SPB   err; 
      SPA   do; 

err:  L     #rIN; // IF err THEN  RET_VAL = rIN
      SPA   save; 

do:   L     #iNoOfDigits; // No. of digits after komma
      SLW   2; // *4 Bits per BCD No.
      L     1; // Load a BCD 1 to Akku 
      SLD   ; // Shift the BCD '1' No of digits left 
      BTD   ; // convert the BCD 1/10/100/1000 ... to INT := 10 EXP iKomma
      DTR   ; // convert Factor  1/10/100/1000 to REAL
      PUSH  ; // Fill AKKU 2/3 with Factor
      PUSH  ; // it's because of automatic POP at 4 Akku CPU's
      L     #rIN; // Load the IN_REAL VALUE
      *R    ; // = IN_REAL * DigitFactor (1/10/100/1000 ...)
      RND   ; // Round to DINT
      DTR   ; // DINT_TO_REAL (=> without komma)
      TAK   ; // Factor back to AKKU 1, Rounded (Value*Factor) to AKKU 2
      /R    ; // = (RoundedValue * Factor) / Factor
save: T     #RET_VAL; // Result rounded to no of digits after komma

      SET   ; 
      SAVE  ; 


END_FUNCTION

FUNCTION "m7b_MinMax_2xREAL" : REAL
TITLE =Select min. or. max of 2 REAL values
//Select the minimum or maximum of 2 REAL values.
//
//INPUT:
//rCH1      : value channel 1
//rCH2      : value channel 2
//cfgMinMax : FALSE: select the min: MIN(CH1,CH2)
//            TRUE : select the max: MAX(CH1,CH2)
//---------------------------------------------------------
//OUTPUT:
//RET_VAL   : the selected value min or max., depending on cfgMinMax 
//ENO       : FALSE = CH1 is selected
//            TRUE  = CH2 is selected
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 09/2015
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE: 
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  rCH1 : REAL ;	//Value channel 1
  rCH2 : REAL ;	//Value channel 2
  cfgMinMax : BOOL ;	//FALSE: select min. value; TRUE: select max. Value
END_VAR
BEGIN
NETWORK
TITLE =

      U     #cfgMinMax; 
      SPB   MAX; 
      SPA   MIN; 

NETWORK
TITLE =Select max (greater vlaue)

MAX:  L     #rCH1; 
      L     #rCH2; 
      <R    ; // TRUE if CH1<CH2 := CH2 is max
      SAVE  ; // ENO (BIE) = TRUE if CH2 selected
      SPB   SAVE; 
      TAK   ; 
      SPA   SAVE; 

NETWORK
TITLE =Select min (lower vlaue)

MIN:  L     #rCH1; 
      L     #rCH2; 
      >R    ; // TRUE if CH1>CH2 := CH2 is min
      SAVE  ; // ENO (BIE) = TRUE if CH2 selected
      SPB   SAVE; 
      TAK   ; 
      SPA   SAVE; 

NETWORK
TITLE =

SAVE: T     #RET_VAL; // Return the selected value

END_FUNCTION

FUNCTION "m7b_MIN_MAX_TEST_REAL" : VOID
TITLE =Test Wert auf <Min, >Max oder o.k.
//Vergleicht Wert mit Grenzen und gibt aus, wo wert liegt
//<Min, zwischen Min&Max; >Max
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 09/2013
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE: 
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  VALUE : REAL ;	//Zu prüfender Wert
  MIN : REAL ;	//Zulässiger Minimalwert
  MAX : REAL ;	//Zulässiger Maximalwert
END_VAR
VAR_OUTPUT
  MSG_MIN : BOOL ;	//VALUE < MIN
  MSG_OK : BOOL ;	//MIN <= VALUE <= MAX
  MSG_MAX : BOOL ;	//VALUE > MAX
END_VAR
BEGIN
NETWORK
TITLE =ENO := TRUE

      SET   ; 
      SAVE  ; 
      CLR   ; 

NETWORK
TITLE =

      L     #VALUE; 
      L     #MIN; 
      <R    ; 
      =     #MSG_MIN; 
      TAK   ; 
      L     #MAX; 
      >R    ; 
      =     #MSG_MAX; 

      UN    #MSG_MIN; 
      UN    #MSG_MAX; 
      =     #MSG_OK; 


END_FUNCTION

FUNCTION "m7b_DampingReal" : VOID
TITLE =Damping of a REAL value
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 9/2015
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//28.11.2017   S.Maag        Fehlerabragen SPU err hinzugefügt, da es 
//                           bei ungültigen Gleitpunktzahlen zu einem 
//                           Dauerhaften Fehler kommt, der sich selbst nicht
//                           mehr korrigiert, da die Rechnung abgebrochen wird.
//                           Das ist ein sehr seltens Phänomen und konnte nicht
//                           ganz nachvollzogen werden warum das passiert.
//                           in der Gleitpunktzahl steht dann der HEX-WERT
//                           DW#16#7FC0 0000
//                           Aufgetaucht ist dies nach einem Sensordefekt und
//                           Sensorwechsel (Wiegezelle)
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  rVALUE : REAL ;	
  rising_edge_1s : BOOL ;	
  rDampingFactor : REAL ;	
END_VAR
VAR_IN_OUT
  IO_VALUE_DAMP : REAL ;	
END_VAR
VAR_TEMP
  rDamping : REAL ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =Dämpfung des Sensorwertes 
//Durch das aufaddieren eines Teils der Differenz zum aktuellen Analogwert
//läuft der gedämpfte Wert dem Analogwert immer etwas hinterher. Es ergibt sich 
//ein exponentieller Nachlauf (vgl. Kondensator Ladekurve) bei einem 
//Dämpfungsfaktor von 2 erhält man nach 5 Impulsen ca. 96.9%, nach 7 Impulsen ca. 
//99.2% Sensorwertes. Je höher der Dämpfungsfaktor, desto langsamer läuft der 
//Wert hinterher.
//
      UN    #rising_edge_1s; 
      SPB   ne6; 

      L     #rDampingFactor; // sicherstellen, dass
      L     1.000000e+000; // Dämpfungsfaktor >=1.0
      <R    ; 
      SPB   sav; 
      TAK   ; 
sav:  T     #rDamping; 

      L     #rVALUE; 
      L     #IO_VALUE_DAMP; 
      -R    ; 
      SPU   err; // Wenn Fehler, z.B. ungültige Gleitpunktzahl
      L     #rDamping; 
      /R    ; 
      SPU   err; // Wenn Fehler, z.B. ungültige Gleitpunktzahl
      L     #IO_VALUE_DAMP; 
      +R    ; 
      SPU   err; // Wenn Fehler, z.B. ungültige Gleitpunktzahl
      T     #IO_VALUE_DAMP; 
      BEA   ; 

err:  L     #rVALUE; // Wenn Fehler, dann Eingangswert direkt
      T     #IO_VALUE_DAMP; // durchschleusen
ne6:  NOP   0; 
END_FUNCTION

FUNCTION "m7b_PE_to_DB" : VOID
TITLE =PE_to_DB: kopiert einen Peripherie Eingangsbereich in DB
//Kopiert eine Anzahl von Bytes PE zu DB. Die Kopierroutine arbeitet sehr 
//effektiv, da die Werte nicht als einzelne Bytes sondern 
//als 32-Bit-Werte kopiert werden. 
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 11/2011
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  ADR_PE : INT ;	//Start Adresse Peripherie Eingangsbereich
  DB_NR : BLOCK_DB ;	//DB
  DB_ADR : INT ;	//Byteadresse im DB
  BYTES : INT ;	//Number of Bytes to copy
END_VAR
VAR_TEMP
  QUELL_ADR : DINT ;	
  ZIEL_ADR : DINT ;	
  AR1 : DINT ;	
  AR2 : DINT ;	
END_VAR
BEGIN
NETWORK
TITLE =Register sichern

      SET   ; 
      SAVE  ; 
      CLR   ; 

NETWORK
TITLE =Register sichern

      TAR1  #AR1; // Adressregister 1 sichern
      TAR2  #AR2; // Adressregister 2 sichern

NETWORK
TITLE =Adressen für Quell und Ziel-DW als Pointer in Adressregister

      L     #ADR_PE; // Quelladresse-PE 
      SLD   3; // als Pointer
      L     P#0.0; // 0-Pointer addieren, damit
      +D    ; // Kennungsbits für Pointer gesetzt werden
      LAR1  ; // ins Adressregister 1

      L     #DB_ADR; // Zieldatenwort-Nr
      SLD   3; // als Pointer 
      L     P#0.0; 
      +D    ; 
      LAR2  ; // ins Adressregister 2
NETWORK
TITLE =Daten kopieren

      AUF   #DB_NR; // Ziel-DB als Global-DB öffnen

      L     #BYTES; // Anzahl der zu kopierenden Bytes 
      SRW   2; // in Anzahl der 32-Bit-Werte umrechen
LOOP: L     PED [AR1,P#0.0]; // Quell: PED lesen
      T     DBD [AR2,P#0.0]; // Ziel-Daten schreiben
      +AR1  P#4.0; // Quell-Pointer in AR1 um 4 Bytes erhöhen
      +AR2  P#4.0; // Ziel-Pointer in AR2 um 4 Bytes erhöhen
      TAK   ; // Schleifenzähler wieder in Akku 1 zurück
      LOOP  LOOP; // Schleifenzähler bearbeiten

      L     #BYTES; // nun noch prüfen ob noch ein 16-Bit-Wert kopiert werden muss
      SRW   2; // LSB von Anzahl wird in Ergebnisvorzeichenregister geschoben
      SPZ   BYT; // prüft somit, ob LSB von ANZAHL = 1 ist
      L     PEW [AR1,P#0.0]; // Dann muss das letze DW noch kopiert werden
      T     DBW [AR2,P#0.0]; 
      +AR1  P#2.0; // Quell-Pointer in AR1 um 4 Bytes erhöhen
      +AR2  P#2.0; // Ziel-Pointer in AR2 um 4 Bytes erhöhen

BYT:  L     #BYTES; // nun noch prüfen ob noch ein 8-Bit-Wert kopiert werden muss
      SRW   1; // LSB von Anzahl wird in Ergebnisvorzeichenregister geschoben
      SPZ   END; // prüft somit, ob LSB von ANZAHL = 1 ist
      L     PEB [AR1,P#0.0]; // Dann muss das letze Byte noch kopiert werden
      T     DBB [AR2,P#0.0]; 
END:  NOP   0; 

NETWORK
TITLE =Registerinhalte wieder herstellen

      LAR1  #AR1; // Adressregister 1 wieder herstellen
      LAR2  #AR2; // Adressregister 2 wieder herstellen
END_FUNCTION

FUNCTION "m7b_DB_to_PA" : VOID
TITLE =DB_to_PA: kopiert Daten von einem DB zu PeripherieAusgängen
//Kopiert eine Anzahl von Bytes von DB zu PA
//Die Kopierroutine arbeitet sehr effektiv, da die Werte nicht als einzelne Bytes 
//sondern als 32-Bit-Werte kopiert werden. 
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 11/2011
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  ADR_PA : INT ;	//Anfangs-Adresse Peripherie Ausgangsblock
  DB_Nr : BLOCK_DB ;	//DB
  DB_ADR : INT ;	//Byte Adresse im DB
  BYTES : INT ;	//Number of bytes
END_VAR
VAR_TEMP
  QUELL_ADR : DINT ;	
  ZIEL_ADR : DINT ;	
  AR1 : DINT ;	
  AR2 : DINT ;	
END_VAR
BEGIN
NETWORK
TITLE =Register sichern

      SET   ; 
      SAVE  ; 
      CLR   ; 

NETWORK
TITLE =Register sichern

      TAR1  #AR1; // Adressregister 1 sichern
      TAR2  #AR2; // Adressregister 2 sichern

NETWORK
TITLE =Adressen für Quelle und Ziel als Pointer in Adressregister

      L     #DB_ADR; // Quelladresse Datenwort-Nr
      SLD   3; // als Pointer 
      L     P#0.0; 
      +D    ; 
      LAR1  ; // ins Adressregister 1

      L     #ADR_PA; // Zieladresse PA
      SLD   3; // als Pointer
      L     P#0.0; // 0-Pointer addieren, damit
      +D    ; // Kennungsbits für Pointer gesetzt werden
      LAR2  ; // ins Adressregister 2
NETWORK
TITLE =Daten kopieren

      AUF   #DB_Nr; // Ziel-DB als Global-DB öffnen

      L     #BYTES; // Anzahl der zu kopierenden Bytes 
      SRW   2; // in Anzahl der 32-Bit-Werte umrechen
LOOP: L     DBD [AR1,P#0.0]; // Quell: DBD lesen
      T     PAD [AR2,P#0.0]; // Ziel PAD speichern
      +AR1  P#4.0; // Quell-Pointer in AR1 um 4 Bytes erhöhen
      +AR2  P#4.0; // Ziel-Pointer in AR2 um 4 Bytes erhöhen
      TAK   ; // Schleifenzähler wieder in Akku 1 zurück
      LOOP  LOOP; // Schleifenzähler bearbeiten

      L     #BYTES; // nun noch prüfen ob noch ein 16-Bit-Wert kopiert werden muss
      SRW   2; // LSB von Anzahl wird in Ergebnisvorzeichenregister geschoben
      SPZ   BYT; // prüft somit, ob LSB von ANZAHL = 1 ist
      L     DBW [AR1,P#0.0]; // Dann muss das letze DW noch kopiert werden
      T     PAW [AR2,P#0.0]; 
      +AR1  P#2.0; // Quell-Pointer in AR1 um 4 Bytes erhöhen
      +AR2  P#2.0; // Ziel-Pointer in AR2 um 4 Bytes erhöhen

BYT:  L     #BYTES; // nun noch prüfen ob noch ein 8-Bit-Wert kopiert werden muss
      SRW   1; // LSB von Anzahl wird in Ergebnisvorzeichenregister geschoben
      SPZ   END; // prüft somit, ob LSB von ANZAHL = 1 ist
      L     DBB [AR1,P#0.0]; // Dann muss das letze Byte noch kopiert werden
      T     PAB [AR2,P#0.0]; 
END:  NOP   0; 

NETWORK
TITLE =Registerinhalte wieder herstellen

      LAR1  #AR1; // Adressregister 1 wieder herstellen
      LAR2  #AR2; // Adressregister 2 wieder herstellen
END_FUNCTION

FUNCTION "m7b_BitToANY" : ANY
TITLE =BitToANY: 2x ANY Multiplexer
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//01.04.2020   S.Maag      von 2xAnyMultiPlexer nach BitToANY umbenannt, da
//                         kein echter Multiplexer, sondern ähnlich wie
//                         die Funktionen BitToDINT, BitToReal, eine 
//                         Einfachauswahl. Dazu ebenfalls die Auswahleingänge
//                         S1/S2 gegen nur einen Eingang BIT ersetzt.
//                         D.h. es gibt nur eine Entweder Oder Auswahl.
//                         Grund: Würde bei S1/S2 nichts ausgewählt, dann
//                         würden willkührliche Daten als RET_VAL zurückgegeben.
//                         Beim 3x/4xAnyMultiplexer wurde dies mit eiem temp.
//                         NullAny behoben. Bei 2-fach macht das aber keinen
//                         Sinn. Hier ist die bessere Lösung eine Muss-Auswahl.
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  BIT : BOOL ;	
  ANY0 : ANY ;	//ANY Pointer 0
  ANY1 : ANY ;	//ANY Pointer 1
END_VAR
BEGIN
NETWORK
TITLE =
//It isn't recomended to restore AR2, it will be done automatically by the 
//systems CALL operation, when leaving the Function
      U     #BIT; // Select No. 1
      SAVE  ; 
      SPB   HIGH; 
      L     P##ANY0; // Load the Pointer of ANY 0
      SPA   SAVE; 
HIGH: L     P##ANY1; // Load the Pointer of ANY 1
SAVE: LAR1  ; // Load the Pointer of the Source Any into AR1
      L     P##RET_VAL; // Load the Pointer of the ReturnValue into
      LAR2  ; // AR2

      L     D [AR1,P#0.0]; // Copy the 10 Bytes of the ANY Pointer to
      T     D [AR2,P#0.0]; // the returned ANY

      L     D [AR1,P#4.0]; 
      T     D [AR2,P#4.0]; 

      L     W [AR1,P#8.0]; 
      T     W [AR2,P#8.0]; 


END_FUNCTION

FUNCTION "m7b_MUXx3xANY" : ANY
TITLE =3x ANY Multiplexer
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//01.04.2020   S.Maag      Anzeige aktiver Kanal (DSP_CHANNEL)
//                         RETURN NullAny, wenn kein Kanal ausgewählt
//                         ENABLE wie bei WerteMultiplexern hinzugefügt
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  S1 : BOOL ;	//Select no. 1
  S2 : BOOL ;	//Select no. 2
  S3 : BOOL ;	//Select no. 3
  ENABLE : BOOL ;	//If not Enabled: RET_VAL:=NullAny
  ANY1 : ANY ;	//ANY Pointer 1
  ANY2 : ANY ;	//ANY Pointer 3
  ANY3 : ANY ;	//ANY Pointer 3
END_VAR
VAR_OUTPUT
  DSP_CHANNEL : INT ;	//Displays the activated channel
END_VAR
VAR_TEMP
  anyNull : ANY ;	
END_VAR
BEGIN
NETWORK
TITLE =
//It isn't recomended to restore AR1 & AR2, it will be done automatically by the 
//systems CALL operation, when leaving the Function
      UN    #ENABLE; // keine Freigabe, dann 0 ausgeben
      SPB   OFF; 

      U     #S1; // Select No. 1
      SPB   S1; 
      U     #S2; // Select No. 2
      SPB   S2; 
      U     #S3; // Select No. 3
      SPB   S3; 
      SPA   OFF; 

S1:   L     P##ANY1; // Load the Pointer of ANY 1
      L     1; // Wert für Kanalanzeige
      SPA   SAVE; 
S2:   L     P##ANY2; // Load the Pointer of ANY 2
      L     2; 
      SPA   SAVE; 
S3:   L     P##ANY3; // Load the Pointer of ANY 3
      L     3; 
      SPA   SAVE; 

OFF:  L     P##anyNull; // Create a temporary
      LAR1  ; // NullAny
      L     DW#16#0; 
      T     D [AR1,P#0.0]; 
      T     D [AR1,P#4.0]; 
      T     W [AR1,P#8.0]; 

      L     P##anyNull; // Load Pointer to temporary NullAny
      L     0; 
      CLR   ; // CLR BIE

SAVE: SAVE  ; // FC-ENO: TRUE IF ChannelSelected
      T     #DSP_CHANNEL; // Anzeige aktiver Kanal
      TAK   ; // P##ANY in AKKU1 zurück
      LAR1  ; // Load the Pointer of the Source Any into AR1
      L     P##RET_VAL; // Load the Pointer of the ReturnValue into
      LAR2  ; // AR2

      L     D [AR1,P#0.0]; // Copy the 10 Bytes of the ANY Pointer to
      T     D [AR2,P#0.0]; // the returned ANY

      L     D [AR1,P#4.0]; 
      T     D [AR2,P#4.0]; 

      L     W [AR1,P#8.0]; 
      T     W [AR2,P#8.0]; 


END_FUNCTION

FUNCTION "m7b_MUXx4xANY" : ANY
TITLE =4x ANY Multiplexer
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//01.04.2020   S.Maag      Anzeige aktiver Kanal (DSP_CHANNEL).
//                         RETURN NullAny, wenn kein Kanal ausgewählt
//                         ENABLE wie bei WerteMultiplexern 
//hinzugefügt---------------------------------------------------------------------
//-----------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  S1 : BOOL ;	//Select no. 1
  S2 : BOOL ;	//Select no. 2
  S3 : BOOL ;	//Select no. 3
  S4 : BOOL ;	//Select no. 4
  ENABLE : BOOL ;	//If not Enabled: RET_VAL:=NullAny
  ANY1 : ANY ;	//ANY Pointer 1
  ANY2 : ANY ;	//ANY Pointer 3
  ANY3 : ANY ;	//ANY Pointer 3
  ANY4 : ANY ;	//ANY Pointer 4
END_VAR
VAR_OUTPUT
  DSP_CHANNEL : INT ;	//Displays the activated channel
END_VAR
VAR_TEMP
  anyNull : ANY ;	
END_VAR
BEGIN
NETWORK
TITLE =
//It isn't recomended to restore AR1 & AR2, it will be done automatically by the 
//systems CALL operation, when leaving the Function
      UN    #ENABLE; // keine Freigabe, dann 0 ausgeben
      SPB   OFF; 

      U     #S1; // Select No. 1
      SPB   S1; 
      U     #S2; // Select No. 2
      SPB   S2; 
      U     #S3; // Select No. 3
      SPB   S3; 
      U     #S4; // Select No. 4
      SPB   S4; 
      SPA   OFF; 

S1:   L     P##ANY1; // Load the Pointer of ANY 1
      L     1; // Wert für Kanalanzeige
      SPA   SAVE; 
S2:   L     P##ANY2; // Load the Pointer of ANY 2
      L     2; 
      SPA   SAVE; 
S3:   L     P##ANY3; // Load the Pointer of ANY 3
      L     3; 
      SPA   SAVE; 
S4:   L     P##ANY4; // Load the Pointer of ANY 4
      L     4; 
      SPA   SAVE; 

OFF:  L     P##anyNull; // Create a temporary
      LAR1  ; // NullAny
      L     DW#16#0; 
      T     D [AR1,P#0.0]; 
      T     D [AR1,P#4.0]; 
      T     W [AR1,P#8.0]; 

      L     P##anyNull; // Load Pointer to temporary NullAny
      L     0; 
      CLR   ; // CLR BIE

SAVE: SAVE  ; // FC-ENO: TRUE IF ChannelSelected
      T     #DSP_CHANNEL; // Anzeige aktiver Kanal
      TAK   ; // P##ANY in AKKU1 zurück
      LAR1  ; // Load the Pointer of the Source Any into AR1
      L     P##RET_VAL; // Load the Pointer of the ReturnValue into
      LAR2  ; // AR2

      L     D [AR1,P#0.0]; // Copy the 10 Bytes of the ANY Pointer to
      T     D [AR2,P#0.0]; // the returned ANY

      L     D [AR1,P#4.0]; 
      T     D [AR2,P#4.0]; 

      L     W [AR1,P#8.0]; 
      T     W [AR2,P#8.0]; 


END_FUNCTION

FUNCTION "m7b_DB_COMPARE_ByRef" : VOID
TITLE =DB_COMPARE_ByRef
//Vergleicht Anzahl Bytes von 2 Datenbausteinen
//Die Vergleichsroutine arbeitet sehr effektiv, da die Werte nicht als 8-Bit 
//sondern als 32-Bit-Werte verglichen werden. Weiterhin müssen die DBs nur einmal 
//geöffnet werden, dies erreicht man, indem man einen DB als Global-DB und den 
//anderen als Instanz-DB öffnet.
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2010
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//19.10.2010   S.Maag      Basiert auf FC2 CopyDBW_ByRef
//25.10.2010   S.Maag      Wenn keine Einzelbytes mehr zu kopieren sind, dann
//                         darf man nicht zu END springen sondern zu EQ (Daten 
//                         gleich)
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  SOURCE : BLOCK_DB ;	
  DEST : BLOCK_DB ;	
  SOURCE_BYTE : INT ;	
  DEST_Byte : INT ;	
  NoOfBytes : INT ;	
END_VAR
VAR_TEMP
  QUELL_ADR : DINT ;	
  ZIEL_ADR : DINT ;	
  AR1 : DINT ;	
  LOOPS : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =Register sichern
//Adressregister 2 Global- und Instanz DB werden bei CALL-Aufrufen automatisch 
//vom System gesichert, bei UC nicht!
      TAR1  #AR1; // Adressregister 1 sichern

NETWORK
TITLE =Adressen für Quell und Ziel-DW als Pointer in Adressregister

      L     #SOURCE_BYTE; // Quelldatenbyte Nr.
      SLD   3; // als Pointer
      L     P#0.0; // 0-Pointer addieren, damit
      +D    ; // Kennungsbits für Pointer gesetzt werden
      LAR1  ; // ins Adressregister 1

      L     #DEST_Byte; // ZieldatenByte-Nr
      SLD   3; // als Pointer 
      L     P#0.0; 
      +D    ; 
      LAR2  ; // ins Adressregister 2
NETWORK
TITLE =Daten vergleichen

      AUF   #SOURCE; // Quell-DB als Global-DB öffnen
      TDB   ; // Global und Instanz-DB tauschen (Quelle wird Instanz-DB)
      AUF   #DEST; // Ziel-DB als Global-DB öffnen

      L     #NoOfBytes; // Anzahl der zu kopierenden Bytes
      L     4; // in Anzahl der 32-Bit-Werte umrechen
      /I    ; 
      SPZ   LAST; // Wenn 0 32-Bit Werte, dann weiter mit letzten 3 Bytes 
LOOP: T     #LOOPS; 
      L     DID [AR1,P#0.0]; // QuellDaten lesen
      L     DBD [AR2,P#0.0]; // VergleichsDaten lesen
      <>D   ; // wenn nicht gleich, dann Ende
      SPB   NEQ; 
      +AR1  P#4.0; // Quell-Pointer in AR1 um 4 Bytes erhöhen
      +AR2  P#4.0; // Ziel-Pointer in AR2 um 4 Bytes erhöhen
      L     #LOOPS; // Schleifenzähler wieder in Akku 1 zurück
      LOOP  LOOP; // Schleifenzähler bearbeiten

LAST: L     #NoOfBytes; // nun noch die evtl. letzte 3 Bytes prüfen
      L     2#11; // Anzahl übriger Bytes maskieren
      UW    ; // Anzahl übriger Bytes
      SPZ   EQ; // Wenn 0 dann ENDE
LOP1: T     #LOOPS; 
      L     DIB [AR1,P#0.0]; // QuellDaten lesen
      L     DBB [AR2,P#0.0]; // VergleichsDaten lesen
      <>I   ; // wenn nicht gleich, dann Ende
      SPB   NEQ; 
      +AR1  P#1.0; // Quell-Pointer in AR1 um 1 Byte erhöhen
      +AR2  P#1.0; // Vergleichs-Pointer in AR2 um 1 Byte erhöhen
      L     #LOOPS; // Schleifenzähler wieder in Akku 1 zurück
      LOOP  LOP1; // Schleifenzähler bearbeiten

EQ:   SET   ; // Daten sind gleich  (equal)
      SAVE  ; // ENO=TRUE
      CLR   ; 
      SPA   END; 

NEQ:  CLR   ; // Daten sind nicht identisch (not equal)
      SAVE  ; // ENO=FALSE

NETWORK
TITLE =Adressregister 1 wieder herstellen

END:  LAR1  #AR1; // Adressregister 1 wieder herstellen

END_FUNCTION

FUNCTION "m7b_IEC_TIMER_CTRL" : VOID
TITLE =Erweiterte Steuerung von IEC Timern (RESET und 0ms Rüfung)
//IEC-Timer haben im Gegensatz zu den S5-Timern keine RESET-Eingang
//Für RESET eines IEC-Timers muss man diesen mit einer Zeit von 0ms
//aufrufen. (Dies gilt dann als Reset). D.h. IEC-Timer laufen mit
//einer Vorgabe von 0ms nicht an. S5-Timer dagegen gehen bei 0s sofort auf Hi.
//Dieses Verhalten der IEC-Timer führt immer wieder zu Problemen, wenn variable 
//Zeitwerte verwendet werden, und 0 eingegeben wird.
//
//Dieser Baustein vor den eigentlichen IEC-Timer geschaltet, ermöglicht gleiches 
//Verhalten wie bei S5-Timern.
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 1/2013
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  IN_TIME : TIME ;	//Vorgabezeit Timer
  RESET : BOOL ;	//RESET Timer
END_VAR
VAR_OUTPUT
  OUT_TIME : TIME ;	
END_VAR
BEGIN
NETWORK
TITLE =

      SET   ; 
      SAVE  ; 
      CLR   ; 

NETWORK
TITLE =

      L     T#0MS; // Wenn Reset, dann 0ms als Zeit ausgeben
      U     #RESET; // Ein Aufruf mit T=0ms ist für IEC Timer
      SPB   save; // Ein Reset. Siehe Step7 Dokumentation

      L     T#1MS; // Wenn kein Reset, dann minimale Zeitvorgabe
      L     #IN_TIME; // auf 1ms begrenzen
      <D    ; // sonst läuft Timer nicht los,
      SPB   save; // d.h. Ausgang bleibt Lo, da RESET
      TAK   ; 
save: T     #OUT_TIME; // Ausgang Zeit für IEC-Timer

END_FUNCTION

FUNCTION "m7b_IEC_TIMER_WRAPPER" : VOID
TITLE =IEC-TIMER-WRAPPER
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2013
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  IN : BOOL ;	//TIMER IN-SIGNAL
  RESET : BOOL ;	//RESET THE TIMER
  cfgDSP_ET_INV : BOOL ;	//Configuration: Display the ET-Time inverted (rest TIME)
  PT : TIME ;	//TIMER PT (TIME)
  ptrTmrInst : POINTER ;	//RELATIVE POINTER TO TIMER INSTANCE: MemoryArea must be in actual instance DB
  TMR_SFB_No : INT ;	//No. of Timer SFB: 3=TP, 4=TON, 5=TOF
END_VAR
VAR_OUTPUT
  ET : TIME ;	//Abgelaufene Zeit
END_VAR
VAR_TEMP
  memAR1 : DWORD ;	
  memAR2 : DWORD ;	
  TimeIsNull : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =Save AR1 & AR2

      TAR1  #memAR1; // save AR1, AR2
      TAR2  #memAR2; 

NETWORK
TITLE =Load AR2 with Pointer to TIMER-INSTANCE and SET the TIMER
//For the unconditioned call of TIMER SFBs (UC SFB3..5) we have to implement the 
//following steps manually:
//1. SET AR2 with correct INSTANCE-POINTER of TIMER
//2. TRANSFER TIMER.VARIABLES into INCTANCE-DATA: (IN and PT)
//
//TIMER_STRUCTURE of SFB 3..5 (TP/TON/TOF) with relative ADDRESS
//   IN      BOOL   0.0  INPUT:  Signal
//   PT      TIME   2.0  INPUT:  TIME
//   Q       BOOL   6.0  OUTPUT: Q
//   ET      TIME   8.0  OUTPUT: ET
//   STATE   BYTE  10.0  static: STATE
//   STIME   TIME  14.0  static: STIME
//   ATIME   TIME  18.0  static: ATIME
//
      L     P##ptrTmrInst; // Load POINTER to ptrTmrInst
      LAR1  ; // in AR1
      L     D [AR1,P#2.0]; // Load relative InstancePointer (Offset 2: don't need DB-No; Byte 0..1)
      UD    DW#16#FFFFFF; // BYTE.BIT-Pointer only: Remove MemoryArea (Speicherbereich)
      +AR2  ; // Instance-DataPointer of TimerInstance [P#Byte.Bit]
      U     #IN; // Timer Startsignal in Instanz eintragen
      =     DIX [AR2,P#0.0]; // [TIMER].IN

      L     #PT; // Zeitwert in TimerInstanz eintragen
      T     DID [AR2,P#2.0]; // [TIMER].PT
      L     L#0; // IF .PT =0 means RESET for IEC-TIMERs
      ==D   ; 
      =     #TimeIsNull; // Zeit ist T#0ms  => [TIMER].Q will be FALSE

NETWORK
TITLE =RESET
//// IEC-Timer Reset is done by PT:=0
//IF RESET THEN
//   [TIMER].PT = 0
//ENDIF
      U     #RESET; 
      SPBN  ne2; 
      L     L#0; // T#0ms means RESET for IEC-TIMERs
      T     DID [AR2,P#2.0]; // [TIMER].PT

ne2:  NOP   0; 
NETWORK
TITLE =SELECT TIMER FUNCTION
//SELECT TMR_SFB_No
//  CASE <3 or >5 : ERR
//  CASE 3: SFB3 'TP'
//  CASE 4: SFB4 'TON'
//  CASE 5: SFB5 'TOF'
      L     #TMR_SFB_No; 
      SPL   ERR; // >5 (OUT OF RANGE)
      SPA   ERR; // 0
      SPA   ERR; // 1
      SPA   ERR; // 2
      SPA   TP; // 3  SFB3 TP
      SPA   TON; // 4  SFB4 TON
      SPA   TOF; // 5  SFB5 TOF

ERR:  NOP   0; //  *****    E R O R     *****
      CLR   ; 
      SAVE  ; 
      SPA   END; 

TP:   NOP   0; //  ***** M O D E   T P  *****

      UC    "TP"; // unconditioned call for SFB3 'TP'; AR2 has to be loaded with InstanceDataPointer first!

      U     DIX [AR2,P#6.0]; // [TIMER].Q
      SAVE  ; 
      CLR   ; 
      SPA   END; 

TON:  NOP   0; // ***** M O D E   T O N *****

      UC    "TON"; // unconditioned call for SFB4 'TON'; AR2 has to be loaded with InstanceDataPointer first!

      U     #IN; // INPUT SIGNAL for TIMER start
      U     #TimeIsNull; 
      O     DIX [AR2,P#6.0]; // [TIMER].Q
      SAVE  ; 
      CLR   ; 
      SPA   END; 

TOF:  NOP   0; // ***** M O D E   T O F *****

      UC    "TOF"; // unconditioned call for SFB5 'TOF'; AR2 has to be loaded with InstanceDataPointer first!

      U     #IN; // INPUT SIGNAL for TIMER start
      U     #TimeIsNull; 
      O     DIX [AR2,P#6.0]; // [TIMER].Q
      SAVE  ; 
      CLR   ; 
      SPA   END; 


END:  L     DID [AR2,P#8.0]; // [TIMER].ET   (Laufzeit vom IEC-Timer)
      UN    #cfgDSP_ET_INV; // config Input: Display Time inverted (RestZeit)
      SPB   save; 
      L     #PT; // IF inverted THEN   
      TAK   ; //    [OUT].ET = PT-TIMER.ET
      -D    ; 
save: T     #ET; // [OUT].ET

      LAR1  #memAR1; // restore AR1, AR2
      LAR2  #memAR2; 


END_FUNCTION

FUNCTION "m7b_InputControl_REAL" : VOID
TITLE =Input Control for REAL
//Eingabekontrolle für REAL-Werte.
//Begrenzt einen Real-Wert auf vorgegebenen Min/Max Grenzen,
//wobei die Begrenzungsfunktion über Konfigurationseingänge
//zu und abgeschaltet werden kann. So lassen sich z.B. über globale
//Schalter die Eingabebegrenzungen z.B. für Servicezwecke aufheben.
//
//[IN]
//rMIN :         Zulässiger Minimalwert
//rMAX :         Zulässiger Maximalwert
//cfg_LIM_min :  Konfiguration Begrenzung auf Min-Wert aktiv
//cfg_LIM_max :  Konfiguration Begrenzung auf Max-Wert aktiv
//
//[INOUT]
//rVALUE :       Zu prüfender/begrenzender Wert
//
//[OUT]
//MSG_LIM_MAX :  Meldung: Max-Limit überschritten 
//MSG_LIM_MIN :  Meldung: Min-Limit unterschritten
//DSP_STATUS :   Status: 0 : o.k. ; 1 : MinLimit; 2 : MaxLimit
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 5/2013
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  rMIN : REAL ;	//Zulässiger Minimalwert
  rMAX : REAL ;	//Zulässiger Maximalwert
  cfg_LIM_min : BOOL ;	//Konfiguration Begrenzung auf Min-Wert aktiv
  cfg_LIM_max : BOOL ;	//Konfiguration Begrenzung auf Max-Wert aktiv
END_VAR
VAR_OUTPUT
  MSG_LIM_MAX : BOOL ;	//Meldung: Max-Limit überschritten 
  MSG_LIM_MIN : BOOL ;	//Meldung: Min-Limit unterschritten
  DSP_STATUS : INT ;	//Status: 0 : o.k. ; 1 : MinLimit; 2 : MaxLimit
END_VAR
VAR_IN_OUT
  rVALUE : REAL ;	//Zu prüfender Wert
END_VAR
BEGIN
NETWORK
TITLE =
//-
      SET   ; 
      SAVE  ; 
      CLR   ; 
NETWORK
TITLE =Begrenzung, wenn aktiv!
//Begrenzen des Wertes, wenn über-/unterschritten
//Begrenzung wird mit den Konfigurationseingängen
//cfg_LIM_min, cfg_LIM_max = HIGH aktiviert.
      L     #rVALUE; // Sollwert
      L     #rMIN; // minimal Wert
      <R    ; 
      U     #cfg_LIM_min; 
      SPB   LIM; // Limitierung wenn VALUE < MIN
      TAK   ; // VALUE wieder in Akku 1
      L     #rMAX; // Maximalwert
      >R    ; 
      U     #cfg_LIM_max; 
      SPB   LIM; // Limitierung wenn VALUE > MAX

      SPA   ne; 
      CLR   ; // VKE löschen, da keine Begrenzung erfolgte
      SAVE  ; // BIE-Bit = 0, da Wert im Bereich war; ="Keine Begrenzung"
      BEA   ; 

LIM:  T     #rVALUE; // max.Wert als Sollwert ausgeben

ne:   NOP   0; 

NETWORK
TITLE =Meldeausgänge Limit überschritten
//-
      L     #rVALUE; 
      L     #rMAX; // minmal zulässiger Wert
      >R    ; // falls MIN > VALUE
      =     #MSG_LIM_MAX; 

      L     #rVALUE; 
      L     #rMIN; // minmal zulässiger Wert
      <R    ; // falls MIN > VALUE
      =     #MSG_LIM_MIN; 

NETWORK
TITLE =STATUS
//0 : o.k., keine Begreunzung aktiv
//1 : Begrenzung min
//2 : Begrenzung max
      L     1; 
      U     #MSG_LIM_MIN; 
      SPB   save; 

      L     2; 
      U     #MSG_LIM_MAX; 
      SPB   save; 

      L     0; 
save: T     #DSP_STATUS; 
END_FUNCTION

FUNCTION "m7b_InputControl_DINT" : VOID
TITLE =Input Control for DINT
//Eingabekontrolle für DINT-Werte.
//Begrenzt einen Real-Wert auf vorgegebenen Min/Max Grenzen,
//wobei die Begrenzungsfunktion über Konfigurationseingänge
//zu und abgeschaltet werden kann. So lassen sich z.B. über globale
//Schalter die Eingabebegrenzungen z.B. für Servicezwecke aufheben.
//
//[IN]
//dMIN :         Zulässiger Minimalwert
//dMAX :         Zulässiger Maximalwert
//cfg_LIM_min :  Konfiguration Begrenzung auf Min-Wert aktiv
//cfg_LIM_max :  Konfiguration Begrenzung auf Max-Wert aktiv
//
//[INOUT]
//dVALUE :       Zu prüfender/begrenzender Wert
//
//[OUT]
//MSG_LIM_MAX :  Meldung: Max-Limit überschritten 
//MSG_LIM_MIN :  Meldung: Min-Limit unterschritten
//DSP_STATUS :   Status: 0 : o.k. ; 1 : MinLimit; 2 : MaxLimit
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2017
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//31.10.2017   S.Maag         Entstand aus FC252 InputControl_REAL
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  dMIN : DINT ;	//Zulässiger Minimalwert
  dMAX : DINT ;	//Zulässiger Maximalwert
  cfg_LIM_min : BOOL ;	//Konfiguration Begrenzung auf Min-Wert aktiv
  cfg_LIM_max : BOOL ;	//Konfiguration Begrenzung auf Max-Wert aktiv
END_VAR
VAR_OUTPUT
  MSG_LIM_MAX : BOOL ;	//Meldung: Max-Limit überschritten 
  MSG_LIM_MIN : BOOL ;	//Meldung: Min-Limit unterschritten
  DSP_STATUS : INT ;	//Status: 0 : o.k. ; 1 : MinLimit; 2 : MaxLimit
END_VAR
VAR_IN_OUT
  dVALUE : DINT ;	//Zu prüfender Wert
END_VAR
BEGIN
NETWORK
TITLE =
//-
      SET   ; 
      SAVE  ; 
      CLR   ; 
NETWORK
TITLE =Begrenzung, wenn aktiv!
//Begrenzen des Wertes, wenn über-/unterschritten
//Begrenzung wird mit den Konfigurationseingängen
//cfg_LIM_min, cfg_LIM_max = HIGH aktiviert.
      L     #dVALUE; // Sollwert
      L     #dMIN; // minimal Wert
      <D    ; 
      U     #cfg_LIM_min; 
      SPB   LIM; // Limitierung wenn VALUE < MIN
      TAK   ; // VALUE wieder in Akku 1
      L     #dMAX; // Maximalwert
      >D    ; 
      U     #cfg_LIM_max; 
      SPB   LIM; // Limitierung wenn VALUE > MAX

      SPA   ne; 
      CLR   ; // VKE löschen, da keine Begrenzung erfolgte
      SAVE  ; // BIE-Bit = 0, da Wert im Bereich war; ="Keine Begrenzung"
      BEA   ; 

LIM:  T     #dVALUE; // max.Wert als Sollwert ausgeben

ne:   NOP   0; 

NETWORK
TITLE =Meldeausgänge Limit überschritten
//-
      L     #dVALUE; 
      L     #dMAX; // minmal zulässiger Wert
      >D    ; // falls MIN > VALUE
      =     #MSG_LIM_MAX; 

      L     #dVALUE; 
      L     #dMIN; // minmal zulässiger Wert
      <D    ; // falls MIN > VALUE
      =     #MSG_LIM_MIN; 

NETWORK
TITLE =STATUS
//0 : o.k., keine Begreunzung aktiv
//1 : Begrenzung min
//2 : Begrenzung max
      L     1; 
      U     #MSG_LIM_MIN; 
      SPB   save; 

      L     2; 
      U     #MSG_LIM_MAX; 
      SPB   save; 

      L     0; 
save: T     #DSP_STATUS; 
END_FUNCTION

FUNCTION "m7b_BetriebsStunden" : VOID
TITLE =Betriebsstunden erfassen
//pro Bausteinaufruf wird eine bestimmte Anzahl von Sekunden addiert.
//Diesen Baustein mit einem Referenztakt (Timer OB, oder Flanke von Taktmerker 
//aufrufen)
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2013
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//04.12.2013   S.Maag      Bei Count-Aufruf über EN, funktionieren Impulsausgänge
//                         nicht, deswegen Count-Eingang eingeführt
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  COUNT : BOOL ;	//Eingang zählen
  RESET : BOOL ;	//Tageszähler löschen
  SEC_ADD : INT ;	
END_VAR
VAR_OUTPUT
  IMP_MIN : BOOL ;	
  IMP_H : BOOL ;	
END_VAR
VAR_IN_OUT
  sec : INT ;	
  min : INT ;	
  h : DINT ;	//Stunden
END_VAR
BEGIN
NETWORK
TITLE =

      SET   ; 
      SAVE  ; 
      R     #IMP_MIN; 
      R     #IMP_H; 
      CLR   ; 

      UN    #RESET; 
      SPB   cnt; 
      L     0; 
      T     #sec; 
      T     #min; 
      T     #h; 
      BEA   ; 

cnt:  UN    #COUNT; 
      BEB   ; 

      L     #sec; 
      L     #SEC_ADD; 
      +I    ; 
      T     #sec; 
      L     60; 
      <I    ; 
      BEB   ; 

      S     #IMP_MIN; 

      L     #sec; 
      +     -60; 
      T     #sec; 

      L     #min; 
      +     1; 
      T     #min; 

      L     60; 
      <I    ; 
      BEB   ; 

      S     #IMP_H; 

      L     #min; 
      +     -60; 
      T     #min; 

      L     #h; 
      +     1; 
      T     #h; 
      L     0; // Überlauf prüfen, Stunden müssen >=0 sein
      >=D   ; // wenn nicht, dann auf 0 setzten
      BEB   ; 
      T     #h; 
END_FUNCTION

FUNCTION "m7b_DeltaTime" : VOID
TITLE =DeltaTime : Zeitdifferenz zwischen 2 Impulsen
//Ermittelt den Abstand zwischen 2 Impulsen.
//In io_DeltaTime wird der Abstand des letzten Impulses gespeichert.
//DSP_ActTimDiff zeigt die seit letztem Impuls aktuell vergangene Zeit
//MAX_timDiff = MAX(io_DeltaTime, DSP_TimeDiffAkt)
//
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 11/2013
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//04/09/2017   S.Maag      RESET Eingang + einfrieren 1sec vor max Differenz
//
//16/01/2014   S.Maag      ENO=TRUE
//
//03/12/2013   S.Maag      SFC64 TimeTick Zeitdifferenz korrigiert
//                         da 31Bit, Fehler bei Überlauf. 
//                         jetzt Differenzber. mit FC256 "ABS_DIFF_S7SysTime"
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  FP_Signal : BOOL ;	//Flanke Signal
  RESET : BOOL ;	
END_VAR
VAR_OUTPUT
  DSP_ActTimeDiff : TIME ;	//Anzeige aktuelle Zeitdifferenz seit letztem Ereignis
  MAX_timDiff : TIME ;	//Max(timDiff, io_DeltaTime)
END_VAR
VAR_IN_OUT
  memTime : TIME ;	
  io_DeltaTime : TIME ;	
END_VAR
VAR_TEMP
  SysTimer : TIME ;	
END_VAR
BEGIN
NETWORK
TITLE =

      SET   ; 
      SAVE  ; 
      CLR   ; 

NETWORK
TITLE =
//31Bit = 7F FF FF FF = 2147483647 - 1000ms = 2147482647 ms 
//1sec vor Ablauf der max Differenz den Differenzwert einfrieren bis neuer Impuls 
//kommt.
//Dies verhindert Überlauf der Zeitdifferenz uns somit eine Rückfall der 
//Differenzzeit auf 0 ohne neuen Impuls
      UN    #RESET; 
      SPB   do; 

      L     T#0MS; 
      T     #DSP_ActTimeDiff; 
      T     #MAX_timDiff; 
      SPA   ne2; 

do:   NOP   0; 
      CALL "TIME_TCK" (
           RET_VAL                  := #SysTimer);

      L     #DSP_ActTimeDiff; // Wenn max. Zeitdifferenz erreicht,
      L     L#2147482647; // dann Wert einfrieren und erst
      >=D   ; // nach neuem Impuls weiter
      SPB   ne2; // dadurch wird ein überlauf verhindert

      L     #SysTimer; 
      L     #memTime; 
      UC    "m7b_ABS_DIFF_S7SysTime"; // Absolute Zeitdifferenz S7-SystemTimer 31Bit
      T     #DSP_ActTimeDiff; 
      L     #io_DeltaTime; 
      UC    FC    21; 
      T     #MAX_timDiff; 
ne2:  NOP   0; 
NETWORK
TITLE =Zeit Ereignis

      UN    #FP_Signal; 
      SPB   ne3; 

      L     #DSP_ActTimeDiff; 
      T     #io_DeltaTime; 

      L     L#0; 
      T     #DSP_ActTimeDiff; 

      L     #SysTimer; 
      T     #memTime; 

ne3:  NOP   0; 
NETWORK
TITLE =



END_FUNCTION

FUNCTION "m7b_CNT_UpDwn_IMP_MM.SS" : VOID
TITLE =Zählt Impulse im Minuten.Sekunden Format (MM.SS) - DINT
//Bei jedem Aufruf Zählt diese Funktion einen Impuls weiter. Die Wertedarstellung 
//erfolgt im Minuten.Sekunden-Format MM.SS. Es wird also alle 60 Impulse ein 
//Überlauf auf MM erzeugt. Dieser Baustein eignet sich zum Erfassen von z.B. 
//Behälter Füll- und Entleerzeiten, wenn er mit einer Sekundenflanke aufgerufen 
//wird. Am besten Flanke des Systemtaktmerkers 1 sec verwenden.
//
//Der FC-ENO Ausgang ist immer dan HIGH, wenn Zeit > 0
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 5/2005
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//25.06.2019   S.Maag     COUNT_UP / COUNT_DOWN
//                        Ausgang d_mmss als I/O, somit muss nur bei Änderung
//                        neu berechnet werden.
//                        ENO = (Time > 0) d.h. ENO=FALSE, wenn Zeit = 0     
//                        Wird für Rückwärtszählung benötigt!
//
//14.08.2013   S.Maag     Ausgang MM.SS hinzugefügt so dass im IO mem_dIMP die
//                        gezählten Impulse stehen und nicht mehr MM.SS
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  COUNT_UP : BOOL ;	//Signal for counting up
  COUNT_DWN : BOOL ;	//Signal for counting down
  SET : BOOL ;	//Set to VALUE_SET
  VALUE_SET_mmss : DINT ;	//Value [mm:ss] to set
END_VAR
VAR_IN_OUT
  io_dIMP : DINT ;	//Memory for impulses [sec]
  io_d_mmss : DINT ;	//Memory [mm:ss] format
END_VAR
VAR_TEMP
  SS : INT ;	
  MM : DINT ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =SET

      UN    #SET; 
      SPB   NE1; 

      L     #VALUE_SET_mmss; 
      L     L#100; 
      MOD   ; // Sekundenanteil 0..99
      T     #SS; // =Divisionsrest = Sekunden

      L     #VALUE_SET_mmss; 
      L     L#100; // Minutenanteil
      /D    ; 
      T     #MM; // Rückrechnung auf Sekunden
      L     L#60; // damit werden automatisch
      *D    ; // Sekundenanteile von 60..99
      L     #SS; // auf eine zusätzliche Minute
      +D    ; // umgerechnet
      T     #io_dIMP; 
      SPA   END; 
NE1:  NOP   0; 
NETWORK
TITLE =Impulse Zählen [mm:ss]
//    
//
      U     #COUNT_UP; 
      SPB   up; 
      U     #COUNT_DWN; 
      SPB   dwn; 

      SPA   END; 

up:   L     #io_dIMP; 
      +     L#1; 
      SPA   chk; 
dwn:  L     #io_dIMP; 
      +     L#-1; 
chk:  L     L#0; // wenn <0, dann 0
      <D    ; // das begrenzt sowohl bei down
      SPB   save; // als auch Überläufe bei UP auf negative Zeit
      TAK   ; 
save: T     #io_dIMP; 
      L     L#60; // Sekunden pro Minute
      /D    ; 
      T     #MM; // Minuten

      L     #io_dIMP; 
      L     L#60; // Sekunden pro Minute
      MOD   ; // Restwerdivision: Rest sec
      T     #SS; // =Divisionsrest = Sekunden

      L     #MM; // Minuten*100 
      L     L#100; 
      *D    ; 
      L     #SS; 
      +D    ; 
      T     #io_d_mmss; // Wert in MM.SS

END:  L     #io_dIMP; 
      L     L#0; 
      >D    ; 
      SAVE  ; 
      CLR   ; 

END_FUNCTION

FUNCTION "m7b_CNT_Up" : VOID
TITLE =Simple up counter 
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 4/2020
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  xCnt : BOOL ;	//Count: Hi is continous counting
  xReset : BOOL ;	//Reset counter to 0
END_VAR
VAR_IN_OUT
  io_dCNT : DINT ;	//io Counter value
END_VAR
BEGIN
NETWORK
TITLE =

NETWORK
TITLE =count

      U     #xCnt; 
      SPBNB _001; 
      L     #io_dCNT; 
      L     L#1; 
      +D    ; 
      T     #io_dCNT; 
_001: NOP   0; 
NETWORK
TITLE =Reset

      U     #xReset; 
      SPBNB _002; 
      L     0; 
      T     #io_dCNT; 
_002: NOP   0; 
NETWORK
TITLE =

      SET   ; 
      SAVE  ; 
      CLR   ; 

END_FUNCTION

FUNCTION "m7b_CNT_UpDwn_Limit" : VOID
TITLE =Couter Up Down with Limit
//Counter Up Down with liumit for up and down 
//If the limit is reached the counter stops counting.
//32-Bit DINT: -2147483648 to +2147483647
//
//How to use this counter:
//
//- As Timer if you count with the SystemClockFlags. In contrast to IEC Timer
//  this one is easy to pause!
//
//- As standard counter because IEC counters only use 16-Bit values
//
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 4/2020
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//24.03.2021   S.Maag      FB wasn't ready programmed! Finished!
//                         Added seperate limit for down!
//                         Added seperate Output signals for Limit up/down reached
//                         Changend cfgUpDwn to cfgDwnUp (!more logical)
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  xCntUp : BOOL ;	//1: count up; 0: do nothing
  xCntDwn : BOOL ;	//1: count dwon; 0: do nothing
  xSET : BOOL ;	//Set counter to SetVal
  dSetVal : DINT ;	//Set value
  dCntVal : DINT ;	//io_dCount +/- dCntVal
  dLimitUp : DINT ;	//Limit up (-2147483648..2147483647)
  dLimitDwn : DINT ;	//Limit down (-2147483648..2147483647)
END_VAR
VAR_OUTPUT
  Q_LIM_UP : BOOL ;	
  Q_LIM_DWN : BOOL ;	
END_VAR
VAR_IN_OUT
  io_dCNT : DINT ;	//io Zählerwert
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =Set the counter to SetVal
//IF xSET THEN io_dCNT := dSetVal; END_IF;
      U     #xSET; 
      SPBNB _001; 
      L     #dSetVal; 
      T     #io_dCNT; 
_001: NOP   0; 
NETWORK
TITLE =Count up
//IF xCntUp THEN
//   io_dCnt := io_dCnt + dCntVal;
//   IF OVERFLOW OR (iodCnt > dLimitUp) THEN
//      iodCnt := dLimitUp;
//   END_IF;
//END_IF;
//
      U     #xCntUp; // IF CntUp
      SPBN  NE2; 

      L     #io_dCNT; // Counter value
      L     #dCntVal; // Value to count
      +D    ; 
      L     #dLimitUp; // Counter upper limit
      U     OV; // Overflow Bit
      O     ; 
      >D    ; // io_dCNT + dCntVal > LimitUp
      SPB   SUp; // save CntUp => save Limit
      TAK   ; // io_dCNT + dCntVal => Akku1
SUp:  T     #io_dCNT; // save the new counter value
NE2:  NOP   0; 

NETWORK
TITLE =Count down
//IF xCntDwn THEN
//   io_dCnt := io_dCnt - dCntVal;
//   IF OVERFLOW OR (iodCnt < dLimitDwn) THEN
//      iodCnt := dLimitDwn;
//   END_IF;
//END_IF;
      U     #xCntDwn; // IF CntDwn
      SPBN  NE3; 

      L     #io_dCNT; // Counter value
      L     #dCntVal; // Value to count
      -D    ; 
      L     #dLimitDwn; // Counter lower limit
      U     OV; // Overflow Bit
      O     ; 
      <D    ; // io_dCNT - dCntVal < LimitDwn
      SPB   SDwn; // save CntUp => save Limit
      TAK   ; // io_dCNT - dCntVal => Akku1
SDwn: T     #io_dCNT; // save the new counter value
NE3:  NOP   0; 

NETWORK
TITLE =Limit up reached ?

      U     #xCntDwn; 
      U(    ; 
      L     #io_dCNT; 
      L     #dLimitUp; 
      >=D   ; 
      )     ; 
      =     #Q_LIM_UP; 
NETWORK
TITLE =Limit down reached

      L     #io_dCNT; 
      L     #dLimitDwn; 
      <=D   ; 
      =     #Q_LIM_DWN; 
NETWORK
TITLE =

      SET   ; 
      SAVE  ; 

END_FUNCTION

FUNCTION "m7b_mmss_Overflow" : VOID
TITLE =Check and correct Overflow of hh:mm or mm:ss variables
//mmss_Overflow:
//Check and correct the overflow of variables with time values in the [hh:mm] or 
//[mm:ss] Format.
//
//Example: 
//Value = 259  ;  2h 59m -> correct, nothing to do
//Value = 260  ;  2h 60m -> correct to 3h 00m by adding 40 -> Value = 300
//Value = 265  ;  2h 65m -> correct to 3h 05m by adding 40 -> Value = 305
//
//FC_ENO = TRUE if there was an overflow
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 9/2019
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//-------------------------------------------------------------------------------
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_IN_OUT
  io_d_hhmm_mmss : DINT ;	//Input value in hh:mm or mm:ss 
END_VAR
BEGIN
NETWORK
TITLE =

      L     #io_d_hhmm_mmss; 
      L     L#100; // select lower 2 digits
      MOD   ; 
      L     L#60; // full mm or ss
      >=D   ; 
      SPBB  OFlw; // Jump if VKE=1 and Save VKE to BIE (Overflow)  
      BEA   ; 

OFlw: L     #io_d_hhmm_mmss; // we must count 58,59,100 (=add 40 if >=60)
      +     L#40; // Add the correct value for overflow
      T     #io_d_hhmm_mmss; // 

END_FUNCTION

FUNCTION "m7b_ImpulsTeiler" : VOID
TITLE =Impulsteiler
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 12/2015
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE: In Library aufgenommen 05/2019
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  Impuls : BOOL ;	
  dTeilung : DINT ;	//Impulsteilung: alle x Impulse am Eingang 1x Ausgang
END_VAR
VAR_OUTPUT
  Q : BOOL ;	
END_VAR
VAR_IN_OUT
  memDI : DINT ;	
END_VAR
VAR_TEMP
  HM_Q : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =



      U     #Impuls; 
      SPBNB _001; 
      L     #memDI; 
      L     L#1; 
      +D    ; 
      T     #memDI; 
_001: NOP   0; 
NETWORK
TITLE =

      L     #memDI; 
      L     #dTeilung; 
      >=D   ; 
      =     #Q; 
      =     #HM_Q; 
NETWORK
TITLE =

      U     #HM_Q; 
      SPBNB _002; 
      L     0; 
      T     #memDI; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
_002: U     BIE; 
      SAVE  ; 
END_FUNCTION

FUNCTION "m7h_Check4xInput_REAL" : VOID
TITLE =4 Schwellen prüfen: auf- oder absteigend
//Plausiblitätsprüfung von Auf- oder Absteigenden Grenzwerten. 
//z.B. Füllstandsschwellen von Behältern. (min darf nicht > max sein)
//[IN]
//cfg_Limit_ON : FALSE : keine Begrenzung der Eingabewerte
//               TRUE  : Begrenzung der Eingabewerte Fehleingaben 
//                       werden nicht zugelassen.
//
//cfg_ASC_DESC : FALSE : aufsteigen S1<S2<S3<S4
//               TRUE  : absteigend S1>S2>S3>S4
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 07/2012
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME       AENDERUNG
//--------------------------------------------------------------------------------
//14.03.2020   S.Maag     in Library aufgenommen und Code optimiert
//                        (FLAGs direkt aus Lokaldatenbyte kopiert statt über
//                         FC1 zusammengesetzt) 
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  cfg_Limit_ON : BOOL ;	//Schaltet die Begrenzung Ein, sonst nur Anzeige, wenn Schwelle inkonsistent
  cfg_ASC_DESC : BOOL ;	//FALSE: 'ASC' aufsteigende Werte S2>S1 / TRUE: 'DESC' absteigende Werte S2<S1
END_VAR
VAR_OUTPUT
  FLAGs_ok : BYTE ;	
END_VAR
VAR_IN_OUT
  S1 : REAL ;	
  S2 : REAL ;	
  S3 : REAL ;	
  S4 : REAL ;	
END_VAR
VAR_TEMP
  S1_ok : BOOL ;	
  S2_ok : BOOL ;	
  S3_ok : BOOL ;	
  S4_ok : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =Lokaldatnwort 0 löschen
//wird benötigt, da S1_0k .. S4_ok als FLAGs ausgegeben wird.
//Damit keine Signale in den Leerbits sind, muss zuvor gelöscht werden.
      L     0; 
      T     LW     0; 
      NOP   0; 
NETWORK
TITLE =Schaltschwelle 2 o.k.: 

      UN    #cfg_ASC_DESC; 
      U(    ; 
      L     #S2; 
      L     #S1; 
      >R    ; 
      )     ; 
      O     ; 
      U     #cfg_ASC_DESC; 
      U(    ; 
      L     #S2; 
      L     #S1; 
      <R    ; 
      )     ; 
      =     #S2_ok; 
      =     #S1_ok; 
NETWORK
TITLE =Schaltschwelle 3 o.k.:

      UN    #cfg_ASC_DESC; 
      U(    ; 
      L     #S3; 
      L     #S2; 
      >R    ; 
      )     ; 
      O     ; 
      U     #cfg_ASC_DESC; 
      U(    ; 
      L     #S3; 
      L     #S2; 
      <R    ; 
      )     ; 
      =     #S3_ok; 
NETWORK
TITLE =Schaltschwelle 4 o.k.: S4 > S3

      UN    #cfg_ASC_DESC; 
      U(    ; 
      L     #S4; 
      L     #S3; 
      >R    ; 
      )     ; 
      O     ; 
      U     #cfg_ASC_DESC; 
      U(    ; 
      L     #S4; 
      L     #S3; 
      <R    ; 
      )     ; 
      =     #S4_ok; 
NETWORK
TITLE =Anzeige Schaltschwelle o.k.
//S1_ok .. S4_ok als FLAGs ausgeben
      L     LB     0; 
      T     #FLAGs_ok; 
      NOP   0; 
NETWORK
TITLE =

      UN    #cfg_Limit_ON; 
      BEB   ; 

      U     #S4_ok; 
      SPB   lim3; 

      L     #S3; 
      T     #S4; 

lim3: U     #S3_ok; 
      SPB   lim2; 

      L     #S2; 
      T     #S3; 

lim2: U     #S2_ok; 
      SPB   END; 

      L     #S1; 
      T     #S2; 

END:  NOP   0; 
NETWORK
TITLE =

      SET   ; 
      SAVE  ; 


END_FUNCTION

FUNCTION "m7h_Check2xInput_REAL" : VOID
TITLE =2 Schwellen prüfen: auf- oder absteigend
//Plausiblitätsprüfung von Auf- oder Absteigenden Grenzwerten. 
//z.B. Füllstandsschwellen von Behältern. (min darf nicht > max sein)
//[IN]
//cfg_Limit_ON : FALSE : keine Begrenzung der Eingabewerte
//               TRUE  : Begrenzung der Eingabewerte Fehleingaben 
//                       werden nicht zugelassen.
//
//cfg_ASC_DESC : FALSE : aufsteigen S1<S2
//               TRUE  : absteigend S1>S2
//
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 11/2016
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME       AENDERUNG
//--------------------------------------------------------------------------------
//14.03.2020   S.Maag     in Library aufgenommen und Code optimiert
//                        (FLAGs direkt aus Lokaldatenbyte kopiert statt über
//                         FC1 zusammengesetzt) 
//
//--------------------------------------------------------------------------------
//
//HINWEISE: entsand aus FC346 4 Schwellen prüfen
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  cfg_Limit_ON : BOOL ;	//Schaltet die Begrenzung Ein, sonst nur Anzeige, wenn Schwelle inkonsistent
  cfg_ASC_DESC : BOOL ;	//FALSE: 'ASC' aufsteigende Werte S2>S1 / TRUE: 'DESC' absteigende Werte S2<S1
END_VAR
VAR_OUTPUT
  FLAGs_ok : BYTE ;	
END_VAR
VAR_IN_OUT
  S1 : REAL ;	
  S2 : REAL ;	
END_VAR
VAR_TEMP
  S1_ok : BOOL ;	
  S2_ok : BOOL ;	
  S3_ok : BOOL ;	
  S4_ok : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =Lokaldatnwort 0 löschen
//wird benötigt, da S1_0k .. S4_ok als FLAGs ausgegeben wird.
//Damit keine Signale in den Leerbits sind, muss zuvor gelöscht werden.
      L     0; 
      T     LW     0; 
      NOP   0; 
NETWORK
TITLE =Schaltschwelle 2 o.k.: 

      UN    #cfg_ASC_DESC; 
      U(    ; 
      L     #S2; 
      L     #S1; 
      >R    ; 
      )     ; 
      O     ; 
      U     #cfg_ASC_DESC; 
      U(    ; 
      L     #S2; 
      L     #S1; 
      <R    ; 
      )     ; 
      =     #S2_ok; 
      =     #S1_ok; 
NETWORK
TITLE =Anzeige Schaltschwelle o.k.
//S1_ok .. S2_ok als FLAGs ausgeben
      L     LB     0; 
      T     #FLAGs_ok; 
      NOP   0; 
NETWORK
TITLE =

      UN    #cfg_Limit_ON; 
      BEB   ; 

      U     #S2_ok; 
      SPB   END; 

      L     #S1; 
      T     #S2; 

END:  NOP   0; 
NETWORK
TITLE =

      SET   ; 
      SAVE  ; 


END_FUNCTION

FUNCTION "m7b_MinMax_ERROR_REAL" : VOID
TITLE =Wert ausserhalb Min..Max Bereich und erzeugt Fehlermeldung
//Prüft ob der IST-Wert zwischen MIN & MAX liegt und erzeugt speichernde 
//Fehlermeldung.
//
//Verwendung: Fehlerüberwachung von Analogsensoren
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 11/2012
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//29.07.2013   S.Maag          Ausgang Statusanzeige hinzugefügt
//--------------------------------------------------------------------------------
//
//HINWEISE: Entstand aus FB38 MinMaxOK_REAL, in Library aufgenommen 03/2020
//          als FC338 beibehalten
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 2.0


VAR_INPUT
  VALUE : REAL ;	//Zu prüfender Wert
  MIN : REAL ;	//Zulässiger Minimalwert
  MAX : REAL ;	//Zulässiger Maximalwert
  RESET : BOOL ;	
END_VAR
VAR_OUTPUT
  DSP_STATUS : INT ;	//STATUS: 0=o.k.; 1=warn; 2=Fehler
END_VAR
VAR_IN_OUT
  ERR : BOOL ;	//Wert im Toleranzbereich
END_VAR
BEGIN
NETWORK
TITLE =

      L     #MIN; // minmal zulässiger Wert
      L     #VALUE; 
      >R    ; // falls MIN > VALUE
      SPB   err; // dann nicht ok
      L     #MAX; 
      >R    ; // falls VALUE > MAX
      SPB   err; // dann nicht ok

      U     #RESET; 
      R     #ERR; // sonst ok
      SPA   END; 

err:  S     #ERR; // Wert nicht ok

END:  UN    #ERR; 
      SAVE  ; 

NETWORK
TITLE =Statusanzeige
//0 := o.k.
//1 := Warnung
//2 := Fehler
      L     2; 
      U     #ERR; // Fehler
      SPB   save; 
      L     1; 
      CLR   ; // Warnung
      SPB   save; 
      L     0; // o.k.
save: T     #DSP_STATUS; 
END_FUNCTION

FUNCTION "m7b_HYS_to_MinMax_REAL" : VOID
TITLE =Sollwert mit Hysterese auf min/max umrechnen [REAL]
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 09/2011
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE: In Library aufgenommen 03/2020
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  rSOLL : REAL ;	
  rHYS : REAL ;	
  cfgFullHys : BOOL ;	//0:= Soll +- Hys/2 ; 1:= Soll +- Hys
END_VAR
VAR_OUTPUT
  rMin : REAL ;	
  rMax : REAL ;	
END_VAR
VAR_TEMP
  tmpHys : REAL ;	
END_VAR
BEGIN
NETWORK
TITLE =

      SET   ; 
      SAVE  ; 
      CLR   ; 

NETWORK
TITLE =Konfiguration halbe oder volle Hysteres 
//#cfgFullHys: 0:= Soll +- Hys/2
//             1:= Soll +- Hys
      L     #rHYS; 
      U     #cfgFullHys; 
      SPB   sav; 
      L     2.000000e+000; 
      /R    ; 
sav:  T     #tmpHys; 

NETWORK
TITLE =

      L     #rSOLL; // Sollwert 
      L     #tmpHys; // Hystersewert
      +R    ; 
      T     #rMax; // Ausgang max. Wert
      POP   ; // Sollwert zurück in AKKU1
      L     #rSOLL; // Sollwert
      L     #tmpHys; // Hystersewert
      -R    ; 
      T     #rMin; // Ausgang min. Wert
END_FUNCTION

FUNCTION "m7b_GetParity_DWORD" : BOOL
TITLE =Get ParityBit for Even/Odd Parity and count Hi-Bits (0..32)
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 4/2020
//
//RET_VAL : Parity Bit, so dass gewünschte gerade/ungerade Parität entsteht
//FC_ENO  : TRUE: mindestens 1 Bit war Hi
//
//Für BYTE/INT/DINT/REAL, diese zuerst auf ein DWORD kopieren bzw. wandeln
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM       NAME       AENDERUNG
//--------------------------------------------------------------------------------
//03.04.2020  S.Maag     Entsand aus BitCountINT
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  dwVAL : DWORD ;	//zu prüfender Wert
  cfg_Even_Odd : BOOL ;	//FALSE: returns odd parity; TRUE: returns even parity
END_VAR
VAR_OUTPUT
  iBitCount : INT ;	//No of Hi-Bits
END_VAR
VAR_TEMP
  AR1 : DWORD ;	
  EvenParity : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =Anzahl der gestzten Bits in INT Zählen
//Die Anzahl der Bits wird dann in #Bits zurückgeben, steht aber auch noch
//zusätzlich im Akku1 zur Verfügung
      TAR1  #AR1; // Adressregister im TMEP-Bereich sichern
      L     #dwVAL; // zu prüfenden Wert in Akku 1
      L     DW#16#0; // Adressregister 1 wird als BitZaehler verwendet
      LAR1  ; // daher auf 0 setzten
LOOP: TAK   ; // zu prüfende Bits wieder in Akku 1     
      SRD   1; // erstes zu Prüfendes Bit hinausschieben
      SPZ   NEXT; // Wenn 0 dann Schleifenende prüfen
      +AR1  P#0.1; // Bitzähler im Adressregister 1 um 1 erhöhen
NEXT: L     DW#16#0; // Vergleichswert, Bits zählen bis 0 erreicht
      <>D   ; // Solange wiederholen bis zu prüfende Bits
      SPB   LOOP; // den Wert 0 erreicht haben, alle Bits gezählt!
      TAR1  ; // Anzahl Bits aus Adressregister in Akku 1
      <>D   ; // Anzahl Bits auf 0 prüfen (mit vorheriger 0, bereits im AKKU)
      SAVE  ; // BIE-BIT = High, wenn Anzahl der Bits<>0
      CLR   ; // VKE wieder rücksetzen (verarbeiten)
      T     #iBitCount; // Anzahl Bits in Rückgabewert
      SRD   1; // erstes Bit der Bitanzahl rausschieben
      U     ==0; // Wenn Bit=0, dann gerade Bitanzahl
      =     #EvenParity; 
// Parity Bit für gewünsche Parity erzeugen
      UN    #EvenParity; // Parity ist nicht gerade (ungerade)
      UN    #cfg_Even_Odd; // und gerade Parity gefordert
      O     ; 
      U     #EvenParity; // Parity ist gerade
      U     #cfg_Even_Odd; // ungerade Parity ist gefordert
      =     #RET_VAL; // Parity Bit, so dass geforderte Parity erziehlt wird

      LAR1  #AR1; // Adressregister wieder herstellen

NETWORK
TITLE =alternativer Code
//    // #BitCounter & #LoopRegister im TEMP-Bereich als INT anlegen
//
//      L     0
//      T     #BitCounter                 // Anzahl Bits auf 0
//      L     2#1000000000000000          // SchleifenRegister
//      T     #LoopRegister               // initialisieren
//
//      L     #Wert                       // zu prüfenden Wert in Akku 1
//loop: SRD   1                           // 1 Bit hinausschieben
//      SPP   inc                         // wenn positiv, dann Bit zaehlen
//      SPA   next                        // sonst weiter mit Schleifenregister
//
//inc:  L     #BitCounter                 // Bit zählen
//      +     1
//      T     #BitCounter
//      TAK                               // zu prüfenden Wert in Akku 1 zurück
//
//next: L     #LoopRegister               // SchleifenRegister auf nächstes Bit
//      SRD   1
//      SPP   end                         // falls positiv, dann letztes Bit != 
//Ende
//      T     #LoopRegister
//      TAK   
//      SPA   loop
//
//end:  L     #BitCounter                 // Anzahl Bits zurückgeben
//      T     #Bits
//      L     0                           // BIE-Bit=High, wenn Anzahl Bits >0 
//      <>I   
//      SAVE  
//      CLR   
//


END_FUNCTION

FUNCTION "m7b_GetFirstOf8Bits" : VOID
TITLE =Get First Hi of 8 Bits
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 6/2007
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//12.08.2013   S.Maag    direkets Byteweises kopieren von den Eingängen
//                       funktioniert nur, wenn die Quellbits aufeinanderfolgend
//                       sind. (war bisher immer zufällig so, da KOP und 
//                       Übergabe per Lx.y, Im AWL funktioniert es nicht, da 
//                       direkte Merkeradressen übergeben werden)
//                       Bits müssen deshalb immer einzeln kopiert werden!
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  RESET : BOOL ;	
  Sig1 : BOOL ;	
  Sig2 : BOOL ;	
  Sig3 : BOOL ;	
  Sig4 : BOOL ;	
  Sig5 : BOOL ;	
  Sig6 : BOOL ;	
  Sig7 : BOOL ;	
  Sig8 : BOOL ;	
END_VAR
VAR_OUTPUT
  TheByte : BYTE ;	//The 8 Input Bits as Byte
  iNoOf1st : INT ;	//No of 1st Hi-Signal 1..8 (0 = no Hi Bit)
END_VAR
BEGIN
NETWORK
TITLE =

      UN    #RESET; 
      SPB   ne1; 

      L     0; 
      T     #TheByte; 
      T     #iNoOf1st; 

      CLR   ; 
      SAVE  ; 
      BEA   ; 
ne1:  NOP   0; 

NETWORK
TITLE =
// 
      U     #Sig1; 
      =     L      0.0; 
      U     #Sig2; 
      =     L      0.1; 
      U     #Sig3; 
      =     L      0.2; 
      U     #Sig4; 
      =     L      0.3; 
      U     #Sig5; 
      =     L      0.4; 
      U     #Sig6; 
      =     L      0.5; 
      U     #Sig7; 
      =     L      0.6; 
      U     #Sig8; 
      =     L      0.7; 

      L     LB     0; 
      T     #TheByte; 

NETWORK
TITLE =Nr des ersten gesetzten Bits
//CODE FROM FC192 m7a_FirstBit_INT
      L     LB     0; // zu prüfenden Wert in Akku
      L     0; // vergleichen ob Wert = 0
      <>I   ; // dann Ende, wenn nicht muss mind. 1 Bit gesetzt sein
      SAVE  ; // Anzahl Bits <> 0 in BIE-Bit speichern
      SPBN  end; // ENDE, wenn Wert = 0
      INC   1; // Schleifenzaehler in Akku 1 auf 1 stellen = BitPosition
      TAK   ; // zu prüfende Bits in Akku 1 zurück
Loop: SRW   1; // 1 Bit hinausschieben
      SPP   save; // wenn poitiv, dann erstes Bit gefunden => speichern
      TAK   ; // Schleifenzaehler in Akku 1
      INC   1; // erhöhen Schleifenzaehler, BitNr.
      TAK   ; // zu prüfende Bits in Akku zurück
      SPA   Loop; // Schleife für nächstes Bit wiederholen
save: TAK   ; // Schleifenzaehler, BitNr in Akku 1
end:  T     #iNoOf1st; // BitPosition zurückgeben


NETWORK
TITLE =

      SET   ; 
      SAVE  ; 
      CLR   ; 


END_FUNCTION

FUNCTION "m7b_FSM_STATE_TIME" : VOID
TITLE =Count Time pulses of State No.
//Erfasst die Zeit der Schrittkette im akutellen Schritt.
//Zeitbasis muss als Taktflankenmerker übergeben werden.
//So lassen sich z.B. 0.1sec und 1sec Taktungen erreichen, je nachdem welchen
//Basistakt man wählt.
//
//ENO: True for 1 cycle, if StateNo change (=Timer Restart / RESET)
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 2/2017
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
//
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  TaktImpuls : BOOL ;	//Taktimpuls 1sec 
  iSNR : INT ;	//Schrittnummer / State No.
END_VAR
VAR_OUTPUT
  dTime_10xTakt : DINT ;	//Zähler Zeitimpulse (10xTakt, sec) / Counter Time pulses (10xTakt, sec)
END_VAR
VAR_IN_OUT
  io_dTime_TAKT : DINT ;	//Zähler Zeitimpulse (Takt, 1/10sec) / Counter Time pulses (takt 1/10sec)
  io_iMemSNR : INT ;	//Speicher letzte Schrittnummer / Memory last State No.
END_VAR
VAR_TEMP
  tmpMSG_RESET : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =Reset Time when State No changed
//Achtung: direkts (SAVE) hier statt tmpMSG_RESET
//geht nicht. Sonst werden nachfolgende Verknüpfungen mit
//nicht ausgeführt, das das BIE-Bit automatisch mit verknüpft wird.
//Es wäre vorher ein CLR nötig
      U(    ; 
      U(    ; 
      L     #iSNR; 
      L     #io_iMemSNR; 
      <>I   ; 
      )     ; 
      SPBNB _001; 
      L     L#0; 
      T     #io_dTime_TAKT; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
_001: U     BIE; 
      )     ; 
      SPBNB _002; 
      L     #iSNR; 
      T     #io_iMemSNR; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
_002: U     BIE; 
      =     #tmpMSG_RESET; 
NETWORK
TITLE =Count Time

      U     #TaktImpuls; 
      SPBNB _003; 
      L     #io_dTime_TAKT; 
      L     L#1; 
      +D    ; 
      T     #io_dTime_TAKT; 
_003: NOP   0; 
NETWORK
TITLE =Time 10xTakt

      L     #io_dTime_TAKT; 
      L     L#10; 
      /D    ; 
      T     #dTime_10xTakt; 
      NOP   0; 
NETWORK
TITLE =RESET / RESTART Message as FC-ENO

      U     #tmpMSG_RESET; 
      SAVE  ; 
END_FUNCTION

FUNCTION "m7b_FSM_TIME" : VOID
TITLE =Count Time pulses of active State range
//Duration of active States
//starts at: StateNo = iStateStart
//stops at:  StateNo = iStateEnd
//
//Ermittelt die abgelaufene Zeit einer Schrittkette von
//iStateStart bis iStateEnd. Anwendung z.B. zur Laufzeitüberwachung! 
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 11/2017
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  TaktImpuls : BOOL ;	//Taktimpuls 1sec 
  iSNR : INT ;	//Schrittnummer / State No.
  iStateStart : INT ;	
  iStateEnd : INT ;	
END_VAR
VAR_OUTPUT
  dTime_10xTakt : DINT ;	//Zähler Zeitimpulse (10xTakt, sec) / Counter Time pulses (10xTakt, sec)
END_VAR
VAR_IN_OUT
  io_dTime_TAKT : DINT ;	//Zähler Zeitimpulse (Takt, 1/10sec) / Counter Time pulses (takt 1/10sec)
  io_iMemSNR : INT ;	//Speicher letzte Schrittnummer / Memory last State No.
END_VAR
VAR_TEMP
  MSG_active : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =State No in the active range => cout Time

      U(    ; 
      L     #iSNR; 
      L     #iStateStart; 
      >=I   ; 
      )     ; 
      U(    ; 
      L     #iSNR; 
      L     #iStateEnd; 
      <=I   ; 
      )     ; 
      =     #MSG_active; 
NETWORK
TITLE =Reset Time when State No changed and State out of range

      U(    ; 
      U(    ; 
      L     #iSNR; 
      L     #io_iMemSNR; 
      <>I   ; 
      )     ; 
      SPBNB _001; 
      L     #iSNR; 
      T     #io_iMemSNR; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
_001: U     BIE; 
      )     ; 
      UN    #MSG_active; 
      SPBNB _002; 
      L     L#0; 
      T     #io_dTime_TAKT; 
_002: NOP   0; 
NETWORK
TITLE =Count Time

      U     #MSG_active; 
      U     #TaktImpuls; 
      SPBNB _003; 
      L     #io_dTime_TAKT; 
      L     L#1; 
      +D    ; 
      T     #io_dTime_TAKT; 
_003: NOP   0; 
NETWORK
TITLE =Time 10xTakt

      L     #io_dTime_TAKT; 
      L     L#10; 
      /D    ; 
      T     #dTime_10xTakt; 
      NOP   0; 
NETWORK
TITLE =FC-ENO


      U     #MSG_active; 
      SAVE  ; 
END_FUNCTION

FUNCTION "m7b_GlobalParent_Mode" : VOID
TITLE =Get Global/Parent Control Mode
//Get the Global or Parent Control mode to set the device mode
//
//[IN]
//iGlobalMode: The Global Control Mode which sets the User Rights for operation
//             0: all operation allowed (OFF/ON/AUTO)
//             1: only HAND (OFF/ON) allowed, AUTO is disabled
//             2: Global Control AUTO; no user Operation allowed, set fix to AUTO
//
//iParentMode: The actual Mode of the Parent Control
//             The Child Device is controled with the Mode of the Parent Device
//             0: OFF (HAND_OFF)
//             1: ON  (HAND_ON)
//             2: AUTO
//
//cfg_Global_Parent: Select the Device Control Mode
//     FALSE : The Device is controled according to the Globel User Right's 
//             iGlobalMode is used to set the DeviceMode
//
//     TRUE :  The Device is controled directly/simultaneously with the mode of a
//             Parent Control. The Actual Device is a Child Device
//             iParentMode is used to set the DeviceMode
//
//ioHMIactivate: HMI Button OFF/ON/AUTO: 0=hide; 1=visible
//               In HMI, a click on the device (valve, motor ...) must toggle
//               this switch between 0 and 1.
//               Then the output HMI_ButtonStyle change between visible and
//               unvisible. 
//               This function helps to not confuse the user with tons of 
//               visible buttons.
//               If manual operation is enabled, the user must click on the device
//               to show the manual operation button for the device.
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 9/2018
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//20.11.2019   S.Maag    Seperate HMI_Button "ioHMIactive" to activate and 
//                       deactivate the OFF_ON_AUTO Button.
//                       In HMI, a click on the device (valve, motor ...) must 
//                       toggle this switch between 0 and 1.
//                       
//                       Outuput "HMI_Button_Style" to control OFF_ON_AUTO 
//                       Button style.
//--------------------------------------------------------------------------------
//
//HINWEISE:
//             Use this mode, if you want to control maybe a valve 
//             simultan with a Pump.           
//            
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  iGlobalMode : INT ;	//0: Allow all / 1: Global HAND (AUTO forbidden) / 2: Global AUTO
  iParentMode : INT ;	//Mode of the Parent Control
  cfg_Global_Parent : BOOL ;	//0: Device controled by Global Control; 1:=Device conrolled by Parent Device
END_VAR
VAR_OUTPUT
  SET_OFF : BOOL ;	
  SET_HAND : BOOL ;	
  SET_AUTO : BOOL ;	//Set Device Mode fix to AUTO (User operation HAND OFF/ON not allowed)
  ENABLE_AUTO : BOOL ;	//Enable the AUTO MODE selection for the User
  HMI_ButtonStyle : INT ;	//Value to display HMI Button (0: All; 1: OFF/ON; 2: Hide)
END_VAR
VAR_IN_OUT
  ioHMIactivate : INT ;	//HMI Button OFF/ON/AUTO: 0=hide; 1=visible
END_VAR
BEGIN
NETWORK
TITLE =
//0 : Allow all User Operation
//1 : Global Hand Mode (dont allow Auto Operation)
//2 : Global Auto Mode


NETWORK
TITLE =ENABLE AUTO
//in Mode 0 user can operate all (OFF/ON/AUTO)
//in Mode 2 user can't operate anything (Set the device fix to AUTO)
//          so Auto must be ENABLED


      O(    ; 
      L     #iGlobalMode; 
      L     0; 
      ==I   ; 
      )     ; 
      O(    ; 
      L     #iGlobalMode; 
      L     2; 
      ==I   ; 
      )     ; 
      O     #cfg_Global_Parent; 
      =     #ENABLE_AUTO; 
NETWORK
TITLE =Set the Device to AUTO
//In GlobalControl Mode 2 user can't operate anything (Set the device fix to AUTO)
//In ParentMode : Set AUTO if Parent is AUTO
      UN    #cfg_Global_Parent; 
      U(    ; 
      L     #iGlobalMode; 
      L     2; 
      ==I   ; 
      )     ; 
      O     ; 
      U     #cfg_Global_Parent; 
      U(    ; 
      L     #iParentMode; 
      L     2; 
      ==I   ; 
      )     ; 
      =     #SET_AUTO; 
NETWORK
TITLE =IF Parent Control: Set HAND
//If ParentControl AND Parent.Mode=1 THEN SET_HAND
      U     #cfg_Global_Parent; 
      U(    ; 
      L     #iParentMode; 
      L     1; 
      ==I   ; 
      )     ; 
      =     #SET_HAND; 
NETWORK
TITLE =IF Parent Control: Set OFF
//If ParentControl AND Parent.Mode=0 THEN SET_OFF
      U     #cfg_Global_Parent; 
      U(    ; 
      L     #iParentMode; 
      L     0; 
      ==I   ; 
      )     ; 
      =     #SET_OFF; 
NETWORK
TITLE =HMI activate Button
//======================================================================
//                    HMI activate Button
//======================================================================
//
//with click on the device (valve, motor) the HMI activate button is
//switched on/off. With activated signal, the button for OFF/ON/AUTO
//is visible.
NETWORK
TITLE =Switch off HMI_activate Button
//If GlobalMode = 2  (user can operate nothing)
//   AND HMIactivate = 1  (Activate Button is ON)
//
//THEN
//   HMIactivate = 0   (Swtich Off activate Button, because operation
//                      is not allowed.)
//
//END_IF
      U(    ; 
      L     #iGlobalMode; 
      L     2; 
      ==I   ; 
      )     ; 
      U(    ; 
      L     #ioHMIactivate; 
      L     1; 
      ==I   ; 
      )     ; 
      SPBNB _001; 
      L     0; 
      T     #ioHMIactivate; 
_001: NOP   0; 
NETWORK
TITLE =If HMI Button is activated: HMI_ButtonStyle=GlobalMode

      U(    ; 
      L     #ioHMIactivate; 
      L     1; 
      ==I   ; 
      )     ; 
      SPBNB _002; 
      L     #iGlobalMode; 
      T     #HMI_ButtonStyle; 
_002: NOP   0; 
NETWORK
TITLE =If HMI Button is deactivated: HMI_ButtonStyle=2 (hide Button)

      U(    ; 
      L     #ioHMIactivate; 
      L     0; 
      ==I   ; 
      )     ; 
      SPBNB _003; 
      L     2; 
      T     #HMI_ButtonStyle; 
_003: NOP   0; 
END_FUNCTION

FUNCTION "m7b_RP_FILL_INT" : VOID
TITLE =Ringpuffer mit Wert fuellen
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2017
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  DB_RP : BLOCK_DB ;	
  iFillVavlue : INT ;	//Fuellwert
  idxSTART : INT ;	//Start bei Index (0..255)
  iAnzahl : INT ;	//Anzahl zu schreibender Werte (0..256)
  cfg_REV_FWD : BOOL ;	//Konfiguration Richtung: 0: Füllen rückwärts; 1: füllen vorwärts
END_VAR
VAR_TEMP
  tmpLOP : INT ;	
  tmpPtr : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =

      CLR   ; 
      SAVE  ; 

NETWORK
TITLE =

      AUF   #DB_RP; // Ringpuffer DB öffnen

      L     #idxSTART; 
      T     #tmpPtr; 


      L     #iAnzahl; 
      L     0; 
      <=I   ; 
      SPB   END; // Wenn Anzahl <=0, dann nichts tun => ENDE

      L     #iAnzahl; 
      L     256; 
      >I    ; 
      SPB   LOOP; // Wenn >256, dann auf 256 begrenzen
      TAK   ; 
LOOP: T     #tmpLOP; // Schleifenzaehler
      L     #tmpPtr; // Indexwert Ringpuffer 0..255
      PUSH  ; // copy tmpPtr to AKKU2
      U     #cfg_REV_FWD; // Wenn fuellen vorwaerts
      SPB   fwd; 
      DEC   1; // tmpPtr-- (255..0); fuellen rueckwaerts
      SPA   save; 
fwd:  INC   1; // tmpPtr++ (0..255); fuellen vorwaerts
save: T     #tmpPtr; 
      TAK   ; // org tmpPtr => AKKU 1
      SLD   4; // SLD 1 wegen INT-Werten=>Byte + SLD 3 wegen Pointer
      L     P#0.0; // 0-Pointer addieren
      +D    ; // Pointer auf Daten erzeugen
      LAR1  ; // in Adressregister 1 laden

      L     #iFillVavlue; // Eingangswert laden
      T     DBW [AR1,P#0.0]; // in DB speichern

      L     #tmpLOP; // Schleifenzaehler
      LOOP  LOOP; // LOOP:= AKKU 1, springe wenn <>0

      SET   ; 
      SAVE  ; 
      CLR   ; 
END:  NOP   0; 
END_FUNCTION

FUNCTION "m7b_POSITONIEREN_REAL" : VOID
TITLE =Positionierrichtung Achse ermitteln. Position ok ausgeben
//Dieser FC ermittelt die Positonierrichtung von Achsen (vorw./rückw.)
//
//TOL_POS : Ist die zuslässige Positionsdifferenz, ab der die Achse zum
//          nachpositionieren anfängt
//
//TOL_POS_OK : Ist die zulässige Toleranz bis zu der gemeldet wird, dass
//             die Achse im gültigen Positiosfenster steht
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 12/2012
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
//Funktion identisch FC96 Positionierrichtung DINT
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  FRG : BOOL ;	//Freigabe
  SOLL : REAL ;	//Sollwert
  IST : REAL ;	//Istwert Achse
  TOL_POS_OK : REAL ;	//Toleranz für Position ok Meldung
  TOL_POS : REAL ;	//Toleranz Posiitionierung Achse
END_VAR
VAR_OUTPUT
  PLUS : BOOL ;	
  MINUS : BOOL ;	
  POS_OK : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =Postion Achse prüfen, Positionsdifferenz

      L     #SOLL; // aktuelle Sollposition
      L     #IST; // aktuelle Istposition
      -R    ; // Positionierdifferenz
      SPP   PLUS; 
      NEGR  ; // nach positiv

PLUS: L     #TOL_POS_OK; // Toleranz für Position ok
      <R    ; 
      =     #POS_OK; // Ausgang Position ok

      TAK   ; // Positionsdifferenz in AKKU1
      L     #TOL_POS; // Toleranz für Positionierung
      <R    ; 
      SAVE  ; 
      SPB   STOP; // Innerhalb Toleranz, dann Stop

NETWORK
TITLE =FREIGABE

      UN    #FRG; // keine Freigabe, dann Stop
      SPB   STOP; 

NETWORK
TITLE =Postionierrichtung vorw. oder rückw.

      L     #SOLL; // Soll
      L     #IST; // IST
      >R    ; 
      SPB   VW; // Soll > Ist, dann vw
      SPA   RW; // sonst rw
NETWORK
TITLE =Richtungsausgänge setzen

STOP: R     #PLUS; 
      R     #MINUS; 
      BEA   ; 

VW:   R     #MINUS; 
      S     #PLUS; 
      BEA   ; 

RW:   R     #PLUS; 
      S     #MINUS; 
      BE    ; 
END_FUNCTION

FUNCTION_BLOCK "m7b_6x_MSG_QUITT"
TITLE =6 Meldungen mit Quittierung
//6 Meldungen speichernd verarbeiten.
//
//cfg_HIDE: ist der Konfigurationseingang cfg_HIDE Hi, dann werden Meldungen
//          Folgemeldungen ausgeblendet. D.h. Meldung die weiter oben steht
//          sperrt nachfolgende.
//
//Quittierung mit RESET (für Autoquittierung RESET:=TRUE)
//
//Verwendung:
//Motoren mit mehreren Störmeldungen (Motorschutzschalter, Endschalter)
//(Pumpen mit Trockenlaufschutz, Drucküberwachung)
//
//FB-ENO: TRUE
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2012
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//16.03.2020   S.Maag     FC.ENO = UN IN_MSG0 .. IN MSG5 (kein Meldeeingang aktiv)
//                        dies kann verwendet werden, um AutoReset nach Zeit
//                        durchzuführen, wenn alle Fehlermeldungen aus!
//
//03.09.2018   S.Maag     FC.ENO = TRUE; (war FC.ENO=MSG_OK)
//
//17.10.2014   S.Maag     Ab MSG_3 das F für Folgemeldung entfernt, da schon
//                        seit beginn alle Meldungen als Folgemeldung abgeschaltet
//                        werden können.
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  IN_MSG_0 : BOOL ;	//Signal Meldung 0: 
  IN_MSG_1 : BOOL ;	//Signal Meldung 1: 
  IN_MSG_2 : BOOL ;	//Signal Meldung 2: 
  IN_MSG_3 : BOOL ;	//Signal Meldung 3: 
  IN_MSG_4 : BOOL ;	//Signal Meldung 4: 
  IN_MSG_5 : BOOL ;	//Signal Meldung 5: 
  RESET : BOOL ;	//RESET: für Autoquittierung fest auf Hi
  cfg_HIDE : BOOL ;	//Konfigurationseingang Folgemeldungen ausblenden
END_VAR
VAR_OUTPUT
  OUT_MSG_0 : BOOL ;	//Ausgang Meldung 0
  OUT_MSG_1 : BOOL ;	//Ausgang Meldung 1
  OUT_MSG_2 : BOOL ;	//Ausgang Meldung 2
  OUT_MSG_3 : BOOL ;	//Ausgang Meldung 3
  OUT_MSG_4 : BOOL ;	//Ausgang Meldung 4
  OUT_MSG_5 : BOOL ;	//Ausgang Meldung 5
  OUT_MSG : BOOL ;	//Sammelmeldung: True, wenn Meldung vorhanden
  OUT_OK : BOOL ;	//Keine Meldung: True, wenn keine Meldung aktiv
  FLAGS : BYTE ;	//Meldebits gesammelt in Byte
END_VAR
VAR_TEMP
  HM_MSG_ON : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =Meldung 0

      U     #RESET; 
      R     #OUT_MSG_0; 
      U     #IN_MSG_0; 
      S     #OUT_MSG_0; 
      NOP   0; 
NETWORK
TITLE =Meldung 1

      U     #RESET; 
      R     #OUT_MSG_1; 
      U(    ; 
      ON    #OUT_MSG_0; 
      ON    #cfg_HIDE; 
      )     ; 
      U     #IN_MSG_1; 
      S     #OUT_MSG_1; 
      NOP   0; 
NETWORK
TITLE =Meldung 2

      U     #RESET; 
      R     #OUT_MSG_2; 
      U(    ; 
      UN    #OUT_MSG_0; 
      UN    #IN_MSG_1; 
      ON    #cfg_HIDE; 
      )     ; 
      U     #IN_MSG_2; 
      S     #OUT_MSG_2; 
      NOP   0; 
NETWORK
TITLE =eine Meldung 0..2 aktiv

      O     #OUT_MSG_0; 
      O     #OUT_MSG_1; 
      O     #OUT_MSG_2; 
      =     #HM_MSG_ON; 
NETWORK
TITLE =Meldung 3:
//Meldung ist abhängig von Vorgängermeldungen, wird nicht aktiviert, wenn bereits 
//Vorgängermeldung vorhanden ist
      U     #RESET; 
      R     #OUT_MSG_3; 
      U(    ; 
      ON    #HM_MSG_ON; 
      ON    #cfg_HIDE; 
      )     ; 
      U     #IN_MSG_3; 
      S     #OUT_MSG_3; 
      NOP   0; 
NETWORK
TITLE =Meldung 4:
//Meldung ist abhängig von Vorgängermeldungen, wird nicht aktiviert, wenn bereits 
//Vorgängermeldung vorhanden ist
      U     #RESET; 
      R     #OUT_MSG_4; 
      U(    ; 
      UN    #HM_MSG_ON; 
      UN    #OUT_MSG_3; 
      ON    #cfg_HIDE; 
      )     ; 
      U     #IN_MSG_4; 
      S     #OUT_MSG_4; 
      NOP   0; 
NETWORK
TITLE =Meldung 5:
//Meldung ist abhängig von Vorgängermeldungen, wird nicht aktiviert, wenn bereits 
//Vorgängermeldung vorhanden ist
      U     #RESET; 
      R     #OUT_MSG_5; 
      U(    ; 
      UN    #HM_MSG_ON; 
      UN    #OUT_MSG_3; 
      UN    #OUT_MSG_4; 
      ON    #cfg_HIDE; 
      )     ; 
      U     #IN_MSG_5; 
      S     #OUT_MSG_5; 
      NOP   0; 
NETWORK
TITLE =Sammelmeldung

      O     #OUT_MSG_0; 
      O     #OUT_MSG_1; 
      O     #OUT_MSG_2; 
      O     #OUT_MSG_3; 
      O     #OUT_MSG_4; 
      O     #OUT_MSG_5; 
      =     #OUT_MSG; 
NETWORK
TITLE =Ausgang: keine Meldung (Out_NoMsg) und FB-ENO

      UN    #OUT_MSG; 
      =     #OUT_OK; 
NETWORK
TITLE =ENO = kein Meldeeingang aktiv
//16.03.2020 S.Maag
//
//Dies kann verwendet werden, um herauszufinden, wenn alle Meldeeingaenge wieder 
//FALSE sind. Damit kann man dann z.B. einen AutoReset nach Zeit durchführen.
      UN    #IN_MSG_0; 
      UN    #IN_MSG_1; 
      UN    #IN_MSG_2; 
      UN    #IN_MSG_3; 
      UN    #IN_MSG_4; 
      UN    #IN_MSG_5; 
      SAVE  ; 
NETWORK
TITLE =OUT MSG [0..7] als Byte nach Flags kopieren
//S.Maag 12.10.2012
//
//direktes laden über 
//
//      L     P##OUT_MSG_0
//      LAR1  
//      L     B [AR1,P#0.0]
//      T     #FLAGS
//
//funktioniert nich, da die Pointeradresse relativ zu den Instanzdaten ist
      L     B [AR2,P#2.0]; // in AR2 befindest sich immer der Pointer auf STAT Daten
      T     #FLAGS; // d.h. STAT Byte 2 laden und nach FLAGs


END_FUNCTION_BLOCK

FUNCTION_BLOCK "m7b_DelayedNiveau_REAL"
TITLE =Niveau-Schalter mit Min/Max Hysterese, Min- oder Max- schaltend 
//Niveau-Schalter mit Delay, Min/Max Hysterese und Funktion Min- oder Max- 
//schaltend 
//
//VERWENDUNG:
//2-Punkt-Regler
//Befüllen oder entleeren von Tanks mit Füllstandsmesser
//Heizen bzw. kühlen
//
//VALUE : Istwert (Temperatur, Druck, Füllstand ...)
//MIN   : Minimalwert (Ein bei Min-schaltend bzw. Aus bei Max-schaltend)
//MAX   : Maximalwert (Aus bei Min-schaltend bzw. Ein bei Max-schaltend)
//
//Fkt_Min_Max:
//  0 = Minimumschaltend
//      Beim Minimum wird eingeschaltet bis das Maximum erreicht ist, dann aus
//      (z.B. befüllen, heizen)    
//
//  1 = Maximumschaltend
//      Beim Maximu wird eingeschaltet bis das Minimum erreicht ist, dann aus
//      (z.B. entleeren, kühlen)
//
//OUT : Schaltsignal
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2013
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//28.08.2013   S.Maag      RESET-Eingang hinzugefügt
//--------------------------------------------------------------------------------
//
//HINWEISE: enstand aus FC84 'm7b_NiveauSchalter_REAL'
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  rVALUE : REAL ;	//Istwert
  rMIN : REAL ;	//Minimalwert Hysterese
  rMAX : REAL ;	//Maximalwert Hysterese
  cfg_Min_Max : BOOL ;	//0=MinSchaltend (z.B. befüllen, heizen) 1=MaxSchaltend (z.B. entleeren, kühlen)
  cfg_DELAY_OFF : BOOL ;	//TRUE: deaktiviert ON & OFF Verzögerung (für Programmgesteuerte Deaktivierung)
  RESET : BOOL ;	//RESET: löscht Ausgang
  timDelayOn : TIME ;	//Einschaltverzögerung: bei T=0 deaktiviert => unverz. schalten
  timDelayOff : TIME ;	//Ausschaltverzögerung: bei T=0 deaktiviert => unverz. schalten
END_VAR
VAR_OUTPUT
  OUT : BOOL ;	//Hilfsbit, Hilfmerker
  OnDelay : BOOL ;	
  OffDelay : BOOL ;	
  DSP_TIMER : TIME ;	//Anzeige Restlaufzeit bis schalten
END_VAR
VAR
  timDELAY : TIME ;	
  TON_DELAY : "TON";	
  Q_TON_DELAY : BOOL ;	
  Q_DELAY : BOOL ;	
  VAL_MIN : BOOL ;	
  VAL_MAX : BOOL ;	
END_VAR
VAR_TEMP
  ET_TIMER : TIME ;	
END_VAR
BEGIN
NETWORK
TITLE =VALUE <= MIN
//Minimalwert erreicht:
//Einschaltpunkt bei Minimum schaltend
//Ausschaltpunkt bei Maximum schaltend
      L     #rVALUE; 
      L     #rMIN; 
      <=R   ; 
      =     #VAL_MIN; 
NETWORK
TITLE =VALUE >= MAX
//Maximalwert erreicht:
//Einschaltpunkt bei Maximum schaltend
//Ausschaltpunkt bei Minimum schaltend
      L     #rVALUE; 
      L     #rMAX; 
      >=R   ; 
      =     #VAL_MAX; 
NETWORK
TITLE =DELAY_ON : Einschaltverzögerung aktiv

      U(    ; 
      U(    ; 
      UN    #cfg_Min_Max; 
      U     #VAL_MIN; 
      O     ; 
      U     #cfg_Min_Max; 
      U     #VAL_MAX; 
      )     ; 
      UN    #OUT; 
      SPBNB _001; 
      L     #timDelayOn; 
      T     #timDELAY; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
_001: U     BIE; 
      )     ; 
      UN    #cfg_DELAY_OFF; 
      UN    #RESET; 
      =     #OnDelay; 
NETWORK
TITLE =DELAY_OFF : Ausschaltverzögerung aktiv

      U(    ; 
      U(    ; 
      UN    #cfg_Min_Max; 
      U     #VAL_MAX; 
      O     ; 
      U     #cfg_Min_Max; 
      U     #VAL_MIN; 
      )     ; 
      U     #OUT; 
      SPBNB _002; 
      L     #timDelayOff; 
      T     #timDELAY; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
_002: U     BIE; 
      )     ; 
      UN    #cfg_DELAY_OFF; 
      UN    #RESET; 
      =     #OffDelay; 
NETWORK
TITLE =Verzögerungszeit
//Falls DelayTime=0, muss Q_DELAY Hi werden.
//Da IEC-Timer bei T=0 einen RESET ausführen und Q=Lo ist, muss dieser Fall 
//abgefangen werden.
//
      U(    ; 
      U(    ; 
      O     #OnDelay; 
      O     #OffDelay; 
      )     ; 
      =     L      4.0; 
      BLD   103; 
      CALL #TON_DELAY (
           IN                       := L      4.0,
           PT                       := #timDELAY,
           Q                        := #Q_TON_DELAY,
           ET                       := #ET_TIMER);
      U     BIE; 
      )     ; 
      U(    ; 
      O     #Q_TON_DELAY; 
      O     #cfg_DELAY_OFF; 
      O(    ; 
      L     #timDELAY; 
      L     0; 
      ==D   ; 
      )     ; 
      )     ; 
      =     #Q_DELAY; 
NETWORK
TITLE =Anzeige Restlaufzeit TIMER

      L     #timDELAY; 
      L     #ET_TIMER; 
      -D    ; 
      T     #DSP_TIMER; 
      NOP   0; 
NETWORK
TITLE =Funktion: Minimum/Maximum schaltend
//Funktion: Minimum schaltend (z.B. befüllen, heizen)
//Bei Erreichen des Minimums wird eingeschaltet, bis das 
//Maximum erreicht ist, dann wird ausgeschaltet.
//
//Funktion: Maximum schaltend (z.B. entleeren, kühlen)
//Bei Erreichen des Maximus wird eingeschaltet, bis das 
//Minimum wieder erreicht ist, dann wird ausgeschaltet.
      U(    ; 
      UN    #cfg_Min_Max; 
      U     #VAL_MIN; 
      O     ; 
      U     #cfg_Min_Max; 
      U     #VAL_MAX; 
      )     ; 
      U     #Q_DELAY; 
      S     #OUT; 
      U(    ; 
      U(    ; 
      UN    #cfg_Min_Max; 
      U     #VAL_MAX; 
      O     ; 
      U     #cfg_Min_Max; 
      U     #VAL_MIN; 
      )     ; 
      U     #Q_DELAY; 
      O     #RESET; 
      )     ; 
      R     #OUT; 
      NOP   0; 
NETWORK
TITLE =FB-ENO := TRUE

      SET   ; 
      SAVE  ; 
      CLR   ; 

END_FUNCTION_BLOCK

FUNCTION_BLOCK "m7b_DelayedNiveau_INT"
TITLE =Niveau-Schalter mit Min/Max Hysterese, Min- oder Max- schaltend 
//Niveau-Schalter mit Delay, Min/Max Hysterese und Funktion Min- oder Max- 
//schaltend 
//
//VERWENDUNG:
//2-Punkt-Regler
//Befüllen oder entleeren von Tanks mit Füllstandsmesser
//Heizen bzw. kühlen
//
//VALUE : Istwert (Temperatur, Druck, Füllstand ...)
//MIN   : Minimalwert (Ein bei Min-schaltend bzw. Aus bei Max-schaltend)
//MAX   : Maximalwert (Aus bei Min-schaltend bzw. Ein bei Max-schaltend)
//
//Fkt_Min_Max:
//  0 = Minimumschaltend
//      Beim Minimum wird eingeschaltet bis das Maximum erreicht ist, dann aus
//      (z.B. befüllen, heizen)    
//
//  1 = Maximumschaltend
//      Beim Maximu wird eingeschaltet bis das Minimum erreicht ist, dann aus
//      (z.B. entleeren, kühlen)
//
//OUT : Schaltsignal
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2013
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE: enstand aus FC84 'm7b_NiveauSchalter_REAL'
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  iVALUE : INT ;	//Istwert
  iMIN : INT ;	//Minimalwert Hysterese
  iMAX : INT ;	//Maximalwert Hysterese
  cfg_Min_Max : BOOL ;	//0=MinSchaltend (z.B. befüllen, heizen) 1=MaxSchaltend (z.B. entleeren, kühlen)
  DELAY_OFF : BOOL ;	//TRUE: deaktiviert ON & OFF Verzögerung (für Programmgesteuerte Deaktivierung)
  timDelayOn : TIME ;	//Einschaltverzögerung: bei T=0 deaktiviert => unverz. schalten
  timDelayOff : TIME ;	//Ausschaltverzögerung: bei T=0 deaktiviert => unverz. schalten
END_VAR
VAR_OUTPUT
  OUT : BOOL ;	//Hilfsbit, Hilfmerker
  OnDelay : BOOL ;	
  OffDelay : BOOL ;	
  DSP_TIMER : TIME ;	//Anzeige Restlaufzeit bis schalten
END_VAR
VAR
  timDELAY : TIME ;	
  TON_DELAY : "TON";	
  Q_TON_DELAY : BOOL ;	
  Q_DELAY : BOOL ;	
  VAL_MIN : BOOL ;	
  VAL_MAX : BOOL ;	
END_VAR
VAR_TEMP
  ET_TIMER : TIME ;	
END_VAR
BEGIN
NETWORK
TITLE =VALUE <= MIN
//Minimalwert erreicht:
//Einschaltpunkt bei Minimum schaltend
//Ausschaltpunkt bei Maximum schaltend
      L     #iVALUE; 
      L     #iMIN; 
      <=I   ; 
      =     #VAL_MIN; 
NETWORK
TITLE =VALUE >= MAX
//Maximalwert erreicht:
//Einschaltpunkt bei Maximum schaltend
//Ausschaltpunkt bei Minimum schaltend
      L     #iVALUE; 
      L     #iMAX; 
      >=I   ; 
      =     #VAL_MAX; 
NETWORK
TITLE =DELAY_ON : Einschaltverzögerung aktiv

      U(    ; 
      U(    ; 
      UN    #cfg_Min_Max; 
      U     #VAL_MIN; 
      O     ; 
      U     #cfg_Min_Max; 
      U     #VAL_MAX; 
      )     ; 
      UN    #OUT; 
      SPBNB _001; 
      L     #timDelayOn; 
      T     #timDELAY; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
_001: U     BIE; 
      )     ; 
      UN    #DELAY_OFF; 
      =     #OnDelay; 
NETWORK
TITLE =DELAY_OFF : Ausschaltverzögerung aktiv

      U(    ; 
      U(    ; 
      UN    #cfg_Min_Max; 
      U     #VAL_MAX; 
      O     ; 
      U     #cfg_Min_Max; 
      U     #VAL_MIN; 
      )     ; 
      U     #OUT; 
      SPBNB _002; 
      L     #timDelayOff; 
      T     #timDELAY; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
_002: U     BIE; 
      )     ; 
      UN    #DELAY_OFF; 
      =     #OffDelay; 
NETWORK
TITLE =Verzögerungszeit
//Falls DelayTime=0, muss Q_DELAY Hi werden.
//Da IEC-Timer bei T=0 einen RESET ausführen und Q=Lo ist, muss dieser Fall 
//abgefangen werden.
//
      U(    ; 
      U(    ; 
      O     #OnDelay; 
      O     #OffDelay; 
      )     ; 
      =     L      4.0; 
      BLD   103; 
      CALL #TON_DELAY (
           IN                       := L      4.0,
           PT                       := #timDELAY,
           Q                        := #Q_TON_DELAY,
           ET                       := #ET_TIMER);
      U     BIE; 
      )     ; 
      U(    ; 
      O     #Q_TON_DELAY; 
      O     #DELAY_OFF; 
      O(    ; 
      L     #timDELAY; 
      L     0; 
      ==D   ; 
      )     ; 
      )     ; 
      =     #Q_DELAY; 
NETWORK
TITLE =Anzeige Restlaufzeit TIMER

      L     #timDELAY; 
      L     #ET_TIMER; 
      -D    ; 
      T     #DSP_TIMER; 
      NOP   0; 
NETWORK
TITLE =Funktion: Minimum/Maximum schaltend
//Funktion: Minimum schaltend (z.B. befüllen, heizen)
//Bei Erreichen des Minimums wird eingeschaltet, bis das 
//Maximum erreicht ist, dann wird ausgeschaltet.
//
//Funktion: Maximum schaltend (z.B. entleeren, kühlen)
//Bei Erreichen des Maximus wird eingeschaltet, bis das 
//Minimum wieder erreicht ist, dann wird ausgeschaltet.
      U(    ; 
      UN    #cfg_Min_Max; 
      U     #VAL_MIN; 
      O     ; 
      U     #cfg_Min_Max; 
      U     #VAL_MAX; 
      )     ; 
      U     #Q_DELAY; 
      S     #OUT; 
      U(    ; 
      UN    #cfg_Min_Max; 
      U     #VAL_MAX; 
      O     ; 
      U     #cfg_Min_Max; 
      U     #VAL_MIN; 
      )     ; 
      U     #Q_DELAY; 
      R     #OUT; 
      NOP   0; 
NETWORK
TITLE =FB-ENO := TRUE

      SET   ; 
      SAVE  ; 
      CLR   ; 

END_FUNCTION_BLOCK

FUNCTION_BLOCK "FIFO_INT_MIT_STARTW"
TITLE =FIFO mit Startwert, Summen und Mittelwertbildung
//mit diesem FB lassen sich verwirklichen:
//  - Delays, Pufferung nach dem FIFO-Prinzip
//  - Integratoren
//  - Mittelwertbildung, Dämpfungsglieder
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 5/2003
//
//HINWEIS: 
AUTHOR : 'S.Maag'
FAMILY : 'STANDARD'
VERSION : 0.1


VAR_INPUT
  WRITE : BOOL ;	//Wert in FIFO schreiben, Freigabe für Aufzeichung
  DBNr : INT ;	//Datenbaustein für FIFO
  StartAdr : INT ;	//Startadresse des ersten FIFO Eintrags im DB
  AnzahlWerte : INT ;	//Anzahl der Werte, Größe des FIFO
  FIFO_IN : INT ;	//aktueller Eingangswert der im FIFO gespeichert wird
  STARTWERT : INT ;	
  RESET : BOOL ;	//FIFO zurückstellen
END_VAR
VAR_OUTPUT
  FIFO_OUT : INT ;	//Ausgangswert des FIFO
  Summe : DINT ;	//aktuelle Summe aller Werte im FIFO
  MittelWert : INT ;	//aktueller Mittelwert
  FIFO_VOLL : BOOL ;	//FIFO ist vollständig gefüllt
END_VAR
VAR
  ptrFIFO : INT ;	//Hilfsariable zum Speichern des INPUT-Zeigers
END_VAR
VAR_TEMP
  tmpDB : INT ;	
  EndAdr : INT ;	
  AR1 : DWORD ;	
END_VAR
BEGIN
NETWORK
TITLE =RESET 

      UN    #RESET; 
      SPB   NE1; 
      R     #FIFO_VOLL; // FIFO ist leer

      L     #AnzahlWerte; 
      L     #STARTWERT; 
      T     #MittelWert; // Mittelwert = Startwert
      T     #FIFO_OUT; // FIFO_OUT = Startwert
      *D    ; 
      T     #Summe; // Summe=Startwert * AnzahlWerte

      L     #StartAdr; // StartAdresse im DB
      T     #ptrFIFO; // ptrFIFO_IN und

      SLD   3; // Pointer ins Bitformat
      LAR1  ; 

      L     #DBNr; // DBNr
      T     #tmpDB; 
      AUF   DB [#tmpDB]; // DB öffnen

// FIFO in Schleife mit Startwerten füllen
      L     #STARTWERT; // Startwert laden
      L     #AnzahlWerte; // als SchleifenZähler laden
LOOP: TAK   ; // STARTWERT in Akku1 zurück (wegen LOOP)
      T     DBW [AR1,P#0.0]; // Startwert in FIFO eintragen
      +AR1  P#2.0; // Pointer in AR1 auf nächsten Eintrag
      TAK   ; // Schleifenzähler in Akku 1
      LOOP  LOOP; // Schleifensteuerung
      BEA   ; 
NE1:  NOP   0; 

NETWORK
TITLE =Schreibbefehl auswerten und Baustein gegenfalls verlassen

      UN    #WRITE; // Wenn kein Schreibbefehl, dann ENDE
      BEB   ; 

NETWORK
TITLE =DB öffnen und EndAdresse Datenbereich berechnen

      L     #DBNr; // DBNr
      T     #tmpDB; 
      AUF   DB [#tmpDB]; // DB öffnen

      L     #AnzahlWerte; // Anzahl der Werte
      +     -1; // in Byte-Offset
      SLW   1; // konvertieren
      L     #StartAdr; // und zu Startadresse addieren
      +I    ; 
      T     #EndAdr; // Endadresse Datenbereich FIFO

      L     #ptrFIFO; // FIFO Pointer
      SLD   3; // ins BitFormat
      LAR1  ; // und ins AR1
NETWORK
TITLE =FIFO voll?

      U     #FIFO_VOLL; // Wenn FIFO schon voll, dann weiter im näschten NW
      SPB   NWE; 

// Eingangswert speichern und neue Summe berechnen
      L     #FIFO_IN; // Eingangswert
      T     DBW [AR1,P#0.0]; // speichern
      ITD   ; 
      L     #Summe; // neue Summe
      +D    ; // berechnen und speichern
      T     #Summe; 

// prüfen ob FIFO jetzt voll und Anzahl bereits enthaltener Werte berechnen
      L     #EndAdr; // Wenn ptrFIFO
      L     #ptrFIFO; // = EndAdr, dann ist FIFO voll
      ==I   ; 
      S     #FIFO_VOLL; // Meldung FIFO voll
      L     #StartAdr; // ptrFIFO-StartAdr = ByteDifferenz
      -I    ; 
      SRW   1; // /2 = Wortdifferenz
      +     1; // Anzahl der enthaltenen Einträge
// aktuellen Mittelwert berechnen
      L     #Summe; 
      TAK   ; // Wegen Division Akkus tauschen
      /D    ; // Summe / AnzahlWerteImFIFO
      T     #MittelWert; // Mittelwert ausgeben

      SPA   PTR; // FIFO Pointer nachführen

NWE:  NOP   0; 

NETWORK
TITLE =Letztwert aus FIFO entfernen, Summe und Mittelwert berechnen 

      L     DBW [AR1,P#0.0]; // letzten Wert, FIFO-Out laden
      T     #FIFO_OUT; // als Ausgangswert zurückgeben
      ITD   ; // zu DINT
      L     #Summe; // Summe laden
      TAK   ; // wegen Subtraktion, Akkus tauschen
      -D    ; // FIFO-Out von Summe abziehen

      L     #FIFO_IN; // Eingangswert
      T     DBW [AR1,P#0.0]; // speichern
      ITD   ; // FIFO_IN zu DINT
      +D    ; // Summe addieren
      T     #Summe; 
      L     #AnzahlWerte; // Anzahl der Werte
      /D    ; // Mittelwert berechnen
      T     #MittelWert; // Mittelwert speichern
NETWORK
TITLE =ptrFIFO auf nächsten Wert

PTR:  L     #EndAdr; // Vergleich mit Endadresse,
      L     #ptrFIFO; // Zeiger FIFO_IN auf nächsten Wert
      +     2; // +2, da ByteAdresse
      >=I   ; // solange EndAdr >, dann weitermachen
      SPB   OK; // mit neuem Pointer speichern
      L     #StartAdr; // sonst BereichsÜberlauf und weiter in StartAdr.
OK:   T     #ptrFIFO; // neuer Zeiger FIFO-IN  
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FIFO_INT"
TITLE =FIFO mit Summen und Mittelwertbildung
//mit diesem FC lassen sich verwirklichen:
//  - Delays, Pufferung nach dem FIFO-Prinzip
//  - Integratoren
//  - Mittelwertbildung, Dämpfungsglieder
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 5/2003
//
//HINWEIS: 
AUTHOR : 'S.Maag'
FAMILY : 'STANDARD'
VERSION : 0.1


VAR_INPUT
  DBNr : INT ;	//Datenbaustein für FIFO
  StartAdr : INT ;	//Startadresse des ersten FIFO Eintrags im DB
  AnzahlWerte : INT ;	//Anzahl der Werte, Größe des FIFO
  FIFO_IN : INT ;	//aktueller Eingangswert der im FIFO gespeichert wird
  RESET : BOOL ;	//FIFO zurückstellen
END_VAR
VAR_OUTPUT
  FIFO_OUT : INT ;	//Ausgangswert des FIFO
  Summe : DINT ;	//aktuelle Summe aller Werte im FIFO
  MittelWert : INT ;	//aktueller Mittelwert
  FIFO_VOLL : BOOL ;	//FIFO ist vollständig gefüllt
END_VAR
VAR
  ptrFIFO : INT ;	//Hilfsariable zum Speichern des INPUT-Zeigers
END_VAR
VAR_TEMP
  tmpDB : INT ;	
  EndAdr : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =RESET 

      UN    #RESET; 
      SPB   WEIT; 
      R     #FIFO_VOLL; // FIFO ist leer

      L     0; 
      T     #Summe; // Summe löschen
      T     #MittelWert; // Mittelwert löschen
      T     #FIFO_OUT; // Ausgangswert = 0

      L     #StartAdr; // StartAdresse für
      T     #ptrFIFO; // ptrFIFO_IN und
      BEA   ; 
WEIT: NOP   0; 

NETWORK
TITLE =DB öffnen und EndAdresse Datenbereich berechnen

      L     #DBNr; // DBNr
      T     #tmpDB; 
      AUF   DB [#tmpDB]; // DB öffnen

      L     #AnzahlWerte; // Anzahl der Werte
      +     -1; // in Byte-Offset
      SLW   1; // konvertieren
      L     #StartAdr; // und zu Startadresse addieren
      +I    ; 
      T     #EndAdr; // Endadresse Datenbereich FIFO

      L     #ptrFIFO; // FIFO Pointer
      SLD   3; // ins BitFormat
      LAR1  ; // und ins AR1
NETWORK
TITLE =FIFO voll?

      U     #FIFO_VOLL; // Wenn FIFO schon voll, dann weiter im näschten NW
      SAVE  ; 
      SPB   NWE; 

// Eingangswert speichern und neue Summe berechnen
      L     #FIFO_IN; // Eingangswert
      T     DBW [AR1,P#0.0]; // speichern
      ITD   ; 
      L     #Summe; // neue Summe
      +D    ; // berechnen und speichern
      T     #Summe; 

// prüfen ob FIFO jetzt voll und Anzahl bereits enthaltener Werte berechnen
      L     #EndAdr; // Wenn ptrFIFO
      L     #ptrFIFO; // = EndAdr, dann ist FIFO voll
      ==I   ; 
      S     #FIFO_VOLL; // Meldung FIFO voll
      L     #StartAdr; // ptrFIFOn-StartAdr = ByteDifferenz
      -I    ; 
      SRW   1; // /2 = Wortdifferenz
      +     1; // Anzahl der enthaltenen Einträge
// aktuellen Mittelwert berechnen
      L     #Summe; 
      TAK   ; // Wegen Division Akkus tauschen
      /D    ; // Summe / AnzahlWerteImFIFO
      T     #MittelWert; // Mittelwert ausgeben

      SPA   PTR; // FIFO Pointer nachführen

NWE:  NOP   0; 

NETWORK
TITLE =Letztwert aus FIFO entfernen, Summe und Mittelwert berechnen 

      L     DBW [AR1,P#0.0]; // letzten Wert, FIFO-Out laden
      T     #FIFO_OUT; // als Ausgangswert zurückgeben
      ITD   ; // zu DINT
      L     #Summe; // Summe laden
      TAK   ; // wegen Subtraktion, Akkus tauschen
      -D    ; // FIFO-Out von Summe abziehen

      L     #FIFO_IN; // Eingangswert
      T     DBW [AR1,P#0.0]; // speichern
      ITD   ; // FIFO_IN zu DINT
      +D    ; // Summe addieren
      T     #Summe; 
      L     #AnzahlWerte; // Anzahl der Werte
      /D    ; // Mittelwert berechnen
      T     #MittelWert; // Mittelwert speichern
NETWORK
TITLE =ptrFIFO auf nächsten Wert

PTR:  L     #EndAdr; // Vergleich mit Endadresse,
      L     #ptrFIFO; // Zeiger FIFO_IN auf nächsten Wert
      +     2; // +2, da ByteAdresse
      >=I   ; // solange EndAdr >, dann weitermachen
      SPB   OK; // mit neuem Pointer speichern
      L     #StartAdr; // sonst BereichsÜberlauf und weiter in StartAdr.
OK:   T     #ptrFIFO; // neuer Zeiger FIFO-IN  
END_FUNCTION_BLOCK

FUNCTION_BLOCK "m7b_FIFO_DINT_STARTWERT"
TITLE =FIFO DINT mit Startwert, Summen und Mittelwertbildung
//mit diesem FB lassen sich verwirklichen:
//  - Delays, Pufferung nach dem FIFO-Prinzip
//  - Integratoren
//  - Mittelwertbildung, Dämpfungsglieder
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 1/2022
//
//HINWEIS: 
//Entstand aus FIFO_INT_STARTWERT FB1121
AUTHOR : 'S.Maag'
FAMILY : 'STANDARD'
VERSION : 0.1


VAR_INPUT
  WRITE : BOOL ;	//Wert in FIFO schreiben, Freigabe für Aufzeichung
  BLK_DB : BLOCK_DB ;	//Datenbaustein für FIFO
  dStartAdr : DINT ;	//Startadresse des ersten FIFO Eintrags im DB
  dAnzahlWerte : INT ;	//Anzahl der Werte, Größe des FIFO
  dFIFO_IN : DINT ;	//aktueller Eingangswert der im FIFO gespeichert wird
  dStartWert : DINT ;	
  RESET : BOOL ;	//FIFO zurückstellen
END_VAR
VAR_OUTPUT
  FIFO_OUT : DINT ;	//Ausgangswert des FIFO
  Summe : DINT ;	//aktuelle Summe aller Werte im FIFO
  MittelWert : DINT ;	//aktueller Mittelwert
  FIFO_VOLL : BOOL ;	//FIFO ist vollständig gefüllt
END_VAR
VAR
  ptrFIFO : DINT ;	//Hilfsariable zum Speichern des INPUT-Zeigers
END_VAR
VAR_TEMP
  dEndAdr : DINT ;	
  AR1 : DWORD ;	
END_VAR
BEGIN
NETWORK
TITLE =RESET 

      UN    #RESET; 
      SPB   NE1; 
      R     #FIFO_VOLL; // FIFO ist leer

      L     #dAnzahlWerte; // Anzahl Werte [INT]
      L     #dStartWert; 
      T     #MittelWert; // Mittelwert = Startwert
      T     #FIFO_OUT; // FIFO_OUT = Startwert
      *D    ; 
      T     #Summe; // Summe=Startwert * AnzahlWerte

      L     #dStartAdr; // StartAdresse im DB
      T     #ptrFIFO; // ptrFIFO_IN und

      SLD   3; // Pointer ins Bitformat
      LAR1  ; 

      AUF   #BLK_DB; 
// FIFO in Schleife mit Startwerten füllen
      L     #dStartWert; // Startwert laden
      L     #dAnzahlWerte; // als SchleifenZähler laden
LOOP: TAK   ; // STARTWERT in Akku1 zurück (wegen LOOP)
      T     DBD [AR1,P#0.0]; // Startwert in FIFO eintragen
      +AR1  P#4.0; // Pointer in AR1 auf nächsten Eintrag
      TAK   ; // Schleifenzähler in Akku 1
      LOOP  LOOP; // Schleifensteuerung
      BEA   ; 
NE1:  NOP   0; 

NETWORK
TITLE =Schreibbefehl auswerten und Baustein gegenfalls verlassen

      UN    #WRITE; // Wenn kein Schreibbefehl, dann ENDE
      BEB   ; 

NETWORK
TITLE =DB öffnen und EndAdresse Datenbereich berechnen

      AUF   #BLK_DB; 
      L     #dAnzahlWerte; // Anzahl der Werte
      +     L#-1; // in Byte-Offset
      SLD   2; // konvertieren zu 4 Byte
      L     #dStartAdr; // und zu Startadresse addieren
      +D    ; 
      T     #dEndAdr; // Endadresse Datenbereich FIFO

      L     #ptrFIFO; // FIFO Pointer
      SLD   3; // ins BitFormat
      LAR1  ; // und ins AR1
NETWORK
TITLE =FIFO voll?

      U     #FIFO_VOLL; // Wenn FIFO schon voll, dann weiter im näschten NW
      SPB   NWE; 

// Eingangswert speichern und neue Summe berechnen
      L     #dFIFO_IN; // Eingangswert
      T     DBD [AR1,P#0.0]; // speichern
      L     #Summe; // neue Summe
      +R    ; // berechnen und speichern
      T     #Summe; 

// prüfen ob FIFO jetzt voll und Anzahl bereits enthaltener Werte berechnen
      L     #dEndAdr; // Wenn ptrFIFO
      L     #ptrFIFO; // = EndAdr, dann ist FIFO voll
      ==D   ; 
      S     #FIFO_VOLL; // Meldung FIFO voll
      L     #dStartAdr; // ptrFIFO-StartAdr = ByteDifferenz
      -D    ; 
      SRD   2; // /4 = DWorddifferenz
      +     L#1; // Anzahl der enthaltenen Einträge
      DTR   ; 
      L     #Summe; // aktuellen Mittelwert berechnen
      TAK   ; // Wegen Division Akkus tauschen
      /D    ; // Summe / AnzahlWerteImFIFO
      T     #MittelWert; // Mittelwert ausgeben

      SPA   PTR; // FIFO Pointer nachführen

NWE:  NOP   0; 

NETWORK
TITLE =Letztwert aus FIFO entfernen, Summe und Mittelwert berechnen 

      L     DBD [AR1,P#0.0]; // letzten Wert, FIFO-Out laden
      T     #FIFO_OUT; // als Ausgangswert zurückgeben
      L     #Summe; // Summe laden
      TAK   ; // wegen Subtraktion, Akkus tauschen
      -D    ; // FIFO-Out von Summe abziehen

      L     #dFIFO_IN; // Eingangswert
      T     DBD [AR1,P#0.0]; // speichern
      +D    ; // Summe addieren
      T     #Summe; 
      L     #dAnzahlWerte; // Anzahl der Werte
      /D    ; // Mittelwert berechnen
      T     #MittelWert; // Mittelwert speichern
NETWORK
TITLE =ptrFIFO auf nächsten Wert

PTR:  L     #dEndAdr; // Vergleich mit Endadresse,
      L     #ptrFIFO; // Zeiger FIFO_IN auf nächsten Wert
      +     4; // +4, da ByteAdresse
      >=D   ; // solange EndAdr >, dann weitermachen
      SPB   OK; // mit neuem Pointer speichern
      L     #dStartAdr; // sonst BereichsÜberlauf und weiter in StartAdr.
OK:   T     #ptrFIFO; // neuer Zeiger FIFO-IN  
END_FUNCTION_BLOCK

FUNCTION_BLOCK "m7b_FIFO_REAL_STARTWERT"
TITLE =FIFO REAL mit Startwert, Summen und Mittelwertbildung
//mit diesem FB lassen sich verwirklichen:
//  - Delays, Pufferung nach dem FIFO-Prinzip
//  - Integratoren
//  - Mittelwertbildung, Dämpfungsglieder
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 1/2022
//
//HINWEIS: 
//Entstand aus FIFO_INT_STARTWERT FB1121
AUTHOR : 'S.Maag'
FAMILY : 'STANDARD'
VERSION : 0.1


VAR_INPUT
  WRITE : BOOL ;	//Wert in FIFO schreiben, Freigabe für Aufzeichung
  BLK_DB : BLOCK_DB ;	//Datenbaustein für FIFO
  StartAdr : INT ;	//Startadresse des ersten FIFO Eintrags im DB
  iAnzahlWerte : INT ;	//Anzahl der Werte, Größe des FIFO
  FIFO_IN : REAL ;	//aktueller Eingangswert der im FIFO gespeichert wird
  STARTWERT : REAL ;	
  RESET : BOOL ;	//FIFO zurückstellen
END_VAR
VAR_OUTPUT
  FIFO_OUT : REAL ;	//Ausgangswert des FIFO
  Summe : REAL ;	//aktuelle Summe aller Werte im FIFO
  MittelWert : REAL ;	//aktueller Mittelwert
  FIFO_VOLL : BOOL ;	//FIFO ist vollständig gefüllt
END_VAR
VAR
  ptrFIFO : DINT ;	//Hilfsariable zum Speichern des INPUT-Zeigers
END_VAR
VAR_TEMP
  EndAdr : DINT ;	
  AR1 : DWORD ;	
END_VAR
BEGIN
NETWORK
TITLE =RESET 

      UN    #RESET; 
      SPB   NE1; 
      R     #FIFO_VOLL; // FIFO ist leer

      L     #iAnzahlWerte; // Anzahl Werte [INT]
      ITD   ; 
      DTR   ; 
      L     #STARTWERT; 
      T     #MittelWert; // Mittelwert = Startwert
      T     #FIFO_OUT; // FIFO_OUT = Startwert
      *R    ; 
      T     #Summe; // Summe=Startwert * AnzahlWerte

      L     #StartAdr; // StartAdresse im DB
      T     #ptrFIFO; // ptrFIFO_IN und

      SLD   3; // Pointer ins Bitformat
      LAR1  ; 

      AUF   #BLK_DB; // DBNr
// FIFO in Schleife mit Startwerten füllen
      L     #STARTWERT; // Startwert laden
      L     #iAnzahlWerte; // als SchleifenZähler laden
LOOP: TAK   ; // STARTWERT in Akku1 zurück (wegen LOOP)
      T     DBD [AR1,P#0.0]; // Startwert in FIFO eintragen
      +AR1  P#4.0; // Pointer in AR1 auf nächsten Eintrag
      TAK   ; // Schleifenzähler in Akku 1
      LOOP  LOOP; // Schleifensteuerung
      BEA   ; 
NE1:  NOP   0; 

NETWORK
TITLE =Schreibbefehl auswerten und Baustein gegenfalls verlassen

      UN    #WRITE; // Wenn kein Schreibbefehl, dann ENDE
      BEB   ; 

NETWORK
TITLE =DB öffnen und EndAdresse Datenbereich berechnen

      AUF   #BLK_DB; // DB öffnen
      L     #iAnzahlWerte; // Anzahl der Werte
      ITD   ; 
      +     L#-1; // in Byte-Offset
      SLD   2; // konvertieren zu 4 Byte
      L     #StartAdr; // und zu Startadresse addieren
      +D    ; 
      T     #EndAdr; // Endadresse Datenbereich FIFO

      L     #ptrFIFO; // FIFO Pointer
      SLD   3; // ins BitFormat
      LAR1  ; // und ins AR1
NETWORK
TITLE =FIFO voll?

      U     #FIFO_VOLL; // Wenn FIFO schon voll, dann weiter im näschten NW
      SPB   NWE; 

// Eingangswert speichern und neue Summe berechnen
      L     #FIFO_IN; // Eingangswert
      T     DBD [AR1,P#0.0]; // speichern
      L     #Summe; // neue Summe
      +R    ; // berechnen und speichern
      T     #Summe; 

// prüfen ob FIFO jetzt voll und Anzahl bereits enthaltener Werte berechnen
      L     #EndAdr; // Wenn ptrFIFO
      L     #ptrFIFO; // = EndAdr, dann ist FIFO voll
      ==D   ; 
      S     #FIFO_VOLL; // Meldung FIFO voll
      L     #StartAdr; // ptrFIFO-StartAdr = ByteDifferenz
      -D    ; 
      SRD   2; // /4 = DWorddifferenz
      +     L#1; // Anzahl der enthaltenen Einträge
      DTR   ; 
      L     #Summe; // aktuellen Mittelwert berechnen
      TAK   ; // Wegen Division Akkus tauschen
      /R    ; // Summe / AnzahlWerteImFIFO
      T     #MittelWert; // Mittelwert ausgeben

      SPA   PTR; // FIFO Pointer nachführen

NWE:  NOP   0; 

NETWORK
TITLE =Letztwert aus FIFO entfernen, Summe und Mittelwert berechnen 

      L     DBD [AR1,P#0.0]; // letzten Wert, FIFO-Out laden
      T     #FIFO_OUT; // als Ausgangswert zurückgeben
      L     #Summe; // Summe laden
      TAK   ; // wegen Subtraktion, Akkus tauschen
      -R    ; // FIFO-Out von Summe abziehen

      L     #FIFO_IN; // Eingangswert
      T     DBD [AR1,P#0.0]; // speichern
      +R    ; // Summe addieren
      T     #Summe; 
      L     #iAnzahlWerte; // Anzahl der Werte
      ITD   ; 
      DTR   ; 
      /R    ; // Mittelwert berechnen
      T     #MittelWert; // Mittelwert speichern
NETWORK
TITLE =ptrFIFO auf nächsten Wert

PTR:  L     #EndAdr; // Vergleich mit Endadresse,
      L     #ptrFIFO; // Zeiger FIFO_IN auf nächsten Wert
      +     4; // +4, da ByteAdresse
      >=D   ; // solange EndAdr >, dann weitermachen
      SPB   OK; // mit neuem Pointer speichern
      L     #StartAdr; // sonst BereichsÜberlauf und weiter in StartAdr.
OK:   T     #ptrFIFO; // neuer Zeiger FIFO-IN  
END_FUNCTION_BLOCK

FUNCTION_BLOCK "BCD_HAND_SCHALTER"
TITLE =4 Bit BCD verzögert zu 10 digitalen Ausgängen, nur einer aktiv
//Der BCD-Wert der Eingänge BCD0 bis BCD3 werden in 10 digitale Ausgänge, von 
//denen jeweils nur einer aktiv ist. Der neue BCD-Wert wird erst verzögert auf 
//die Ausgänge durchgeschaltet. Dies ist nötig, wenn man einen BCD-Codierschalter 
//hat und diesen als Wahlschalter zur Geräteanwahl verwendet, somit wird nicht 
//bei jedem Tastendruck gleich der Steuermerker geschaltet.
//
//Zum Umschaltzeitpunkt wir der ENO-Ausgang des Bausteins für 1 Zyklus HIGH 
//(Umschaltimpuls)
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 4/2005
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
VERSION : 0.1


VAR_INPUT
  BCD0 : BOOL ;	
  BCD1 : BOOL ;	
  BCD2 : BOOL ;	
  BCD3 : BOOL ;	
  DELAY : TIME ;	
END_VAR
VAR_OUTPUT
  Q0 : BOOL ;	
  Q1 : BOOL ;	
  Q2 : BOOL ;	
  Q3 : BOOL ;	
  Q4 : BOOL ;	
  Q5 : BOOL ;	
  Q6 : BOOL ;	
  Q7 : BOOL ;	
  Q8 : BOOL ;	
  Q9 : BOOL ;	
END_VAR
VAR
  AKT_BCD : BYTE ;	
  LAST_BCD_AKTIV : BYTE ;	
  LAST_BCD : BYTE ;	
  CHANGE_TIME : TIME ;	
  TON : "TON";	
END_VAR
VAR_TEMP
  DIFF : BOOL ;	
  QT : BOOL ;	
  NODIFF : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =
//Wenn der Baustein als Multiinstanzaufruf verwendet wird kann nicht mit 
//L DIB 0 gearbeitet werden, da es sich beim Multiinstanz-Speicher nicht 
//wirklich um DIB 0 handelt, sondern mit einem Offset behaftet ist. Die 
//Startadresse des Multiinstanzspeichers steht aber im Adressregister 2. 
//Somit kann über die Pointer-Offsets die entsprechende Adresse geladen werden
      L     DIB [AR2,P#0.0]; // aktueller BCD Eingangswert   (lädt Byte 0 der Multiinstanz)
      L     B#16#F; // nur Bit0 bis 4
      UW    ; 
      T     #AKT_BCD; // aktueller aufbereiteter BCD-WERT

      L     #AKT_BCD; // Prüfen ob der BCD
      L     #LAST_BCD_AKTIV; // Eingangswert verändert wurde
      <>I   ; 
      =     #DIFF; // BCD-Wert wurde verändert

      L     #LAST_BCD; 
      L     #AKT_BCD; // Prüfen ob der BCD
      ==I   ; 
      =     #NODIFF; // kein Unterschied in der Anwahl
      T     #LAST_BCD; // seit dem letzten Programmzyklus
NETWORK
TITLE =Verzögerungszeit BCD-WERT-Änderung bis zur Ausgangsumschaltung

      U     #DIFF; 
      U     #NODIFF; 
      =     L      1.0; 
      BLD   103; 
      CALL #TON (
           IN                       := L      1.0,
           PT                       := #DELAY,
           Q                        := #QT);

      NOP   0; 
NETWORK
TITLE =

      U     #DIFF; // Wert wurde verändert
      U     #QT; // Wartezeit für Umschaltung abgelaufen
      SAVE  ; // Umschaltereignis auf ENO-AUSGANG
      SPB   SAVE; // neue Werte speichern
      BEA   ; 

SAVE: L     #AKT_BCD; // Aktuelle BCD-Zahl
      T     #LAST_BCD_AKTIV; // als letzte Zahl speichern

      L     #AKT_BCD; // Aktuelle BCD-Zahl = Bit-Nr im Ausgangs-WORD
      L     1; // Eine 1 um Anzahl "BCD-Zahl" nach links schieben
      SLW   ; 
      TAW   ; // Low- und High- Byte im WORD tauschen
      T     DIW [AR2,P#6.0]; // Wert an Ausgänge schreiben (Q1 bis Q9)

END_FUNCTION_BLOCK

FUNCTION_BLOCK "UP_DOWN_INT"
TITLE =UP_DOWN_INT: Wert mit Tasten vergrößeren und verkleinern
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 1/2005
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
VERSION : 0.1


VAR_INPUT
  UP : BOOL ;	
  DOWN : BOOL ;	
  SET : BOOL ;	
  SET_VALUE : INT ;	
  MIN : INT ;	
  MAX : INT ;	
  STEP_SLOW : INT ;	
  STEP_FAST : INT ;	
  STEP_PULS : INT ;	
  TAKT : TIME ;	
  DELAY_FAST : TIME ;	//Verzögerungszeit für Umschalten auf Schnell
END_VAR
VAR_IN_OUT
  VALUE : INT ;	
END_VAR
VAR
  lb_FP_UP : BOOL ;	
  lb_FP_DOWN : BOOL ;	
  UP_PULS : BOOL ;	
  DOWN_PULS : BOOL ;	
  FAST : BOOL ;	
  TAKT_PULS : BOOL ;	
  T1 : "TON";	
  T2 : "TON";	
END_VAR
BEGIN
NETWORK
TITLE =
//23.06.2012 Slow daktiviert


NETWORK
TITLE =Puls UP

      U     #UP; 
      FN    #lb_FP_UP; 
      UN    #FAST; 
      =     #UP_PULS; 
NETWORK
TITLE =Puls DOWN

      U     #DOWN; 
      FN    #lb_FP_DOWN; 
      UN    #FAST; 
      =     #DOWN_PULS; 
NETWORK
TITLE =Verzögerung bis zum schnellen Zählen

      U(    ; 
      U     #UP; 
      UN    #DOWN; 
      O     ; 
      U     #DOWN; 
      UN    #UP; 
      )     ; 
      =     L      0.0; 
      BLD   103; 
      CALL #T1 (
           IN                       := L      0.0,
           PT                       := #DELAY_FAST,
           Q                        := #FAST);

      NOP   0; 
NETWORK
TITLE =Zähltakt

      U(    ; 
      O     #UP; 
      O     #DOWN; 
      )     ; 
      UN    #TAKT_PULS; 
      =     L      0.0; 
      BLD   103; 
      CALL #T2 (
           IN                       := L      0.0,
           PT                       := #TAKT,
           Q                        := #TAKT_PULS);

      NOP   0; 
NETWORK
TITLE =SET: Wert setzen

      UN    #SET; 
      SPB   NE5; 
      L     #SET_VALUE; 
      SPA   CHK; 
NE5:  NOP   0; 

NETWORK
TITLE =

      U     #DOWN_PULS; 
      SPB   D_P; 

      U     #UP_PULS; 
      SPB   U_P; 

      U     #UP; 
      U     #TAKT_PULS; 
      UN    #FAST; 
      U     M      0.0; 
      SPB   U_S; 

      U     #DOWN; 
      U     #TAKT_PULS; 
      UN    #FAST; 
      U     M      0.0; 
      SPB   D_S; 

      U     #UP; 
      U     #FAST; 
      U     #TAKT_PULS; 
      SPB   U_F; 

      U     #DOWN; 
      U     #FAST; 
      U     #TAKT_PULS; 
      SPB   D_F; 
      BEA   ; 

NETWORK
TITLE =

U_S:  NOP   0; // Up slow
      L     #VALUE; 
      L     #STEP_SLOW; 
      +I    ; 
      SPA   CHK; 

U_F:  NOP   0; // Up fast
      L     #VALUE; 
      L     #STEP_FAST; 
      +I    ; 
      SPA   CHK; 

U_P:  NOP   0; // Up pulse
      L     #VALUE; 
      L     #STEP_PULS; 
      +I    ; 
      SPA   CHK; 


D_S:  NOP   0; // Down slow
      L     #VALUE; 
      L     #STEP_SLOW; 
      -I    ; 
      SPA   CHK; 

D_P:  NOP   0; // Down puls
      L     #VALUE; 
      L     #STEP_PULS; 
      -I    ; 
      SPA   CHK; 

D_F:  NOP   0; // Down fast
      L     #VALUE; 
      L     #STEP_FAST; 
      -I    ; 

CHK:  L     #MIN; // Wert auf Min/Max begrenzen
      <I    ; 
      SPB   SAVE; 
      TAK   ; 
      L     #MAX; 
      >I    ; 
      SPB   SAVE; 
      TAK   ; 
SAVE: T     #VALUE; 

END_FUNCTION_BLOCK

FUNCTION_BLOCK "m7b_SchuetzUeberwachung"
TITLE =Schützfehlerüberwachung mit Rückmeldekontakt
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 12/2009
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  K : BOOL ;	
  RM : BOOL ;	
  IEC_TIME : TIME ;	
END_VAR
VAR
  MI_TON : "TON";	
END_VAR
VAR_TEMP
  XOR_RESULT : BOOL ;	
  Q_TON : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =Schütz <> Rückmdlung ?

      X     #K; 
      X     #RM; 
      =     #XOR_RESULT; 

NETWORK
TITLE =Zeitverzögerung, wenn Ansteuerung <> Rückmeldung



      U     #XOR_RESULT; 
      =     L      1.0; 
      BLD   103; 
      CALL #MI_TON (
           IN                       := L      1.0,
           PT                       := #IEC_TIME,
           Q                        := #Q_TON);

      NOP   0; 
NETWORK
TITLE =ENO-Ausgang : Fehlerausgang

      U     #Q_TON; 
      SAVE  ; 
      CLR   ; 

END_FUNCTION_BLOCK

FUNCTION_BLOCK "POSI"
TITLE =Positionierung Achse mit Delay für Nachpositionierung bzw. Ready
//Positionierung Achse als Schrittsteuerung: 
//
//Lageregelung nur während der timDelayReady.
//Soll ohne die Möglichkeit der Nachpositionierung sofort bei erreichen der 
//Stopdifferenz fest abgeschaltet werden, dann timDelayReady =0
//
//
//[IN]
//FRG :       Freigabe, wenn Low, dann Abbruch der Positionierung
//SOLL:       Sollposition Achse
//IST :       Istposition Achse
//STOP_DIFF:  Vorabschaltentfernung
//TOL_POS_OK: Toleranz für Position ok Prüfung
//timDelayReady : Verzögerung für Ready (Nachpositionierung nur in dieser Zeit)
//
//[IN_OUT]
//START:      Befehl Positionierung Start, wird bei Ende oder Abbruch gelöscht
//
//[OUT]
//PLUS:       Fahrtrichtung Plus (vorw.)
//MINUS:      Fahrtrichtung Minus (rückw.)
//READY:      Positionierablauf korrekt beendet
//POS_OK:     Position innerhalb der Toleranz (ständige Prüfung)
//DSP_SNR:    Schrittnummer Positionierablauf
//
//FC_ENO:     zeigt an, dass Positionierung läuft
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 9/2007
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//20.11.2017   S.Maag     Nachpositionierung eingeführt.
//                        timDelayReady gibt, an wie lange der Antrieb in 
//                        korrekter Position sein muss, bis READY ausgegeben
//                        wird. Dann wird nicht mehr nachpositioniert.
//                        Dies ist insbesondere bei etwas instabilen Positons-
//                        erfassungen wie Laser Entfernungsmesser nötig. Sonst
//                        kann es sein, dass der Laser etwas wackelt, es wird
//                        gestoppt, die Position ist jedoch nicht im Fenster.
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
VERSION : 0.1


VAR_INPUT
  FRG : BOOL ;	//Freigabe
  SOLL : DINT ;	//Sollwert
  IST : DINT ;	//Istwert Achse
  STOP_DIFF : DINT ;	//Vorabschaltpunkt
  TOL_POS : DINT ;	//Toleranz für Positionierung
  TOL_POS_OK : DINT ;	//Toleranz für Position ok Meldung
  timDelayReady : TIME ;	
END_VAR
VAR_OUTPUT
  PLUS : BOOL ;	//Fahrtrichtung PLUS
  MINUS : BOOL ;	//Fahrtrichtung MINUS
  READY : BOOL ;	//Positionierung fertig
  POS_OK : BOOL ;	//Position innerhalb Toleranz ok
  DSP_SNR : INT ;	//Schrittnummer Positionierung, STATE
END_VAR
VAR_IN_OUT
  START : BOOL ;	
END_VAR
VAR
  SNR : INT ;	
  POS_DIFF : DINT ;	//aktuelle Positionsdifferenz
  FRG_GO : BOOL ;	
  POS_INTERVAL : BOOL ;	
  Q_TON_FRG_GO_OFF : BOOL ;	
  mi_TON_FRG_GO_OFF : "TON";	
END_VAR
VAR_TEMP
  tmpPosDIFF : DINT ;	
  tmp_timDelay : TIME ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =Zeit mindestens 1ms (da 0=RESET für IEC-Timer)

      L     L#1; 
      L     #timDelayReady; 
      UC    FC    21; 
      T     #tmp_timDelay; 

NETWORK
TITLE =Zeit Freiagbe GO ist AUS (Achse ist positioniert)

      UN    #FRG_GO; 
      =     L      8.0; 
      BLD   103; 
      CALL #mi_TON_FRG_GO_OFF (
           IN                       := L      8.0,
           PT                       := #tmp_timDelay,
           Q                        := #Q_TON_FRG_GO_OFF);

      NOP   0; 
NETWORK
TITLE =Signale Fahrtrichtung

      U(    ; 
      L     #SOLL; 
      L     #IST; 
      -D    ; 
      T     #POS_DIFF; 
      UN    OV; 
      SAVE  ; 
      CLR   ; 
      U     BIE; 
      )     ; 
      U     #FRG_GO; 
      UN    #POS_INTERVAL; 
      =     L      8.0; 
      U     L      8.0; 
      U     >0; 
      =     #PLUS; 
      U     L      8.0; 
      U     <0; 
      =     #MINUS; 
NETWORK
TITLE =Toleranzprüfung Position

      U(    ; 
      L     #POS_DIFF; 
      L     L#0; 
      <D    ; 
      )     ; 
      SPBNB _001; 
      L     #POS_DIFF; 
      NEGD  ; 
      T     #POS_DIFF; 
_001: NOP   0; 
NETWORK
TITLE =Toleranzprüfung Position

      L     #POS_DIFF; 
      L     #TOL_POS_OK; 
      <=D   ; 
      =     #POS_OK; 
NETWORK
TITLE =Position im Stop Interval

      L     #POS_DIFF; 
      L     #TOL_POS; 
      <=D   ; 
      =     #POS_INTERVAL; 
NETWORK
TITLE =Freigabe

      UN    #FRG; 
      R     #START; 
      R     #READY; 

NETWORK
TITLE =Standard Ablaufsteuerung mit INIT und CLR-Zweig

      L     #SNR; // Schrittnummer
      SPL   CLR; // Sprungziel bei SNR>max
      SPA   INIT; // 0-Schritt, Initialisierung
      SPA   S1; // Startschritt
      SPA   S2; 

CLR:  SET   ; // CLR
// hier die bei CLR zu löschenden Merker eintragen
      R     #START; 
      R     #FRG_GO; 

      L     1; // Schrittnummer 
      T     #SNR; // auf Startschritt stellen
      T     #DSP_SNR; // Schrittnummer Anzeige
      SPA   END; 

INIT: SET   ; // Initalisierung
      CLR   ; 
      SPA   CLR; 
      SPA   SET; // wird nur benötigt, damit die Entwicklungsumgebung die Sprungmarke nicht löscht

NETWORK
TITLE =Schrittweiterschaltung, bzw. Bausteinende

NEXT: L     #SNR; // NEXT : Schrittnummer auf nächsten
      +     1; // Schritt
SET:  T     #SNR; // Schritt setzten

END:  L     #SNR; // Sprungmarke für Baustein ENDE
      T     #DSP_SNR; // Schrittnummer Anzeige
      L     1; // Wenn Ablauf läuft, dann ENO-Ausgang = 1
      >I    ; 
      SAVE  ; 
      CLR   ; 
      BEA   ; 

NETWORK
TITLE =Positionierung START?

S1:   U     #START; 
      R     #READY; // Positionierung fertig CLR
      S     #FRG_GO; 
      SPB   NEXT; 
      SPA   END; 

NETWORK
TITLE =Abschaltposition erreicht?
//20.11.2017 S.Maag
//auf = FRG_GO und Delay umgestellt.
//Somit kann Zeit festgelegt werden, innerhalb welcher nach erreichen der
//Abschaltposition nochmals nachpositioniert werden kann.
//Dies ist insbesondere bei nich 100% Positionsstabilen Messystemen nötig. (z.B. 
//Laserentfernungsmessungen, welche druchaus etwas schwanken können)
S2:   NOP   0; 
      L     #POS_DIFF; // aktuelle Positionsdifferenz
      L     #STOP_DIFF; // Vorabschaltpunkt
      >D    ; 
      =     #FRG_GO; 

      U     #Q_TON_FRG_GO_OFF; // Freigabe GO ist für Zeit aus => READY
      S     #READY; // Positionierung fertig
      R     #START; // Start Positionierung CLR
      SPB   NEXT; // NEXT

      UN    #START; // Wenn Start von aussen gelöscht wird,
      SPB   CLR; // dann Ablauf löschen
      SPA   END; 


END_FUNCTION_BLOCK

FUNCTION_BLOCK "m7b_FU_RFR"
TITLE =Reglerfreigabe mit Nachlauf aus vw/rw Signal erzeugen
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 01/2013
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME         AENDERUNG
//--------------------------------------------------------------------------------
//13.06.2020   S.Maag       in Library aufgenommen  
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
VERSION : 0.1


VAR_INPUT
  vw : BOOL ;	//vorwärts
  rw : BOOL ;	//rückwärts
  FRG : BOOL ;	
  timTON_MSG : TIME ;	//Verzögerung Meldung RFR
  timTOF_RFR : TIME ;	//Nachlauf Reglerfreigabe
END_VAR
VAR_OUTPUT
  RFR : BOOL ;	//Ausgang Reglerfreigabe FU
  MSG_RFR : BOOL ;	//Meldung verzögert Reglerfreigabe o.k.
END_VAR
VAR
  Q_TON_MSG : BOOL ;	
  Q_TOF_RFR : BOOL ;	
  TOF_RFR : "TOF";	
  TON_MSG : "TON";	
END_VAR
VAR_TEMP
  xTON_MSG_IS_ZERO : BOOL ;	
  xTOF_RFR_IS_ZERO : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =Verzögerungszeit Meldung ist 0 ms
//bei 0ms starten IEC Timer nicht und Ausgang bleibt immer lo,
//Aufruf mit 0ms ist RESET
      L     #timTON_MSG; 
      L     L#0; 
      ==D   ; 
      =     #xTON_MSG_IS_ZERO; 
NETWORK
TITLE =Nachlauf Reglerfreigabe 0 ms
//bei 0ms starten IEC Timer nicht und Ausgang bleibt immer lo,
//Aufruf mit 0ms ist RESET
      L     #timTOF_RFR; 
      L     L#0; 
      ==D   ; 
      =     #xTOF_RFR_IS_ZERO; 
NETWORK
TITLE =Nachlauf Reglerfreigabe

      U(    ; 
      O     #vw; 
      O     #rw; 
      )     ; 
      =     L      1.0; 
      BLD   103; 
      CALL #TOF_RFR (
           IN                       := L      1.0,
           PT                       := #timTOF_RFR,
           Q                        := #Q_TOF_RFR);

      NOP   0; 
NETWORK
TITLE =Ausgang Reglerfreigabe

      U(    ; 
      U(    ; 
      O     #vw; 
      O     #rw; 
      )     ; 
      U     #xTOF_RFR_IS_ZERO; 
      O     ; 
      U     #Q_TOF_RFR; 
      UN    #xTOF_RFR_IS_ZERO; 
      )     ; 
      U     #FRG; 
      =     #RFR; 
NETWORK
TITLE =Verzögerung Meldung Reglerfreigabe



      U     #Q_TOF_RFR; 
      =     L      1.0; 
      BLD   103; 
      CALL #TON_MSG (
           IN                       := L      1.0,
           PT                       := #timTON_MSG,
           Q                        := #Q_TON_MSG);

      NOP   0; 
NETWORK
TITLE =Meldung Reglerfreigabe

      U     #RFR; 
      U(    ; 
      O     #Q_TON_MSG; 
      O     #xTON_MSG_IS_ZERO; 
      )     ; 
      =     #MSG_RFR; 
END_FUNCTION_BLOCK

FUNCTION_BLOCK "m7b_HydraulicPump"
TITLE =Steuerung Hydraulik mit Lastventil : Hydraulic with load valve
//Steuerung Hydraulikpumpe mit Lastventil!
//
//Einstellbare Nachlaufzeit für Hydraulikpumpe.
//Durch einstellbare Vor- und Nachlaufzeit für Lastventil (Meldung Druck auf 
//Hydraulik), verwendbar auch für Hydrauliken mit Porportionalventilen. Bei 
//Proportinalsteuerung muss das Lastventil mindestens so lange nachlaufen, wie 
//die 
//längste Rampenzeit der Ventile. Durch die Vorlaufzeit des Lastventils kann man 
//sicherstellen, dass auf jeden Fall Druck ansteht, bevor man die 
//Proportionalventile ansteuert.
//
//[IN]
//START        : Befehl, Hydraulik starten
//FRG          : Freigabe für Hydraulik (Netz_ok, Motorschutz usw. verschalten)
//T_HYDR_OFF   : Nachlaufzeit Hydraulikpumpe IEC-Time-Format
//T_Y_LOAD_OFF : Nachlaufzeit Lastventil (> max. Rampenzeiten bei Prop.Ventilen) 
//T_MSG_LOAD_ON: Verzögerung Meldung Lastventil ein (Vorlauf Lastventil)
//
//[OUT]
//PUMP          : Ausgang Hydraulikpumpe EIN
//Y_LOAD        : Ausgang Lastventil
//MSG_PUMP_READY: Meldung Hydraulik bereit (=durchgeschleiftes Singal FRG)
//MSG_PUMP_RUN  : Meldung Hydraulikpumpe läuft (fix verzögert 500ms)
//MSG_LOAD_ON   : Meldung Lastventil ist ein (Druck auf Hydraulik) - verzögert
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 11/2008
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//17.09.2010  S.Maag      Reset der iecZeit TOF_HydrPump über 0 im den Zeitwert
//                        damit läuft Pumpe nach Freigabeverlust nicht wieder an
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  START : BOOL ;	//Hydraulik START
  FRG : BOOL ;	//Freigabe Hydraulikpumpe
  T_HYDR_OFF : TIME ;	//Nachlaufzeit Hydraulikpumpe
  T_Y_LOAD_OFF : TIME ;	//Nachlauf Lastventil
  T_MSG_LOAD_ON : TIME ;	
END_VAR
VAR_OUTPUT
  PUMP : BOOL ;	//Ausgang Hydraulikpumpe EIN
  Y_LOAD : BOOL ;	//Ausgang Lastventil
  MSG_PUMP_READY : BOOL ;	//Meldung Hydraulik bereit
  MSG_PUMP_RUN : BOOL ;	//Meldung Hydraulik läuft
  MSG_LOAD_ON : BOOL ;	//Meldung Lastventil ein
END_VAR
VAR
  Q_T_Hydraulic : BOOL ;	
  Q_PUMP : BOOL ;	
  Q_LOAD_REQ : BOOL ;	
  Q_T_LOAD : BOOL ;	
  Q_LOAD : BOOL ;	
  TOF_HydrPump : "TOF";	
  TON_MSG_RUN : "TON";	
  TON_LOAD_ON : "TON";	
  TOF_LOAD : "TOF";	
END_VAR
VAR_TEMP
  DSP_TIME : TIME ;	
  m_T_HYDR_OFF : TIME ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =Zeit Hydraulik aus auf temporären Zwischenspeicher

      U     #FRG; 
      SPBNB _001; 
      L     #T_HYDR_OFF; 
      T     #m_T_HYDR_OFF; 
_001: NOP   0; 
NETWORK
TITLE =Wenn keine Freigabe, dann 0 in Zeitwert schreiben
//0 in Zeitwert schreiben ist die einzige Methode, um Zeiten zurückzusetzen, da 
//iecTimer nicht wie die S5-Timer einen Rücksetzeingang haben.
//
//Rücksetzen ist notwendig, da sonst die Hydraulikpumpe sofort wieder anläuft, 
//wenn das Freigabesignal zurückkehrt und die Zeit noch nicht abgelaufen ist.
//Es soll aber erst wieder eingeschaltet werden, wenn das Startsignal kommt.
//
      UN    #FRG; 
      SPBNB _002; 
      L     T#0MS; 
      T     #m_T_HYDR_OFF; 
_002: NOP   0; 
NETWORK
TITLE =Nachlauf Hydraulikpumpe



      U     #START; 
      U     #FRG; 
      =     L      8.0; 
      BLD   103; 
      CALL #TOF_HydrPump (
           IN                       := L      8.0,
           PT                       := #m_T_HYDR_OFF,
           Q                        := #Q_T_Hydraulic,
           ET                       := #DSP_TIME);
      NOP   0; 
NETWORK
TITLE =Ausgang Hydraulikpumpe

      U     #Q_T_Hydraulic; 
      U     #FRG; 
      =     #Q_PUMP; 
      =     #PUMP; 
NETWORK
TITLE =Meldung Hydraulikpumpe läuft verzögert

      U     #Q_PUMP; 
      =     L      8.0; 
      BLD   103; 
      CALL #TON_MSG_RUN (
           IN                       := L      8.0,
           PT                       := T#500MS,
           Q                        := #MSG_PUMP_RUN);

      NOP   0; 
NETWORK
TITLE =Anforderung Lastventil ein

      U     #START; 
      U     #MSG_PUMP_RUN; 
      U     #FRG; 
      =     #Q_LOAD_REQ; 
NETWORK
TITLE =Nachlauf Lastventil

      U     #Q_LOAD_REQ; 
      =     L      8.0; 
      BLD   103; 
      CALL #TOF_LOAD (
           IN                       := L      8.0,
           PT                       := #T_Y_LOAD_OFF,
           Q                        := #Q_T_LOAD);

      NOP   0; 
NETWORK
TITLE =Lastventil : Load valve

      U     #Q_T_LOAD; 
      U     #MSG_PUMP_RUN; 
      U     #FRG; 
      =     #Q_LOAD; 
      =     #Y_LOAD; 
NETWORK
TITLE =Meldung Lastventil ein : Message Load valve on

      U     #Q_LOAD; 
      =     L      8.0; 
      BLD   103; 
      CALL #TON_LOAD_ON (
           IN                       := L      8.0,
           PT                       := #T_MSG_LOAD_ON,
           Q                        := #MSG_LOAD_ON);

      NOP   0; 
NETWORK
TITLE =ENO-Ausgang = Lastventil

      U     #Q_LOAD; 
      SAVE  ; 
      CLR   ; 

END_FUNCTION_BLOCK

FUNCTION_BLOCK "m7b_ZylSensorCtrl"
TITLE =ZylinderSensorControl, für Zylinder mit 2 Sensoren
//Dier FB erledigt 2 Funktionen 
//1. Verzögerung der Zylindersensoren und generieren der Positionsmeldungen
//2. Überwachung der Zylinderbewegungen anhand der max. erlaubten Bewegungszeit   
//   bis der entsprechende Positionssensor belegt ist.
//
//Wird in der angebenen Zeit die Zylinderendstellung nicht erreicht, so wird 
//ERROR für die entsprechende Richtung ausgegeben. Der ENO-Ausgang des FC erhält 
//den ODER-verknüpten Error-Zustand. Ist also bei Fehler, egal welcher Richtung 
//High  
//
//Auf die SFBs TON, TOF wird verzichtet, da diese bereits je 22Byte an statischen 
//Daten verbrauchen. Dies wurde hauptsächlich wegen Speicherproblemen bei den 
//kleinen CPUs (312/313) so ausgeführt.
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 3/2008
//INTERNET: www.maagic7.de
//
//HINWEISE: Entstand aus FC7: m7ZylinderFehlerEx
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//03/12/2013   S.Maag      SFC64 TimeTick Zeitdifferenz korrigiert
//                         da 31Bit, Fehler bei Überlauf.
//                         UC FC256 "ABS_DIFF_S7SysTime" verwendet
//--------------------------------------------------------------------------------
//
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  SENS_GST : BOOL ;	//Sensor Grundstellung
  SENS_AST : BOOL ;	//Sensor Arbeitsstellung
  Y_GST : BOOL ;	//Eingang Schaltsignal Grundstellungs-Ventil
  Y_AST : BOOL ;	//Eingang Schaltsignal Arbeitsstellungs-Ventil
  iec_T_Err : TIME ;	//Zeit für Bewegung Fehlerüberwachung, IEC-Format
  iec_T_PosDelay : TIME ;	//Verzögerungszeit für Positionssensoren
END_VAR
VAR_OUTPUT
  POS_GST : BOOL ;	//Position Grundstellung
  POS_AST : BOOL ;	//Position Arbeitsstellung
  ERR_GST : BOOL ;	//Ausgang Fehler Sensor Grundstellung
  ERR_AST : BOOL ;	//Ausgang Fehler Sensor Arbeitsstellung
  STATUS : INT ;	//0=zu 1=auf 2=fährt 3=Fehler zu  4=Fehler auf
END_VAR
VAR
  FP_YGST : BOOL ;	//Flanke positiv Ventil Grundstellung
  FP_YAST : BOOL ;	//Flanke positiv Ventil Arbeitsstellung
  FP_B_GST : BOOL ;	
  FP_B_AST : BOOL ;	
  aktSysTime : TIME ;	
  T_FP_B_GST : TIME ;	//akt. SysZeit Sensor GST Flanke
  T_FP_B_AST : TIME ;	//akt. SysZeit Sensor AST Flanke
  tmpErrTime : TIME ;	//Speichervariable für Zeit
END_VAR
BEGIN
NETWORK
TITLE =aktuelle Systemzeit Zwischenspeichern

      CALL "TIME_TCK" (// aktuelle Systemzeit auslesen
           RET_VAL                  := #aktSysTime);
      NOP   0; 
NETWORK
TITLE =Systemzeit bei Sensor Grundstellung belegt
//Zeit bei der Sensor belegt wurde.
      U     #SENS_GST; 
      FP    #FP_B_GST; 
      SPBNB _001; 
      L     #aktSysTime; 
      T     #T_FP_B_GST; 
_001: NOP   0; 
NETWORK
TITLE =Systemzeit bei Sensor Arbeitsstellung belegt
//Zeit bei der Sensor belegt wurde.
      U     #SENS_AST; 
      FP    #FP_B_AST; 
      SPBNB _002; 
      L     #aktSysTime; 
      T     #T_FP_B_AST; 
_002: NOP   0; 
NETWORK
TITLE =Ausgang Position Grundstellung erreicht
//Verzögerung Position Grundstellung
      UN    #SENS_GST; // Sensor Grundstellung nicht aktiv
      R     #POS_GST; // dann Position Grundstellung clr
      SPB   ne4; // Netzwerkende
      L     #aktSysTime; // Wenn Grundstellungssensor High, dann
      L     #T_FP_B_GST; // Zeit überpüfen wie lange bereits
      UC    "m7b_ABS_DIFF_S7SysTime"; // Zeitdifferenz absolut ermitteln
      L     #iec_T_PosDelay; // Wenn größer als Verzögerung,
      >=D   ; 
      S     #POS_GST; // dann Position Grundstellung setzen
ne4:  NOP   0; 

NETWORK
TITLE =Ausgang Position Arbeitsstellung erreicht
//Verzögerung Position Arbeitsstellung
      UN    #SENS_AST; // Sensor Arbeitsstellung nicht aktiv
      R     #POS_AST; // dann Position Arbeitsstellung clr
      SPB   ne5; // Netzwerkende
      L     #aktSysTime; // Wenn Arbeitsstellungssensor High, dann
      L     #T_FP_B_AST; // Zeit überpüfen wie lange bereits
      UC    "m7b_ABS_DIFF_S7SysTime"; // Zeitdifferenz absolut ermitteln
      L     #iec_T_PosDelay; // Wenn größer als Verzögerung,
      >=D   ; 
      S     #POS_AST; // dann Position Arbeitsstellung setzen
ne5:  NOP   0; 

NETWORK
TITLE =Zeit bei Bewegung Start speichern

      U     #Y_GST; // falls beide Ventile gleichzeitg angesteuert sind
      U     #Y_AST; // dann Zeitüberwachung solange starten bis ein
      SPB   SVT; // Ventil abgeschaltet wird. Erst dann ist def. Zustand

      U     #Y_GST; // Ventil Grundstellung
      FP    #FP_YGST; // Flanke Ventilansteuerung
      SPB   SVT; // Save Time

      U     #Y_AST; // Ventil Arbeitsstellung
      FP    #FP_YAST; // Flanke Ventilansteuerung
      SPB   SVT; // Save Time

      SPA   NE1; 

SVT:  NOP   0; // Zeit bei Bewegung Start speichern
      CALL "TIME_TCK" (// Systemzeit wird zur Bewegungsüberwachung verwendet
           RET_VAL                  := #tmpErrTime);// dadurch erspart man sich Timerübergaben

NE1:  NOP   0; 
NETWORK
TITLE =Prüfen, ob beide Sensoren belegt sind => Fehler

      U     #SENS_GST; 
      U     #SENS_AST; 
      SPBN  NE2; 
      =     #ERR_GST; 
      =     #ERR_AST; 
      SAVE  ; 
      BEA   ; 
NE2:  NOP   0; 

NETWORK
TITLE =Zeit überprüfen, ob Endstellung erreicht ist

      U     #Y_GST; // Ventil Grundstellung
      UN    #SENS_GST; // Sensor GST nicht erreicht
      SPB   TCHK; // Prüfen ob max. Zeit Abgelaufen 

      U     #Y_AST; // Ventil Arbeitsstellung
      UN    #SENS_AST; // Sensor Arbeitsstellung nicht erreicht
      SPB   TCHK; // Prüfen ob max. Zeit Abgelaufen 

      CLR   ; 
      =     #ERR_GST; 
      =     #ERR_AST; 
      SAVE  ; 
      SPA   NE8; // Netzwerkende

TCHK: NOP   0; // Zeit Abgelaufen?
      L     #aktSysTime; 
      L     #tmpErrTime; // Zeit bei Start Bewegung
      UC    "m7b_ABS_DIFF_S7SysTime"; 
      L     #iec_T_Err; // Zeit für Bewegung
      >D    ; // Zeit abgelaufen
      SAVE  ; // Fehler im BIE-Bit speichern
      CLR   ; 

      U     BIE; 
      U     #Y_GST; // Ventil Grundstellung angesteuert, dann 
      =     #ERR_GST; // Fehler Sensor Grundstellung

      U     BIE; // gespeicherter Fehlerzustand im BIE-Bit
      U     #Y_AST; // und Ventil Arbeitsstellung, dann
      =     #ERR_AST; // Fehler Sensor Arbeitsstellung
NE8:  NOP   0; 
NETWORK
TITLE =Statusanzeige bearbeiten
//0 = geschlossen
//1 = offen
//2 = fährt
//3 = Störung bei zu
//4 = Störung bei auf
      L     3; // Fehler zu
      U     #ERR_GST; 
      SPB   SAVE; 

      L     4; // Fehler auf
      U     #ERR_AST; 
      SPB   SAVE; 

      L     0; // zu
      U     #POS_GST; 
      SPB   SAVE; 

      L     1; // offen
      U     #POS_AST; 
      SPB   SAVE; 

      L     2; // fährt

SAVE: T     #STATUS; 
      SET   ; 
      SAVE  ; 
      CLR   ; 

END_FUNCTION_BLOCK

FUNCTION_BLOCK "m7b_DISTANCE_COUNTER"
TITLE =Weg-Zähler (km Zähler)
//Dieser FB arbeitet als Weg-Zähler, vergleichbar einem km-Zähler.
//
//IN: ENDODER: Positionswert des zu zählenden Encoders
//IN: INKR   : Anzahl der Weginkremente, die jeweils eine Zähleinheit bilden
//IN: FRG    : Zählfreigabe; Zählvorgang an der akt. EncoderPos. beginnen
//IN: RICHTUNG: hiermit kann die Zählrichtung für den Weg angebeben werden 0:+/1:-
//
//Der Baustein verfügt über eine integrierte Fehlerkorrektur: D.h. es soll z.B. 
//in einer Teilung von je 100 INKR gezählt werden. Dabei kommt es vor, bedingt 
//durch SPS Zykluszeit usw., das das Zählerereignis erst bei einem Weg von z.B. 
//105 INKR bearbeitet wird. Dies wird korrigiert, indem beim nächsten Mal die 
//Soll-Inkremente dann auf 95 festgelegt werden usw. Dies verhindert einen sich 
//aufschaukelden Fehler!
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 3/2003
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//05.05.2010   S.Maag          von FC auf FB umgestellt, Code unverändert
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  ENCODER : DINT ;	//Positionswert Encoder
  INKR : DINT ;	//Inkremente für einen gezählten Wegimpuls (TEILUNG)
  FRG : BOOL ;	//Zählfreigabe
  RICHTUNG : BOOL ;	//Zählrichtung 0 = vorw. / 1 = rückw.
END_VAR
VAR_OUTPUT
  Overflow : BOOL ;	//Overflow +
  Underflow : BOOL ;	//Overflow - (underflow)
END_VAR
VAR_IN_OUT
  Weg : DINT ;	//Speicher für Wegwert
END_VAR
VAR
  memWeg : DINT ;	//Hilfsspeicher für Zwischenspeicherung Startwert Zählen
  memINKR : DINT ;	
  bStart : BOOL ;	//Hilfsmerker Zähler gestartet
END_VAR
BEGIN
NETWORK
TITLE =Satusausgänge Zählung löschen, werden im Code 1malig gesetzt

      CLR   ; // ENO-Ausgang löschen
      SAVE  ; // bei Zählereignis 1x gesetzt
      =     #Overflow; // Überlauf positiv
      =     #Underflow; // Überlauf negativ

NETWORK
TITLE =


      UN    #FRG; // keine FRG
      R     #bStart; // Zähler gestartet clr
      BEB   ; 

NETWORK
TITLE =Zähler starten: jedesmal bei Wiederkehr von FRG neu starten

      U     #bStart; // Zähler bereits gestartet
      SPB   NWE; // Netzwerkende

      S     #bStart; // Zähler ist gestartet

      L     #ENCODER; // Encoder-Wert
      T     #memWeg; // als Startwert speichern

      L     #INKR; // Anzahl der zu zählenden Inkremente
      T     #memINKR; // in mem-Varible speichern

NWE:  NOP   0; 
NETWORK
TITLE =
//Statubsbits: A0 (<0) : A1 (>0)
//Statusbist bei
//positivem Überlauf (Overflow) : OV, A0 = 1
//negativem Überlauf (Underflow): OV, 1  = 1
      L     #ENCODER; // aktueller Encoder Wert
      L     #memWeg; // Hilfsspeicher StartWert Encoder
      -D    ; // zurückgelegte Strecke
      SPP   weit; // Wenn positiv dann weiter
      NEGD  ; // Vorzeichen drehen
weit: L     #memINKR; // Anzahl der Inkremente pro Wegeinheit
      -D    ; // >=0 : Wegeinheit erreicht; >0 zuviel gez. INKR
      SPPZ  cnt; // springe zu zählen, wenn >=0
      BEA   ; 

cnt:  L     #INKR; // Inkremente pro Wegeinheit
      TAK   ; // zu viel gezählte INKR in Akku 1 zurück
      -D    ; // Korrektur SollInkr.: beim nächsten mal weniger zählen
      SPMZ  nsav; // Wenn Ergebnis <=0, dann nicht speichern (Encoderüberlauf)
      T     #memINKR; // beim nächsten mal zu zählende Inkremente

nsav: L     1; 
      UN    #RICHTUNG; // keine Richtungsumkehr
      SPB   inc; // Weg erhöhen
      NEGD  ; // Vorzeichen drehen
inc:  L     #Weg; 
      +D    ; 
      T     #Weg; 

      L     #ENCODER; // Encoder-Wert
      T     #memWeg; // als Startwert speichern

      SET   ; // ENO-Ausgang bei jedem Zählereignis 1x aktivieren
      SAVE  ; 
      CLR   ; 

      UN    OV; // Überlaufbit
      BEB   ; // Wenn kein Überlauf, dann Ende

      U     <0; // Abfrage Statusbit A0 (Wert im Akku <0)
      =     #Overflow; // Overfolw +, wenn von +2147483647 auf -2147483648 wechselt

      U     >0; // Abfrage Statusbit A1 (Wert im Akku >0)
      =     #Underflow; // Underflow -, wenn von -2147483648 auf +2147483647 wechselt


END_FUNCTION_BLOCK

FUNCTION_BLOCK "m7b_MotorLoadControl"
TITLE =Unter- Überlast- Auswertung Motor
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 4/2012
//
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//05.04.2020   S.Maag      Anordung der Ein- / Ausgänge optimiert und
//                         Bezeichnungsschema auf Stanard:
//                         MinMin, Min, Max, MaxMax geändert.
//                         In Library aufgenommen
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 2.0


VAR_INPUT
  StartUp : BOOL ;	//Motor StartUp is active
  RUN : BOOL ;	//Motor RUN message
  EXT_Inhibit : BOOL ;	//External inibit (externes Sperrsignal)
  iMaxMax : INT  := 1200;	//Level MaxMax
  iMax : INT  := 1100;	//Level Max
  iMin : INT  := 800;	//Level Min
  iMinMin : INT  := 700;	//Level MinMIn
  iMotor_IorP : INT ;	//Motor actual current or power
  iNominal_IorP : INT ;	//Nominal Motor current or power
  tim_MaxMax : TIME ;	//Delay for MaxMax Error
  tim_MinMin : TIME ;	//Delay for MinMin Error
  RESET : BOOL ;	
END_VAR
VAR_OUTPUT
  ERR_MaxMax : BOOL ;	//Error MaxMax, delayed (Overload Error) - must be RESET 
  MSG_MaxMax : BOOL ;	//Message MaxMax, undelayed (Overload)
  MSG_Max : BOOL ;	//Message Max, undelayed (Overload warning)
  MSG_OK : BOOL ;	//Message ok. (Load ok.)0
  MSG_Min : BOOL ;	//Message Min, undelayed (Underload warning)
  MSG_MinMin : BOOL ;	//Message MinMin, undelayed (Underload)
  ERR_MinMin : BOOL ;	//Error MinMin, delayed (Underlaod Error) - must be RESET 
  iMotorLoad : INT ;	//Displays the MotorLoad [%] [0..100..]
  iStatus : INT ;	//HMI Status
END_VAR
VAR
  TON_MinMin : "TON";	
  TON_MaxMax : "TON";	
END_VAR
VAR_TEMP
  HM_MSG_MaxMax : BOOL ;	
  HM_MSG_MinMin : BOOL ;	
  Q_TON_MaxMax : BOOL ;	
  Q_TON_MinMin : BOOL ;	
  DSP_TIME : TIME ;	
  tmpMotorLoad : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =Calulate the Motor load in percent [%],[0..100]
//calculate as DINT to be sure not exceeding the INT Range
      L     #iMotor_IorP; // actual Motor current or power
      ITD   ; 
      L     L#100; // %-Range
      *D    ; 
      L     #iNominal_IorP; // Nominal Motor current or power
      ITD   ; 
      /D    ; 
      T     #tmpMotorLoad; // Motor load % 0..100
      T     #iMotorLoad; 
NETWORK
TITLE =Oveerload analysis / Ueberlastauswertung
//======================================================================
//                     O V E R L O A D
//======================================================================


NETWORK
TITLE =MaxMax Overload

      U(    ; 
      L     #tmpMotorLoad; 
      L     #iMax; 
      >I    ; 
      )     ; 
      U     #RUN; 
      =     #MSG_Max; 
NETWORK
TITLE =Max Overload (warning level)

      U(    ; 
      L     #tmpMotorLoad; 
      L     #iMaxMax; 
      >I    ; 
      )     ; 
      U     #RUN; 
      =     #MSG_MaxMax; 
      =     #HM_MSG_MaxMax; 
NETWORK
TITLE =Delay Overlload MaxMax Error

      U     #HM_MSG_MaxMax; 
      =     L      8.0; 
      BLD   103; 
      CALL #TON_MaxMax (
           IN                       := L      8.0,
           PT                       := #tim_MaxMax,
           Q                        := #Q_TON_MaxMax);

      NOP   0; 
NETWORK
TITLE =Overload MaxMax Error

      U     #Q_TON_MaxMax; 
      S     #ERR_MaxMax; 
      U     #RESET; 
      R     #ERR_MaxMax; 
      NOP   0; 
NETWORK
TITLE =Underload analysis / Unterlastauswertung
//======================================================================
//                   U N D E R L O A D
//======================================================================


NETWORK
TITLE =Underload Min (warning)



      U(    ; 
      L     #tmpMotorLoad; 
      L     #iMin; 
      <I    ; 
      )     ; 
      U     #RUN; 
      =     #MSG_Min; 
NETWORK
TITLE =Underload MinMin

      U(    ; 
      L     #tmpMotorLoad; 
      L     #iMinMin; 
      <I    ; 
      )     ; 
      U     #RUN; 
      =     #MSG_MinMin; 
      =     #HM_MSG_MinMin; 
NETWORK
TITLE =Delay underload MinMin Error
//#HM_MSG_MinMin
      U     #HM_MSG_MinMin; 
      =     L      8.0; 
      BLD   103; 
      CALL #TON_MinMin (
           IN                       := L      8.0,
           PT                       := #tim_MinMin,
           Q                        := #Q_TON_MinMin,
           ET                       := #DSP_TIME);
      NOP   0; 
NETWORK
TITLE =Underload MinMin Error

      U     #Q_TON_MinMin; 
      S     #ERR_MinMin; 
      U     #RESET; 
      R     #ERR_MinMin; 
      NOP   0; 
NETWORK
TITLE =Load ok

      UN    #MSG_MinMin; 
      UN    #MSG_Min; 
      UN    #MSG_Max; 
      UN    #MSG_MaxMax; 
      U     #RUN; 
      =     #MSG_OK; 
NETWORK
TITLE =Display status
//======================================================================
//                       S T A T U S
//======================================================================


NETWORK
TITLE =Display Status
//0 : OFF
//1 : MSG MinMin    (Unterlast)
//2 : MSG Min       (Unterlast Warnung)
//3 : MSG ok.       (Last o.k.)
//4 : MSG_Max       (Überlast Warnung)
//5 : MSG_MaxMax    (Überlast)
//6 : Error MaxMax  (Überlast Störung)
//7 : Error MinMin  (Unterlast Störung)
//8 : External inhibit
//
//Überlast- und Unterlast- Error müssen im Status-Wert nebeneinander liegen, somit
//kann man anhand dieses Wertes in WinCC eine Reset-Schaltfläche einblenden
      L     6; 
      U     #ERR_MaxMax; // Überlast Error
      SPB   save; 

      L     7; 
      U     #ERR_MinMin; // Unterlast Error
      SPB   save; 


      L     5; 
      U     #MSG_MaxMax; // Überlast
      SPB   save; 

      L     4; 
      U     #MSG_Max; // Überlast Alarm
      SPB   save; 

      L     3; // Last o.k.
      U     #MSG_OK; 
      SPB   save; 

      L     1; // Unterlast
      U     #HM_MSG_MinMin; // muss vor UL Alarm sthen,sonst 
      SPB   save; // wird nie Unterlast angezeit

      L     2; 
      U     #MSG_Min; // Unterlast Alarm
      SPB   save; 

      L     8; // Sperre Extern/manuell
      U     #EXT_Inhibit; 
      SPB   save; 

      L     0; 

save: T     #iStatus; 

END_FUNCTION_BLOCK

FUNCTION_BLOCK "m7b_VirtualSensor2x"
TITLE =Virtuellen Sensor durch verschieben eines Sensors erzeugen (255)
//Erzeugt einen virtuellen Sensor durch verschieben eines Sensorsignal um Impluse 
//eines Encoders, dabei wird die Transportrichtung mit vw/rw berücksichtigt und 
//der Sensorwert vorw. mit der positiven Flanke, rückwärts mit negativer Flanke 
//des Encoders verarbeitet
//
//Verwendung:
//- virtuelle Sensoron über 4-Puls Sensorring in Transporttischen
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2011
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME       AENDERUNG
//--------------------------------------------------------------------------------
//16.10.2016   S.Maag     fatalen Fehler P##Buffer Berechnung behoben:
//                        Falsche Bereichskennung ausgeblendet. FB funktionierte
//                        nicht mit Instanz-DB Aufruf, nur über Multiinstanz.
//
//                        Bereichskennung muss aus rel. Adresse aus AR2
//                        entfernt werden, da diese 84 DB ist. Wir benötigen
//                        aber 85 Instanz-DB.
//                        FB gestestet mit direktem Instanz-DB und Multinstanz 
//                        2x verschachtelt. Funktion I.O. 
//
//16.10.2016   S.Maag     Buffer(15) auf Buffer(7) verkürzt. Da DW (32bit)
//                        verwendet wird, sind 256Byte = 8 Dword nicht 16 DWord
// 
//22.08.2016   S.Maag     Fehler P##BUFFER behoben, war ohne Instanzdatenoffset
//                        Varable ptrBUFFER eingeführt.
//                        (!!! Falsche Bereichskennung bei FB Aufruf mit Instanz
//                         DB. Siehe Änderung vom 16.10.2016
//
//16.10.2014   S.Maag     Erweiterung für 2tes Signal 
//
//07.10.2014   S.Maag     Buffer von 1xDWORD auf DWORD Array (15) = 255 Bits
//                        erhöht, dadruch Verschiebung von 0..255 statt 0..31
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  SENSOR : BOOL ;	//Sensorsignal
  ENCODER : BOOL ;	//Encodersignal
  vw : BOOL ;	//Richtungssignal Antrieb vw
  rw : BOOL ;	//Richtungssignal Antrieb rs
  IMP_DELAY_1 : INT ;	//Anzahl Impulse der Signalverschiebung
  IMP_DELAY_2 : INT ;	//Anzahl Impulse der Signalverschiebung
END_VAR
VAR_OUTPUT
  SIGNAL1 : BOOL ;	//Sensorsignal um Impuse 1 verschoben
  SIGNAL2 : BOOL ;	//Sensorsignal um Impuse 2 verschoben
END_VAR
VAR
  FP_ENCODER : BOOL ;	
  FN_ENCODER : BOOL ;	
  ptrBit : DWORD ;	
  BUFFER : ARRAY  [0 .. 15 ] OF DWORD ;	
END_VAR
VAR_TEMP
  BitToRead : DWORD ;	
  IMP_DELAY_CHECKED : DWORD ;	
  ptrBUFFER : DWORD ;	//Pointer auf BUFFER korrekt mit Instanzdaten-Offset verrechnet
END_VAR
BEGIN
NETWORK
TITLE =

      SET   ; 
      SAVE  ; 
      CLR   ; 
NETWORK
TITLE =Pointer BUFFER, relativ zu Instanzdaten
//ACHTUNG: indirektes kopieren der Daten von Multiinstanzen über Pointer
//ist nur mit Berücksichtigung des absoluten Instanz-Pointers möglich, da 
//die P#-Funktion von Step7 den Pointer nur relativ zu den Daten der aktuellen 
//Instanz ermittelt. Dieser relative Pointer muss zum Instanzpointer aus AR2 
//addiert werden.
//18.10.2016 S.Maag 
//Achtung: Es muss zuerst das Adressregister 2 geladen werden und von dort die 
//Bereichskennung ausgeblendet: TAR2 liefert immer Bereichskennung 84 des 
//Datenbausteins. P##Buffer liefert 85 "Instanzdatenbaustein als 
//Bereichskennung", was direkt die Instanzdaten adressiert.
      TAR2  ; // load Akku with instance pointer
      UD    DW#16#FFFFFF; // Remove highest Byte (memory range / Bereichskennung) = 84 "DB"
      L     P##BUFFER; // load relative address of BUFFER()
      +D    ; // add instance and relative data pointer
      T     #ptrBUFFER; // Pointer Buffer()

NETWORK
TITLE =Signal 1 um IMP_DELAY_1 verschoben aus Puffer lesen

      L     #IMP_DELAY_1; // 00..255 als Delay erlaubt
      L     DW#16#FF; // auf 8 Bit =255 begrenzen
      UD    ; 
      T     #IMP_DELAY_CHECKED; // geprüfte Verzögerung max. 8 Bit 0..255

      L     #ptrBit; // akteller Pointer Bit Ringpuffer
      L     #IMP_DELAY_CHECKED; // Auslesedifferenz (Delay)
      -D    ; // BitNoInBuffer - Delay
      L     DW#16#FF; // Limit to 8 Bits (255)
      UD    ; 
      T     #BitToRead; // BitNoToRead
      L     #ptrBUFFER; // Adresse Puffer laden
      +D    ; // Bitposition addieren
      LAR1  ; // In Adressregister laden
      U      [AR1,P#0.0]; // in Puffer schreiben
      =     #SIGNAL1; // virtueller Sensor

NETWORK
TITLE =Signal 2 um IMP_DELAY_2 verschoben aus Puffer lesen

      L     #IMP_DELAY_2; // 00..255 als Delay erlaubt
      L     DW#16#FF; // auf 8 Bit =255 begrenzen
      UD    ; 
      T     #IMP_DELAY_CHECKED; // geprüfte Verzögerung max. 8 Bit 0..255

      L     #ptrBit; // akteller Pointer Bit Ringpuffer
      L     #IMP_DELAY_CHECKED; // Auslesedifferenz (Delay)
      -D    ; // BitNoInBuffer - Delay
      L     DW#16#FF; // Limit to 8 Bits (255)
      UD    ; 
      T     #BitToRead; // BitNoToRead
      L     #ptrBUFFER; // Adresse Puffer laden
      +D    ; // Bitposition addieren
      LAR1  ; // In Adressregister laden
      U      [AR1,P#0.0]; // in Puffer schreiben
      =     #SIGNAL2; // virtueller Sensor

NETWORK
TITLE =Ringpuffer 255 Bit für Sensorsignal

      U     #ENCODER; // Encoder positive Flanke
      FP    #FP_ENCODER; 
      U     #vw; 
      SPB   p; // vorwärts/positiv

      U     #ENCODER; 
      FN    #FN_ENCODER; 
      U     #rw; // rückwärts/negativ
      SPB   n; 

      BEA   ; 

p:    L     #ptrBit; // vorwärts/positiv
      +     L#1; // Pointer Bit +
      SPA   save; 

n:    NOP   0; // rückwärts/negativ
      L     #ptrBit; // Pointer Bit -
      +     L#-1; 

save: L     DW#16#FF; // max. Bitposition in Puffer (255)
      UD    ; // ptr_Puffer auf max 8Bit (255) begrenzen
      T     #ptrBit; // Pointer aktuelles Bit im Puffer  0..255
      L     #ptrBUFFER; // Adresse Puffer laden
      +D    ; // Bitposition addieren
      LAR1  ; // In Adressregister laden
      U     #SENSOR; // Sensorsingal 
      =      [AR1,P#0.0]; // in Ringpuffer schreiben



END_FUNCTION_BLOCK

FUNCTION_BLOCK "m7b_VirtualSensor_32"
TITLE =Erweiterte virtelle Sensorfunktion mit belgter & freier Strecke
//Erzeugt einen virtuellen Sensor durch verschieben eines Sensorsignal um Impluse 
//eines Encoders, dabei wird die Transportrichtung mit vw/rw berücksichtigt und 
//der Sensorwert vorw. mit der positiven Flanke, rückwärts mit negativer Flanke 
//des Encoders verarbeitet.
//Die maximale Verschiebung beträgt 32 Impulse (= den 32 Bits von dwBuffer)
//
//Verwendung:
//- virtuelle Sensoron über 4-Puls Sensorring in Transporttischen
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 10/2011
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME       AENDERUNG
//--------------------------------------------------------------------------------
//11.01.2018   S.Maag     NW 5: Weg frei nach Sensor nur, wenn Sensor auch frei.
//                        Bisher wurde weg frei gemeldet, wenn Sensor bereits
//                        wieder belegt war, aber noch keine Encoderflanke
//                        auftrat.
//
//08.07.2015   S.Maag     NW 4: bei Reset, NW überspringen und  belegte/freie
//                        Strecke nue berechnen
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  RESET : BOOL ;	//RESET Befehl
  SENSOR : BOOL ;	//Sensorsignal
  ENCODER : BOOL ;	//Encodersignal
  vw : BOOL ;	//Richtungssignal Antrieb vw
  rw : BOOL ;	//Richtungssignal Antrieb rs
  IMP_DELAY : INT ;	//Anzahl Impulse der Signalverschiebung
END_VAR
VAR_OUTPUT
  SIGNAL : BOOL ;	//Sensorsignal um Impuse verschoben
  IMP_FREI : INT ;	
  IMP_BELEGT : INT ;	
END_VAR
VAR
  FP_ENCODER : BOOL ;	
  FN_ENCODER : BOOL ;	
  dwBUFFER : DWORD ;	
END_VAR
VAR_TEMP
  cnt_IMP_Hi : INT ;	
  cnt_IMP_Lo : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =

      SET   ; 
      SAVE  ; 
      CLR   ; 

NETWORK
TITLE =Reset: Alle Sensorbelegungen löschen : dwBuffer := 0

      UN    #RESET; // kein Reset, dann weiter
      SPB   ne2; 
      L     DW#16#0; // RESET ausführen: dwBuffer := 0
      T     #dwBUFFER; 
ne2:  NOP   0; 
NETWORK
TITLE =um IMP_DELAY verschobenen virtullen Sensor aus BUFFER lesen
//Wenn IMP_DELAY = 0, dann wird aktueller Sensorzustand als Signal ausgegeben
//sonst das verschobene Signal aus dwBuffer gelesen
      L     DW#16#FF; // erlaubter wert 0..255
      L     #IMP_DELAY; // 00..32 als Delay erlaubt
      UD    ; 
      L     0; // wenn Versatz =0 dann
      <>I   ; // aktuellen Sensorzustand
      SPB   ok; // als Singal ausgeben
      U     #SENSOR; 
      =     #SIGNAL; 
      SPA   ne3; // VKE wird mitgenommen

ok:   TAK   ; // Versatz nicht 0, dann Versatz zurück in Akku 1
      L     #dwBUFFER; // Buffer laden
      SRD   ; // um Anzahl Bits IMP_DELAY (Wert in Akku 2) schieben
      U     >0; // letztes geschobenes bit ist im Statusregister A1 und kann mit >0 abgefragt werden
      =     #SIGNAL; // virtueller Sensor
ne3:  NOP   0; 
NETWORK
TITLE =Ringpuffer 32 Bit für Sensorsignal
//Ringpuffer des Sensorsignals in dwBuffer
//
//08.07.2015 S.Maag : bei RESET NW überspringen - blegt/frei neu berechnen
      U     #RESET; // Bei Reset, freie und belegte Strecke neu berechnen
      SPB   ne4; 

      U     #ENCODER; // Encoder positive Flanke
      FP    #FP_ENCODER; 
      U     #vw; 
      SPB   p; // vorwärts/positiv

      U     #ENCODER; 
      FN    #FN_ENCODER; 
      U     #rw; // rückwärts/negativ
      SPB   n; 

      BEA   ; 

n:    L     #dwBUFFER; // Buffer laden
      SRD   1; // für neus Signal bei rückw.: rechts schieben
      T     #dwBUFFER; 
      SPA   ne4; 

p:    L     #dwBUFFER; // Buffer laden
      SLD   1; // für neues Signal bei vorw.: links schieben
      L     DW#16#1; // High Signal für Sensor belegt!
      OD    ; // Hi mit ODER in Bit_0 eintragen
      U     #SENSOR; // Wenn Sensor belegt
      SPB   save; // dann weiter mit Hi-Signal eintragen
      TAK   ; // Sensor war nicht belegt: SRD 1 Buffer zurück in Akku 2 (neues Bit bleibt Lo)
save: T     #dwBUFFER; // neuer  Buffer
ne4:  NOP   0; 

NETWORK
TITLE =Freie und belegte Impulse (Wegstrecke) nach Sensor
//// Strukturporgramm der Funktion
//
//IF dwBUFFER = DW#16#FFFFFFFF THEN   // alle 32 Bits belegt
//   cnt_IMP_Hi = 32   // Belegte Impulse nach Sensor := 32
//   cnt_IMP_Lo = 0    
//ELSE_IF dwBUFFER = 0 // kein Bit in dwBuffer belegt
//   cnt_IMP_Hi = 0
//   cnt_IMP_Lo = 32   // min. 32 Impulse freie Wegstrecke nach Sensor
//ELSE
//  IF dwBUFFER.Bit0 = TRUE THEN
//     // Bit0 Hi => Wegstrecke nach Sensor belegt
//     // belegte Wegstrecke besimmen
//    LOPH   // Hi-Bits zählen
//  ELSE  // dwBUFFER.Bit0 = FALSE
//    // Bit0 LO => Wegstrecke nach Sensor frei
//    // freie Wegstrecke besimmen, wenn Sensor nicht belegt
//    IF NOT Sensor THEN
//       LOPL   // Lo-Bits zählen
//    END_IF
//  END_IF
//END_IF

      L     0; 
      T     #cnt_IMP_Hi; // Zähler Hi-Impulse auf 0
      T     #cnt_IMP_Lo; // Zähler Lo-Impulse auf 0

      L     DW#16#FFFFFFFF; // Vergleichswert alle Bits Hi
      L     #dwBUFFER; // nur wenn Buffer <>0 und BUFFER <> FFFF FFFF 
      <>D   ; // dann Anzahl freie Stellen bestimmen
      SPB   chkZ; // Wenn Buffer nicht alle Bits belegt, dann Check_Zero
      L     32; // Zähler belegte Impulse = 32
      T     #cnt_IMP_Hi; 
      SPA   sav; 

chkZ: L     L#0; // Vergleichsert alle Bits Lo
      <>D   ; // BUFFER auf 0 prüfen
      SPB   If; // Wenn Buffer auch nicht 0, dann suche nach freier oder belegter Wegstrecke 
      L     32; // Wenn Buffer =0, dann sind alle 32 Stellen frei
      T     #cnt_IMP_Lo; // Zähler freie Impulse = 32
      SPA   sav; // und die freie Wegstrecke ist 32 Impulse => speichern

// If BUFFER.Bit0 = Hi THEN GOTO LOPH 'Hi-zählen' ELSE GOTO LOPL 'Lo-zählen'

If:   TAK   ; // BUFFER in AKKU 1 zurück
      PUSH  ; // PUSH kopiert AKKU 1 nach AKKU 2, somit BUFFER in beiden AKKUS
      SRD   1; // BIT_O von BUFFER in STATUSBIT schieben
      L     L#0; // Bitzähler mit 0 laden
      SPN   LOPH; // If BUFFER.Bit0 <>0, dann Schleife Hi-Werte zählen (belegte IMPULSE)

      U     #SENSOR; // IF Sensor is Hi THEN 'no free distance'
      SPB   sav; // Save the 0 values
      SPA   LOPL; // Else Schleife Lo-Werte zählen (freie IMPULSE)

// END_IF

// Schleife Hi-Bits zählen, belegte Wegstrecke nach Sensor
LOPH: TAK   ; // BUFFER zurück in AKKU_1 ; Bitzähler in Akku_2
      SRD   1; // BUFFER ShiftRight: Bit => STATUS A1
      TAK   ; // Bitzähler wieder in Akku 1 (beim ersten Mal 0)
      INC   1; // Bitzähler um 1 erhöhen
      SPZ   savH; // Wenn Bit=0 dann Hi-zählen ENDE: Bitzähler Hi speichern
      SPA   LOPH; 
savH: T     #cnt_IMP_Hi; // Bitzähler in Hi-Impulse speichern
      SPA   sav; 

// Schleife Lo-Bits zählen, freie Wegstrecke nach Sensor
LOPL: TAK   ; // BUFFER zurück in AKKU_1 ; Bitzähler in Akku_2
      SRD   1; // BUFFER ShiftRight: Bit => STATUS A1
      TAK   ; // Bitzähler wieder in Akku 1 (beim ersten Mal 0)
      INC   1; // Bitzähler um 1 erhöhen
      SPN   savL; // Wenn Bit=1 dann Lo-zählen ENDE: Bitzähler Lo speichern 
      SPA   LOPL; 
savL: T     #cnt_IMP_Lo; // Bitzähler in Lo-Impulse speichern

sav:  L     #cnt_IMP_Hi; // Zähler Hi-Impulse auf
      T     #IMP_BELEGT; // Ausgang Impulse belegte Wegstrecke

      L     #cnt_IMP_Lo; // Zähler Hi-Impulse auf
      T     #IMP_FREI; // Ausgang Impulse freie Wegstrecke
END_FUNCTION_BLOCK

FUNCTION_BLOCK "m7b_RampTime_INT!!!"
TITLE =Rampe Up/Down über Zeit für INT-Werte
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 4/2009
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME       AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  iSOLL : INT ;	//Sollwert
  iRampMax : INT ;	//Endwert Rampe (Maximalwert)
  iRampMin : INT ;	//Startwert Rampe (Minimalwert)
  timUP : TIME ;	//Zeit Beschleunigungsrampe
  timDOWN : TIME ;	//Zeit Bremsrampe
END_VAR
VAR_OUTPUT
  iOUT : INT ;	//Ausgang aktueller Rampenwert
  DSP_TimeDiff : TIME ;	
END_VAR
VAR
  m_rOUT : REAL ;	//letzter Ausgangswert
  m_SysTime : TIME ;	//Systemzeit beim letzten Aufruf
END_VAR
VAR_TEMP
  TimeDiff : TIME ;	
  aktSysTime : TIME ;	
  rABS_SollDiff : REAL ;	
  rRampRange : REAL ;	
  RampUp : BOOL ;	
  RampDown : BOOL ;	
  rTimeFaktor : REAL ;	
  rMaxDiffInCycle : DINT ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =Zeitdifferenz zum letzten Bausteinaufruf

      CALL "TIME_TCK" (// aktuelle Systemzeit in ms
           RET_VAL                  := #aktSysTime);

      L     #aktSysTime; // aktuelle Systemzeit
      L     #m_SysTime; // Systemzeit beim letzten Aufruf
      UC    "m7b_ABS_DIFF_S7SysTime"; // Absolute Differenz S7-Systemzeiten 31Bit
      T     #TimeDiff; // Absolutwert Zeitdifferenz in ms
      L     L#0; // Wenn keine Zeitdifferenz, dann
      ==D   ; // Baustein ENDE
      BEB   ; 
      L     #aktSysTime; // aktuelle Systemzeit
      T     #m_SysTime; // Systemzeit beim letzten Aufruf
      L     #TimeDiff; 
      T     #DSP_TimeDiff; 


NETWORK
TITLE =Wenn Sollwert & Ausgangswert < iMin, dann keine Rampe
//Out=Soll
      L     #iSOLL; 
      L     #iRampMin; 
      >I    ; 
      SPB   RAMP; 
      L     #iOUT; 
      L     #iRampMin; 
      >I    ; 
      SPB   RAMP; 

      L     #iSOLL; 
      ITD   ; 
      DTR   ; 
      T     #m_rOUT; 
      SPA   END; 

RAMP: NOP   0; 
NETWORK
TITLE =Beschleunigungs- oder Bermsrampe ?

      L     #iSOLL; // aktueller Sollwert
      L     #iOUT; // letzter Ausgangswert
      >I    ; 
      =     #RampUp; 
      <I    ; 
      =     #RampDown; 

NETWORK
TITLE =Rampensteuerbereich ermitteln

      L     #iRampMax; 
      L     #iRampMin; 
      -I    ; 
      ITD   ; 
      DTR   ; 
      T     #rRampRange; 


NETWORK
TITLE =Maximal erlaubte Differenz in diesem Zyklus

      L     #timUP; // Beschleunigungsrampe
      U     #RampUp; 
      SPB   calc; 
      L     #timDOWN; // oder Bremsrampe
calc: DTR   ; 
      L     #TimeDiff; 
      DTR   ; 
      /R    ; 
      T     #rTimeFaktor; 

      L     #rRampRange; 
      L     #rTimeFaktor; 
      /R    ; 
      T     #rMaxDiffInCycle; 

NETWORK
TITLE =Absolute Differenz von Ausgang und Sollwert

      L     #iOUT; 
      L     #iSOLL; 
      -I    ; 
      SPP   p2; 
      NEGI  ; 
p2:   ITD   ; 
      DTR   ; 
      T     #rABS_SollDiff; 
NETWORK
TITLE =

      L     #rMaxDiffInCycle; 
      L     #rABS_SollDiff; 
      >R    ; 
      L     #iSOLL; 
      ITD   ; 
      DTR   ; 
      SPB   save; 

      U     #RampUp; 
      SPB   rup; 
      U     #RampDown; 
      SPB   rdn; 
      SPA   save; 

rup:  L     #m_rOUT; 
      L     #rMaxDiffInCycle; 
      +R    ; 
      SPA   save; 
rdn:  L     #m_rOUT; 
      L     #rMaxDiffInCycle; 
      -R    ; 
save: T     #m_rOUT; 

NETWORK
TITLE =Ausgangswert Ausgeben

END:  L     #iRampMax; 
      ITD   ; 
      DTR   ; 
      L     #m_rOUT; // Real-Wert
      >R    ; 
      SPB   sav; 
      TAK   ; 
      T     #m_rOUT; 
sav:  RND   ; 
      T     #iOUT; // integer Wert


END_FUNCTION_BLOCK

FUNCTION_BLOCK "m7b_4xMUX_RevSync_INT"
TITLE =4x Schalter-Multiplexer INT, mit Reverse Synchronisierung
//Rückwärts synchronisierender Multiplexer
//
//Mit diesem Baustein lassen sich folgende Probleme beheben, die vor allem bei
//Maschinenumbauten bzw. Erweiterungen auftreten.
//
//- Hinzufügen eines 2ten Bedienpanels, wobei jedoch immer nur ein Panel die 
//  Bedienberechtigung hat.
//
//Hiermit lassen sich mehrere Schalter auf einen Schalter synchronisieren. Mit 
//cfgSyncSW lassen sich die Schalterstellungen untereinander synchronisieren, 
//d.h. der aktive Schalter schaltet die Schalter der anderen Panels mit.
//Ebenfalls lassen sich die Schalter durch den Ausgang rückwärts sychronisieren 
//(cfgRevSync). Damit werden die Schalterstellungen dem Ausgangswert nachgeführt. 
//Dies ist z.B. notwendig, wenn ein Softwareschalter der z.B. über Multiswitch 
//gesteuert wird verwendet wird.
//
//[IN]
//SELECT : Auswahl aktiver Schalter 0: keiner 1: SWITCH_1 2: SWITCH_2 usw.
//cfgSyncSW : Konfiguration Schalter untereinander synchronisieren
//cfgRevSync: Konfiguration Reverse Synchronisation: Schalter mit Ausgang         
//            synchronisieren (Ausgang schaltet schalter)
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 7/2011
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE: Die Notwendigkeit, die Idee und der erste Umsetzungsversuch stammt 
//          bereits von 06/2007
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  SELECT : INT ;	//Auswahl aktiver Schalter 0: keiner 1: SWITCH_1 2: SWITCH_2 usw.
  cfgSyncSW : BOOL ;	//Konfiguration: Schalter untereinander synchronisieren
  cfgRevSync : BOOL ;	//Konfiguration: Reverse Synchronisation: Schalter mit Ausgang synchronisieren 
END_VAR
VAR_IN_OUT
  SWITCH_1 : INT ;	
  SWITCH_2 : INT ;	
  SWITCH_3 : INT ;	
  SWITCH_4 : INT ;	
  OUT : INT ;	
END_VAR
VAR
  mem_OUT : INT ;	
  mem_SWITCH_SEL : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =ENO := TRUE

      SET   ; 
      SAVE  ; 
      CLR   ; 
NETWORK
TITLE =Wenn extern veränderter Ausgang, dann RevSync
//Wenn der Ausgnang (OUT) extern verändert wurde, dann die Schalter nachführen, 
//sofern ReversSychronisation (RevSync) aktiv.
      UN    #cfgRevSync; // Wenn RevSync nicht aktiv, dann
      SPB   ne2; // überspringen

      L     #mem_OUT; // pruefen, ob Ausgang
      L     #OUT; // extern verändert wurde
      ==I   ; // wenn NEIN, dann weiter
      SPB   ne2; 
// Ausgang wurde extern verändert
      T     #mem_OUT; // aktuellen OUT in mem_OUT speichern
      U     #cfgSyncSW; // Wenn Schalter syncronisieren, dann
      SPB   RSAL; // alle auf Ausgang syncronisieren
      SPA   RSY1; // sonst nur aktuellen Schalter syncronisieren

ne2:  NOP   0; 

NETWORK
TITLE =RevSync, wenn SWITCH_SEL Multiplexer umgeschaltet wird 
//Beim Umschalten des Multiplexers auf einen anderen Eingang, wird zuerst
//Rücksyncronisiert, damit durch das Umschalten keine ungewollten 
//Schalthandlungen auftreten.
      L     #mem_SWITCH_SEL; // SWITCH_SEL
      L     #SELECT; // verändert (Multiplexerumschaltung)?
      ==I   ; 
      SPB   ne3; // wenn nein, dann weiter
      T     #mem_SWITCH_SEL; // sonst SWITCH_SEL Wert in mem speichern

      UN    #cfgRevSync; // Wenn ReverseSyc aus,
      SPB   ne3; // dann weiter

      U     #cfgSyncSW; // sonst wenn auch Schalter sync.
      SPB   RSAL; // dann alle Schalter auf Ausgang syncronisieren
      SPA   RSY1; // sonst nur aktiven Schalter auf Ausgang sync.

ne3:  NOP   0; 

NETWORK
TITLE =4x Multiplexer

      L     #SELECT; 
      SPL   SW0; 
      SPA   SW0; 
      SPA   SW1; 
      SPA   SW2; 
      SPA   SW3; 
      SPA   SW4; 

SW0:  BEA   ; // kein Schalter aktiviert

SW1:  L     #SWITCH_1; 
      UN    #cfgSyncSW; // Wenn Schalter syncronisieren nicht activ,
      SPB   save; // dann speichern
      T     #SWITCH_2; // sonst restliche Schalter syncronisieren
      T     #SWITCH_3; 
      T     #SWITCH_4; 
      SPA   save; 

SW2:  L     #SWITCH_2; 
      UN    #cfgSyncSW; 
      SPB   save; 
      T     #SWITCH_1; 
      T     #SWITCH_3; 
      T     #SWITCH_4; 
      SPA   save; 

SW3:  L     #SWITCH_3; 
      UN    #cfgSyncSW; 
      SPB   save; 
      T     #SWITCH_1; 
      T     #SWITCH_2; 
      T     #SWITCH_4; 
      SPA   save; 

SW4:  L     #SWITCH_4; 
      UN    #cfgSyncSW; 
      SPB   save; 
      T     #SWITCH_1; 
      T     #SWITCH_2; 
      T     #SWITCH_3; 

save: T     #OUT; 
      T     #mem_OUT; 
      BEA   ; 
NETWORK
TITLE =Reverse Sync - nur aktiven Schalter
//aktiven Schalter rücksyncronisieren (Schaltereingang = aktueller OUT)
RSY1: L     #SELECT; 
      SPL   RSW0; // Sprungziel bei Overflow: SWITCH_SEL>4
      SPA   RSW0; // 0, kein Eingang ausgewählt
      SPA   RSW1; 
      SPA   RSW2; 
      SPA   RSW3; 
      SPA   RSW4; 

RSW0: BEA   ; // kein Schalter aktiviert

RSW1: L     #OUT; // RevSync Switch 1
      T     #SWITCH_1; 
      BEA   ; 

RSW2: L     #OUT; // RevSync Switch 2
      T     #SWITCH_2; 
      BEA   ; 

RSW3: L     #OUT; // RevSync Switch 3
      T     #SWITCH_3; 
      BEA   ; 

RSW4: L     #OUT; // RevSync Switch 4
      T     #SWITCH_4; 
      BEA   ; 
NETWORK
TITLE =Reverse Sync - alle Schalter

RSAL: L     #OUT; 
      T     #SWITCH_1; 
      T     #SWITCH_2; 
      T     #SWITCH_3; 
      T     #SWITCH_4; 

END_FUNCTION_BLOCK

FUNCTION_BLOCK "m7b_RAMP_LIN_TIME"
TITLE =Linear-Rampen-Generator über Zeit
//Generiert eine lineare Rampe zwischen den Geschwindigkeiten MIN und MAX.
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 5/2012
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME          AENDERUNG
//--------------------------------------------------------------------------------
//03/12/2013   S.Maag      SFC64 TimeTick Zeitdifferenz korrigiert
//                         da 31Bit, Fehler bei Überlauf. Auf 32 Bit-Rechnung
//                         erweitert
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  RESET : BOOL ;	//Reset Speed to SetPoint
  Speed_SetPoint : INT ;	
  Speed_min : INT ;	//Geschwindigkeit minimal
  Speed_max : INT ;	//Geschwindigkeit maximal
  ACC_TIME : TIME ;	//Acceleration Time (min to max)
  DECC_TIME : TIME ;	//Decceleration Time (max to min)
  TIME_BASE : TIME ;	
END_VAR
VAR_OUTPUT
  Speed : INT ;	
  MSG_ACC : BOOL ;	//Meldung Beschleunigung
  MSG_DECC : BOOL ;	//Meldung Verzögerung
END_VAR
VAR
  r_memSpeed : REAL ;	
  memTime : TIME ;	
END_VAR
VAR_TEMP
  rACC_STEP : REAL ;	
  rDECC_STEP : REAL ;	
  rSPEEDDIFFxTIMEBASE : DINT ;	
  aktSysTime : TIME ;	
  TimeDiff : TIME ;	
  rSpeedSetPoint : REAL ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =prüfen auf abgelaufene Zeitbasis und Resetverarbeitung

      CALL "TIME_TCK" (
           RET_VAL                  := #aktSysTime);

      UN    #RESET; // Wenn Reset,
      SPB   do; 
      R     #MSG_ACC; 
      R     #MSG_DECC; 
      L     #aktSysTime; // dann
      T     #memTime; 
      L     #Speed_SetPoint; // SetPoint als Speed speichern
      SPA   SAVE; 

do:   L     #aktSysTime; // aktuelle Systemzeit
      L     #memTime; // gespeicherte Zeit
      UC    "m7b_ABS_DIFF_S7SysTime"; 
      T     #TimeDiff; 
      L     #TIME_BASE; // Zeitbasis 
      <D    ; // TimeDiff < TimeBase
      BEB   ; // dann Ende
      L     #aktSysTime; 
      T     #memTime; // als letzte Zeit speichern

NETWORK
TITLE =Rampenstufung für beschleunigen & bremsen berechnen
//Beispiel für Berechnung der Beschleunigungsrampe, gleiches gilt für bremsen
//
//STEPS = ACC_TIME/TimeBase  // Anzahl der Rampenstufen
//ACC_STEP = SpeedDiff / (ACC_TIME/TimeBase) = SpeedDiff * TimeBase / ACC_TIME 
//
      L     #Speed_max; // Maximalgeschwindigkeit
      L     #Speed_min; // Minimalgeschwindigkeit
      -I    ; // SPEED_DIFF
      ITD   ; 
      L     #TIME_BASE; 
      *D    ; 
      DTR   ; 
      T     #rSPEEDDIFFxTIMEBASE; 
      L     #ACC_TIME; 
      DTR   ; 
      /R    ; 
      T     #rACC_STEP; // Beschleunigungsstufe


      L     #rSPEEDDIFFxTIMEBASE; 
      L     #DECC_TIME; 
      DTR   ; 
      /R    ; 
      T     #rDECC_STEP; // Bremsstufe

NETWORK
TITLE =Beschleunigen oder bremsen?

      L     #Speed_SetPoint; // aktueller Speed Sollwert
      ITD   ; 
      DTR   ; 
      T     #rSpeedSetPoint; // Real SpeedSetPoint

      L     #Speed_SetPoint; 
      L     #r_memSpeed; // Speicher letzter Speed
      RND   ; 
      >I    ; // Wenn SetPoint > memSpeed
      SPB   acc; // dann beschleuchnigen
      <I    ; // Wenn SetPoint < memSpeed
      SPB   decc; // dann bremsen
      R     #MSG_ACC; 
      R     #MSG_DECC; 
      L     #rSpeedSetPoint; // aktueller Speed Sollwert
      SPA   SAVE; 

acc:  S     #MSG_ACC; 
      R     #MSG_DECC; 
      L     #r_memSpeed; // Beschleunigen
      L     #rACC_STEP; // um eine Stufe
      +R    ; 
      L     #rSpeedSetPoint; // bei Beschleunigung
      >R    ; // auf max SetPoint
      SPB   SAVE; // begrenzen
      TAK   ; 
      SPA   SAVE; 

decc: S     #MSG_DECC; 
      R     #MSG_ACC; 
      L     #r_memSpeed; // Bremsen 
      L     #rDECC_STEP; // um eine Stufe
      -R    ; 
      L     #rSpeedSetPoint; // bei Verzögerung
      <R    ; // auf min SetPoint
      SPB   SAVE; // begrenzen
      TAK   ; 
      SPA   SAVE; 

NETWORK
TITLE =nun noch auf Maximalwert begrenzen

SAVE: L     #Speed_max; // Speed max
      ITD   ; 
      DTR   ; 
      >R    ; // Wenn SpeedAkt >  MaxSpeed,
      SPB   sav; // dann MaxSpeed speichern
      TAK   ; // sonst SpeedAkt zurück in Akku1
      L     #Speed_min; // Wenn SpeedAct < MinSpeed,
      ITD   ; 
      DTR   ; 
      <R    ; // dann MinSpeed speichern
      SPB   sav; 
      TAK   ; // sonst SpeedAkt zurück in Akku1
sav:  T     #r_memSpeed; 
      RND   ; 
      T     #Speed; // Speed speichern
      SAVE  ; 
END_FUNCTION_BLOCK

FUNCTION_BLOCK "m7b_1of4DeviceEnable"
TITLE =1of4_DeviceEnable
//Enables 1 of 4 devices. 
//Allows only 1 device to be enabled.
//Changes the device enable with adjustable delay
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 08/2013
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME            AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE: Entwickelt für Schieber Bioabfallaufbereitung
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  REQ1 : BOOL ;	//Request for Device 1
  REQ2 : BOOL ;	//Request for Device 2
  REQ3 : BOOL ;	//Request for Device 3
  REQ4 : BOOL ;	//Request for Device 3
  timDelay : TIME ;	
END_VAR
VAR_OUTPUT
  EN1 : BOOL ;	
  EN2 : BOOL ;	
  EN3 : BOOL ;	
  EN4 : BOOL ;	
END_VAR
VAR
  Q_TOF_ENABLE : BOOL ;	
  TOF_ENABLE : "TOF";	
END_VAR
VAR_TEMP
  tmpEnIsOn : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =




NETWORK
TITLE =DELAYED ENABLE OFF



      U(    ; 
      O     #EN1; 
      O     #EN2; 
      O     #EN3; 
      O     #EN4; 
      )     ; 
      =     L      1.0; 
      BLD   103; 
      CALL #TOF_ENABLE (
           IN                       := L      1.0,
           PT                       := #timDelay,
           Q                        := #Q_TOF_ENABLE);

      NOP   0; 
NETWORK
TITLE =temporary Signal EnableIsOn
//This signal is used to check wheater a ENABLE signal is already switched  ON.
//If all ENABLES are OFF and more than 1 REQEST become HI at the same time, only 
//one ENABLE will switch ON.
      U     #tmpEnIsOn; 
      R     #tmpEnIsOn; 
NETWORK
TITLE =ENABLE 1

      U     #REQ1; 
      UN    #Q_TOF_ENABLE; 
      S     #EN1; 
      UN    #REQ1; 
      U(    ; 
      O     #REQ2; 
      O     #REQ3; 
      O     #REQ4; 
      )     ; 
      R     #EN1; 
      U     #EN1; 
      S     #tmpEnIsOn; 
NETWORK
TITLE =ENABLE 2

      U     #REQ2; 
      UN    #Q_TOF_ENABLE; 
      S     #EN2; 
      U(    ; 
      UN    #REQ2; 
      U(    ; 
      O     #REQ1; 
      O     #REQ3; 
      O     #REQ4; 
      )     ; 
      O     #tmpEnIsOn; 
      )     ; 
      R     #EN2; 
      U     #EN2; 
      S     #tmpEnIsOn; 
NETWORK
TITLE =ENABLE 3

      U     #REQ3; 
      UN    #Q_TOF_ENABLE; 
      S     #EN3; 
      U(    ; 
      UN    #REQ3; 
      U(    ; 
      O     #REQ1; 
      O     #REQ2; 
      O     #REQ4; 
      )     ; 
      O     #tmpEnIsOn; 
      )     ; 
      R     #EN3; 
      U     #EN3; 
      S     #tmpEnIsOn; 
NETWORK
TITLE =ENABLE 4

      U     #REQ4; 
      UN    #Q_TOF_ENABLE; 
      S     #EN4; 
      U(    ; 
      UN    #REQ4; 
      U(    ; 
      O     #REQ1; 
      O     #REQ2; 
      O     #REQ3; 
      )     ; 
      O     #tmpEnIsOn; 
      )     ; 
      R     #EN4; 
      NOP   0; 
END_FUNCTION_BLOCK

FUNCTION_BLOCK "m7b_PumpPressureMonitor"
TITLE =Pressure monitoring for pumps / Drucküberwachung Pumpen
//Überwachung auf Unterdruck (Trockenlauf/Wassermangel bzw. Rohrbruch)
//Überwachung auf Überdruck (z.B. geschlossene Schieber)
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 08/2012
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME       AENDERUNG
//--------------------------------------------------------------------------------
//04.08.2018   S.Maag    Dokumentation ergänzt/überarbeitet
//
//15.04.2016   S.Maag    SET SAVE CLR in letzte NW verschoben, da ENO nicht TRUE
//                       war. (wird wahrscheinlich von TON-Aufrufen überschrieben)
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  MSG_RUN : BOOL ;	//Message Pump run
  RESET : BOOL ;	//Error Reset
  rPact : REAL ;	//actual pressure
  rPmin : REAL ;	//minimal pressure
  rPmax : REAL ;	//maximal pressure
  timPmin : TIME  := T#30S;	//Time for min pressure Error
  timPmax : TIME  := T#5MS;	//Time for max pressure Error
END_VAR
VAR_OUTPUT
  MSG_ERR : BOOL ;	//ERROR / FAULT (Lo or Hi)
  MSG_ERR_Lo : BOOL ;	//Low pressure error
  MSG_ERR_Hi : BOOL ;	//Over pressure error
  rP_ERR : REAL ;	//Pressure value when error occurs
END_VAR
VAR
  FP_ERR_Pmin : BOOL ;	//Rising edge of low pressure error
  FP_ERR_Pmax : BOOL ;	//Rising edge of over pressure error
  TON_Pmin : "TON";	//Delay low pressure error
  TON_Pmax : "TON";	//Delay over pressure error
END_VAR
VAR_TEMP
  Q_TON_Pmin : BOOL ;	
  Q_TON_Pmax : BOOL ;	
  DSP_TPmin : TIME ;	
  DSP_TPmax : TIME ;	
END_VAR
BEGIN
NETWORK
TITLE =Low pressure / Unterdruck
//======================================================================
//              L O W   P R E S S U R E  /  U N T E R D R U C K
//======================================================================
NETWORK
TITLE =Lo pressure check / Auf Unterdruck prüfen (verzögert)



      U     #MSG_RUN; 
      U(    ; 
      L     #rPact; 
      L     #rPmin; 
      <R    ; 
      )     ; 
      UN    #MSG_ERR_Lo; 
      =     L     10.0; 
      BLD   103; 
      CALL #TON_Pmin (
           IN                       := L     10.0,
           PT                       := #timPmin,
           Q                        := #Q_TON_Pmin,
           ET                       := #DSP_TPmin);
      NOP   0; 
NETWORK
TITLE =Low pressure Error / Unterdruckstörung

      U(    ; 
      U     #Q_TON_Pmin; 
      S     #MSG_ERR_Lo; 
      U     #RESET; 
      R     #MSG_ERR_Lo; 
      U     #MSG_ERR_Lo; 
      )     ; 
      FP    #FP_ERR_Pmin; 
      SPBNB _001; 
      L     #rPact; 
      T     #rP_ERR; 
_001: NOP   0; 
NETWORK
TITLE =Over pressure / Überdruck
//======================================================================
//          O V E R   P R E S S U R E   /   Ü B E R D R U C K
//======================================================================
NETWORK
TITLE =Over pressure check / Auf Überdruck prüfen (verzögert)

      U     #MSG_RUN; 
      U(    ; 
      L     #rPact; 
      L     #rPmax; 
      >R    ; 
      )     ; 
      UN    #MSG_ERR_Hi; 
      =     L     10.0; 
      BLD   103; 
      CALL #TON_Pmax (
           IN                       := L     10.0,
           PT                       := #timPmax,
           Q                        := #Q_TON_Pmax,
           ET                       := #DSP_TPmax);
      NOP   0; 
NETWORK
TITLE =Over pressure Error / Überdruckstörung

      U(    ; 
      U     #Q_TON_Pmax; 
      S     #MSG_ERR_Hi; 
      U     #RESET; 
      R     #MSG_ERR_Hi; 
      U     #MSG_ERR_Hi; 
      )     ; 
      FP    #FP_ERR_Pmax; 
      SPBNB _002; 
      L     #rPact; 
      T     #rP_ERR; 
_002: NOP   0; 
NETWORK
TITLE =ERROR output / Ausgang Störung

      O     #MSG_ERR_Lo; 
      O     #MSG_ERR_Hi; 
      =     #MSG_ERR; 
NETWORK
TITLE =

      SET   ; 
      SAVE  ; 
      CLR   ; 

END_FUNCTION_BLOCK

FUNCTION_BLOCK "m7b_PumpTempMonitor"
TITLE =Temperature monitoring for pumps / Temperaturüberwachung Pumpen
//Stator Temperatur monitoring for pumps with Stator-Temperatur-Sensor
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 03/2019
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME       AENDERUNG
//--------------------------------------------------------------------------------
//
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  MSG_RUN : BOOL ;	//Message Pump run
  RESET : BOOL ;	//Error Reset
  rStatorTemp : REAL ;	//actual Stator Temperature
  rMediumTemp : REAL ;	//actual Medium Temperature
  rTempOffset : REAL ;	//Allowed Temperature Offset (TempStator > TempMedium)
  timTempMax : TIME  := T#5MS;	//Time for max Temperautre Error
END_VAR
VAR_OUTPUT
  MSG_ERR : BOOL ;	//ERROR / FAULT 
  rTemp_ERR : REAL ;	//Stator Temperature value when error occurs
END_VAR
VAR
  m_TempMax : REAL ;	
  TON_TempMax : "TON";	//Delay over pressure error
  FP_ERR : BOOL ;	//Rising edge of over pressure error
END_VAR
VAR_TEMP
  Q_TON_TempMax : BOOL ;	
  DSP_TempMax : TIME ;	
END_VAR
BEGIN
NETWORK
TITLE =

NETWORK
TITLE =Calculate max. allowed Stator Temp. = MediumTemp + Offset

      L     #rMediumTemp; 
      L     #rTempOffset; 
      +R    ; 
      T     #m_TempMax; 
      NOP   0; 
NETWORK
TITLE =Over Temperature/ Übertemperatur
//======================================================================
//  O V E R   T E M P E R A T U R E   /   Ü B E R T E M P E R A T U R
//======================================================================
NETWORK
TITLE =Over pressure check / Auf Überdruck prüfen (verzögert)

      U     #MSG_RUN; 
      U(    ; 
      L     #rStatorTemp; 
      L     #m_TempMax; 
      >R    ; 
      )     ; 
      UN    #MSG_ERR; 
      =     L      6.0; 
      BLD   103; 
      CALL #TON_TempMax (
           IN                       := L      6.0,
           PT                       := #timTempMax,
           Q                        := #Q_TON_TempMax,
           ET                       := #DSP_TempMax);
      NOP   0; 
NETWORK
TITLE =Over temperature Error / Störung Übertemperatur

      U(    ; 
      U     #Q_TON_TempMax; 
      S     #MSG_ERR; 
      U     #RESET; 
      R     #MSG_ERR; 
      U     #MSG_ERR; 
      )     ; 
      FP    #FP_ERR; 
      SPBNB _001; 
      L     #rStatorTemp; 
      T     #rTemp_ERR; 
_001: NOP   0; 
NETWORK
TITLE =

      SET   ; 
      SAVE  ; 
      CLR   ; 

END_FUNCTION_BLOCK

FUNCTION_BLOCK "m7b_DriveError_AutoReset"
TITLE =DriveError AUTO-RESET
//AutoReset the Drives Frequency converter a few times.
//
//[IN]
//MSG_DRIVE_ERR : indicates Drive Fault
//ERR_RESET     : External button to RESET Errors, must be pressed by Operator
//MaxNoOfResets : Max no of Resets allowed during monitoring time (typical 3)
//timResetMonitoring : Time for RESET Monitoring:
//                     during this time only MaxNoOfResets are allowed
//timResetDelay  : Dealy between MsgDriveErr and FC_RESET_Impuls
//timResetImpuls : Duration of FC_RESET_Impuls
//
//[OUT]
//FC_RESET_IMP  : Impuls with duration timResetImpuls to reset frequncy converter
//evt_RESET     : 1 Cycle Event signal: can be used to save time stamp of RESET
//ERR_RESET_CNT : Shows the Error-Reset Counter
//DSP_MonitoringTime : Shows the elappsed time since first RESET   
//                    (=ResetMonitoringTime)
//
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 03/2019
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME       AENDERUNG
//--------------------------------------------------------------------------------
//
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  MSG_DRIVE_ERR : BOOL ;	//Message Drive Error
  ERR_RESET : BOOL ;	
  MaxNoOfResets : INT ;	//Maximal number of RESETs during monitoring time
  timResetMonitoring : TIME ;	//Duration of Reset Monitoring 
  timResetDelay : TIME ;	//Delay for Reset Impuls, after Error occured
  timResetImpuls : TIME  := T#500MS;	//Duration of Reset Impuls
END_VAR
VAR_OUTPUT
  FC_RESET_IMP : BOOL ;	//Frequency converter RESET Impuls
  evt_RESET : BOOL ;	//Reset Event: can be used to save TimeStamp of Reset
  ERR_RESET_CNT : INT ;	//Counter of Resets
  DSP_MonitoringTime : TIME ;	//Elappsed time since first RESET (Reset monitoring time)
END_VAR
VAR
  TON_RESET_DELAY : "TON";	
  TP_RESET : "TP";	
  TON_ResetTimeRange : "TP";	
  CTU_ERR : "CTU";	
  Q_TON_RESET_DELAY : BOOL ;	
  Q_TP_RESET : BOOL ;	
  Q_TON_ResetTimeRange : BOOL ;	
  Q_CTU_Errors : BOOL ;	
  m_StartTimeRange : BOOL ;	
  m_MaxNoOfResetReached : BOOL ;	
  cmd_RESET : BOOL ;	//Reset command for Monitoring Time & RESET-Counter
END_VAR
VAR_TEMP
  DSP_ResetTimeRange : TIME ;	
END_VAR
BEGIN
NETWORK
TITLE =

NETWORK
TITLE =Delay Time for Reset when Error occured

      U     #MSG_DRIVE_ERR; 
      =     L      4.0; 
      BLD   103; 
      CALL #TON_RESET_DELAY (
           IN                       := L      4.0,
           PT                       := #timResetDelay,
           Q                        := #Q_TON_RESET_DELAY);

      NOP   0; 
NETWORK
TITLE =Create the Output RESET-Impuls for the Frequency converter

      U(    ; 
      U     #Q_TON_RESET_DELAY; 
      =     L      4.0; 
      BLD   103; 
      CALL #TP_RESET (
           IN                       := L      4.0,
           PT                       := #timResetImpuls,
           Q                        := #Q_TP_RESET);

      U     BIE; 
      )     ; 
      U     #Q_TP_RESET; 
      =     #FC_RESET_IMP; 
NETWORK
TITLE =Start ResetTimeRange Monitoring
//Überwachungszeit für Max. Anzahl der Resets starten.
//
      U     #Q_TP_RESET; 
      S     #m_StartTimeRange; 
      U     #cmd_RESET; 
      R     #m_StartTimeRange; 
      NOP   0; 
NETWORK
TITLE =Count Resets

      U     #Q_TP_RESET; 
      =     L      4.0; 
      BLD   103; 
      U     #cmd_RESET; 
      =     L      4.1; 
      BLD   103; 
      CALL #CTU_ERR (
           CU                       := L      4.0,
           R                        := L      4.1,
           PV                       := 0,
           Q                        := #Q_CTU_Errors);

      NOP   0; 
NETWORK
TITLE =ResetTimeRange
//Überwachungszeit für Max. Anzahl der Resets.
//Während der Überwachungszeit dürfen nur eine maximale Anzahl an Auto-Resets
//durchgeführt werden. Danach bleibt die Störung und muss manuell quittiert 
//werden.
      U     #m_StartTimeRange; 
      =     L      4.0; 
      BLD   103; 
      CALL #TON_ResetTimeRange (
           IN                       := L      4.0,
           PT                       := #timResetMonitoring,
           Q                        := #Q_TON_ResetTimeRange,
           ET                       := #DSP_ResetTimeRange);
      NOP   0; 
NETWORK
TITLE =Max number of Reset reached

      L     #CTU_ERR.PV; 
      L     #MaxNoOfResets; 
      >=I   ; 
      =     #m_MaxNoOfResetReached; 
NETWORK
TITLE =Reset the Monitoring Time and Counter
//Reset MonitoringTime & Counter if MaxNoOfResets are not reached during 
//monitoring time.
      U     #Q_TON_ResetTimeRange; 
      U(    ; 
      ON    #m_MaxNoOfResetReached; 
      O     #ERR_RESET; 
      )     ; 
      =     #cmd_RESET; 
END_FUNCTION_BLOCK

FUNCTION_BLOCK "m7b_DriveRuntimeMonitor"
TITLE =Runtime Monitoring Drives / Laufzeitüberwachung Antriebe
//Runtime monitoring of Drives with seperate monitoring time for 
//Auto and Manual mode.
//
//In Manual Mode, the STOP command is activated when MaxTime is elapsed.
//In Auto Mode, the STOP command is activated and an ERROR is set. This
//Error must be reset by operator.
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 03/2019
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME       AENDERUNG
//--------------------------------------------------------------------------------
//
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  MSG_RUN : BOOL ;	
  MSG_AUTO : BOOL ;	
  RESET : BOOL ;	
  timMax_HAND : TIME ;	
  timMax_AUTO : TIME ;	
END_VAR
VAR_OUTPUT
  CMD_STOP : BOOL ;	
  MSG_ERR : BOOL ;	
  timRUN : TIME ;	
  timREST : TIME ;	
END_VAR
VAR
  m_timMaxRun : TIME ;	
  TON_MAX_RUN : "TON";	
  Q_TON_MAX_RUN : BOOL ;	
  m_ERROR : BOOL ;	
END_VAR
VAR_TEMP
  xVOID : BOOL ;	
  DSP_TON_MAX_RUN : TIME ;	
END_VAR
BEGIN
NETWORK
TITLE =

NETWORK
TITLE =Multiplexer for Maximum Runtime in AUTO & HAND

      O(    ; 
      UN    #MSG_AUTO; 
      SPBNB _001; 
      L     #timMax_HAND; 
      T     #m_timMaxRun; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
_001: U     BIE; 
      )     ; 
      O(    ; 
      U     #MSG_AUTO; 
      SPBNB _002; 
      L     #timMax_AUTO; 
      T     #m_timMaxRun; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
_002: U     BIE; 
      )     ; 
      =     #xVOID; 
NETWORK
TITLE =Timer Max Runtime

      U(    ; 
      U     #MSG_RUN; 
      =     L      6.0; 
      BLD   103; 
      CALL #TON_MAX_RUN (
           IN                       := L      6.0,
           PT                       := #m_timMaxRun,
           Q                        := #Q_TON_MAX_RUN,
           ET                       := #DSP_TON_MAX_RUN);
      U     BIE; 
      )     ; 
      U     #Q_TON_MAX_RUN; 
      =     #CMD_STOP; 
NETWORK
TITLE =FC-Output: timRUN & timREST
//Display at FC-Output:
//- the actual running time (timRUN)
//- the remaining time to Stop (and Error in Auto-Mode)
      U(    ; 
      L     #m_timMaxRun; 
      T     #timRUN; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
      U     BIE; 
      )     ; 
      SPBNB _003; 
      CALL "m7a_INV_IEC_TIME" (
           iecDauer                 := #m_timMaxRun,
           iecTimer                 := #DSP_TON_MAX_RUN,
           iecInvTime               := #timREST);
_003: NOP   0; 
NETWORK
TITLE =Runtime Error!
//Only in Auto-Mode it is an error if the Drive reaches the maximum runtime.
//In Hand-Mode it's only a STOP
      U     #MSG_AUTO; 
      U     #Q_TON_MAX_RUN; 
      S     #m_ERROR; 
      U     #RESET; 
      R     #m_ERROR; 
      U     #m_ERROR; 
      =     #MSG_ERR; 
END_FUNCTION_BLOCK

FUNCTION_BLOCK "m7b_AVERAGE"
TITLE =Mittelwertbildung: 1,3,5,15 Minuten
//Mittelwertbildung von analogen Signalen.
//Verwendung bei Energieerfassung z.B. Strom-, Gas-, Wärmemengenzähler
//
//TAKT_1S: S7 Systemtaktmerker 1-Sekunde
//RESET :  RESET
//rVALUE : Eingangswert
//
//ENO: TRUE
//
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 11/2013
//INTERNET: www.maagic7.de
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//16.10.2016   S.Maag     fatalen Fehler P##Buffer Berechnung behoben:
//                        Falsche Bereichskennung ausgeblendet. FB funktionierte
//                        nicht mit Instanz-DB Aufruf, nur über Multiinstanz.
//
//                        Bereichskennung muss aus rel. Adresse aus AR2
//                        entfernt werden, da diese 84 DB ist. Wir benötigen
//                        aber 85 Instanz-DB.
//                        Code getestet mit FB1141: direkter Instanz-DB und
//                        Multinstanz mit 2x Verschachtelung. Funktion I.O. 
//--------------------------------------------------------------------------------
//
//HINWEISE:
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  TAKT_1S : BOOL ;	//Taktgeber: (Flankenauswertung erfolgt im FB)
  RESET : BOOL ;	//RESET: Zähler rücksetzen
  rVALUE : REAL ;	//Zu integrierender WERT
END_VAR
VAR_OUTPUT
  rAVG_1min : REAL ;	//1 Minuten Mittelwert
  rAVG_3min : REAL ;	//3 Minuten Mittelwert
  rAVG_5min : REAL ;	//5 Minuten Mittelwert
  rAVG_15min : REAL ;	//15 Minuten Mittelwert
  evtNewValues : BOOL ;	//Ereignis Werte aktualisiert
  DSP_BUFFER_INDEX : INT ;	//Anzeige Buffer Index ARRAY[INDEX]
END_VAR
VAR
  HM_FP_TAKT : BOOL ;	//Lokaler Speicher:  
  CNT_SEC : INT ;	
  CNT_MIN : INT ;	
  dIDX : DINT ;	
  memSum1min : REAL ;	//Integralwert
  rARRAY : ARRAY  [0 .. 15 ] OF REAL ;	
END_VAR
VAR_TEMP
  tmp_rAVG : REAL ;	
  ptrARRAY : DWORD ;	
  I : INT ;	
  dJ : DINT ;	
  tmp_rSUM : REAL ;	
END_VAR
BEGIN
NETWORK
TITLE =Absoluten Pointer auf ARRAY berechnen 
//18.10.2016 S.Maag 
//Achtung: Es muss zuerst das Adressregister 2 geladen werden und von dort die 
//Bereichskennung ausgeblendet: TAR2 liefert immer Bereichskennung 84 des 
//Datenbausteins. P##evt_sec liefert 85 "Instanzdatenbaustein als 
//Bereichskennung", was direkt die Instanzdaten adressiert.
      TAR2  ; // aktueller Instanzdaten-Pointer absolut
      UD    DW#16#FFFFFF; // Speicherbereich (84 "DB") ausblenden 
      L     P##rARRAY; // relativer Pointer auf ARRAY (OFFEST)
      +D    ; 
      T     #ptrARRAY; // absoluter Pointer auf ARRAY
NETWORK
TITLE =

      U     #evtNewValues; 
      R     #evtNewValues; 

NETWORK
TITLE =RESET

      UN    #RESET; 
      SPB   ne4; 

      L     0; 
      T     #CNT_SEC; 
      T     #CNT_MIN; 
      T     #dIDX; // Zaehlvariable Minuten

      L     0.000000e+000; 
      L     #rVALUE; 
      T     #memSum1min; 

ne4:  NOP   0; 
NETWORK
TITLE =Zählen
//Bei Sollwert erreicht wird erst beim nächsten Takt der Integralwert 
//zurückgesetzt, somit kann mit dem IMPULS der aktuelle Integralwert
//für die weitere Verarbeitung noch zur Verfügung.
//
      U     #TAKT_1S; 
      FP    #HM_FP_TAKT; 
      SPB   CNT; 
      SPA   ne3; 

CNT:  L     #CNT_SEC; 
      INC   1; 
      T     #CNT_SEC; 

      L     #rVALUE; 
      L     #memSum1min; 
      +R    ; 
      T     #memSum1min; 

      L     #CNT_SEC; 
      L     60; 
      >=I   ; 
      SPB   calc; 
      SPA   ne3; 

calc: NOP   0; 
      S     #evtNewValues; 

      L     0; // Sekunden rücksetzen
      T     #CNT_SEC; 

      L     #memSum1min; 
      L     6.000000e+001; 
      /R    ; 
      T     #rAVG_1min; 
      T     #tmp_rAVG; 

      L     0.000000e+000; // 1-Minuten-Summe löschen
      T     #memSum1min; 

      L     #ptrARRAY; 
      L     #dIDX; 
      SLD   5; // *32 wegen 4-Byte-Wert = 32 Bit (S7-Pointer sind Bit-Pointer)
      +D    ; 
      LAR1  ; 

      L     #tmp_rAVG; // letzten Minuten Mittelwert  in ARRAY schreiben
      T     D [AR1,P#0.0]; // rARRAY[dIDX] = tmp_rAVG
      T     #tmp_rSUM; 

      L     #dIDX; 
      T     #dJ; 

      L     1; // Schleifenzähler
      T     #I; // For I=1 To 14 (zum akt. Wert noch 14 alte addieren)

LOOP: NOP   0; 

      L     #dIDX; 
      L     #I; 
      ITD   ; 
      -D    ; 
      UD    DW#16#F; // 0..15 Umlaufend
      SLD   5; // *32 wegen 4-Byte-Wert = 32 Bit (S7-Pointer sind Bit-Pointer)
      L     #ptrARRAY; 
      +D    ; 
      LAR1  ; 

      L     D [AR1,P#0.0]; // rARRAY[dIDX-I] Überlauf berücksichtigt
      L     #tmp_rSUM; 
      +R    ; 
      T     #tmp_rSUM; 

      L     #I; 
      L     2; // 2 Werte wurden zum aktuellen addiert, d.h. Summe aus letzten 3 Minuten
      <>I   ; 
      SPB   tst5; 

      L     #tmp_rSUM; 
      L     3.000000e+000; 
      /R    ; 
      T     #rAVG_3min; 

tst5: L     #I; 
      L     4; // 4 Werte wurden zum aktuellen addiert, d.h. Summe aus letzten 5 Minuten
      <>I   ; 
      SPB   weit; 

      L     #tmp_rSUM; 
      L     5.000000e+000; 
      /R    ; 
      T     #rAVG_5min; 

weit: L     #I; // Schleifenzähler
      +     1; 
      T     #I; 
      L     14; 
      <I    ; 
      SPB   LOOP; // LOOP IF I<14 (For I=1 To 14)

      L     #tmp_rSUM; // Summe über die letzten 15 Minuten
      L     1.500000e+001; 
      /R    ; 
      T     #rAVG_15min; 

      L     #dIDX; // geschrieben wird in ARRAY[1..15] ARRAY[0] bleibt frei
      +     1; 
      T     #dIDX; 
      L     L#15; 
      <D    ; 
      SPB   ne3; 
      L     L#0; 
      T     #dIDX; 
ne3:  NOP   0; 
NETWORK
TITLE =FC-ENO-Ausgang = Zählimpuls
//
//
      L     #dIDX; 
      T     #DSP_BUFFER_INDEX; 

      SET   ; 
      SAVE  ; 
      CLR   ; 
END_FUNCTION_BLOCK

FUNCTION_BLOCK "m7b_SpeedTakt"
TITLE =Antrieb Takten, wenn minSpeed unterschritten
//Anwendung: Frequenzumrichterantriebe ohne Fremdlüfter!
//           Antriebe ohne Fremdlüfter können nur auf etwa min 30Hz gefahren
//           werden. Soll weniger Drehzahl gefahren werden, dann muss mit
//           Puls/Pause getaktet werden. (z.B. Dosierschnecken)
//
//Dieser Baustein taktet unterhalb der MinDrehzahl mit dem Sollwert ensprechendem 
//Puls/Pausenverhältnis. Als Sollwert wird dann der Minimalwert ausgegeben. 
//
//z.B. 50Hz Motor bis 100Hz. d.h. 100Hz =100%
//     min Frequ: 30Hz
//
//d.h. bis 30% wird der Istwerteingang einfach druchgeschleift.
//bei Ist < 30% wird Sollwertausgang auf 30% eingefroren
//und der xTAKT Ausgang beginnt zu takten.
//
//bei 15% mit einem Taktverhältnis 50/50
//ist dann bei timeBase_100proz = 100sec, Puls=Pause=0.5 x timBase = 50sec
// 
//Die untere %-Einstellung bei für Fmin berechnet man am besten mit
//FC103 "m7b_RPM_DRive"
//
// 
//AUTOR: Stefan Maag, Dipl.-Ing. (FH) Elektrotechnik 
//DATUM: 8/2018
//
//
//AENDERUNGSVERMERKE:
//--------------------------------------------------------------------------------
//DATUM        NAME        AENDERUNG
//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
//
//HINWEISE: 
AUTHOR : 'S.Maag'
FAMILY : Maagic7
VERSION : 0.1


VAR_INPUT
  FRG_Takten : BOOL ;	//Freigabe: 1: Takten wird bei unterschreiten von iMin aktiviert
  RESET : BOOL ;	//Reset
  iIST : INT ;	//Istwert
  iMin : INT ;	//Minimum
  timeBase_100proz : TIME ;	//Zeitbasis 100% (bei takten 50/50, Puls=Puase=0.5*timBase_100proz)
END_VAR
VAR_OUTPUT
  xTAKT : BOOL ;	
  iSpeed : INT ;	
  DSP_PULS : TIME ;	
  DSP_PAUSE : TIME ;	
END_VAR
VAR
  mi_MultiTimer : "m7b_MultiTimer";	
  timPULS : TIME ;	
  timPAUSE : TIME ;	
END_VAR
VAR_TEMP
  CMD_TAKT : BOOL ;	
  dTime : DINT ;	
  d_ms_Puls : DINT ;	
  dIST : DINT ;	
  dMin : DINT ;	
  Q_PulsPause : BOOL ;	
  dTemp : DINT ;	
  d_test : DINT ;	
  DSP_Multi_T1 : TIME ;	
  DSP_Multi_T2 : TIME ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =Ist < Min => Takten

      U     #FRG_Takten; 
      U(    ; 
      L     #iIST; 
      L     #iMin; 
      <I    ; 
      )     ; 
      =     #CMD_TAKT; 
NETWORK
TITLE =Timebase von IEC-Time-Format => DINT

      L     #timeBase_100proz; 
      T     #dTime; 
      NOP   0; 
NETWORK
TITLE =iIST und iMin => DINT

      U(    ; 
      L     #iIST; 
      ITD   ; 
      T     #dIST; 


      SET   ; 
      SAVE  ; 
      CLR   ; 
      U     BIE; 
      )     ; 
      SPBNB _001; 
      L     #iMin; 
      ITD   ; 
      T     #dMin; 
_001: NOP   0; 
NETWORK
TITLE =Saklierung IST von [0..Min] => [0..Pulsdauer] DINT
//0-basierte Skalierung: IST von 0..MIN => 0..TimeBase 
//
//Formeel x = MaxOUT/MaxIN * VALUE
      U(    ; 
      L     #timeBase_100proz; 
      L     #dMin; 
      /D    ; 
      T     #dTemp; 
      UN    OV; 
      SAVE  ; 
      CLR   ; 
      U     BIE; 
      )     ; 
      SPBNB _002; 
      L     #dTemp; 
      L     #dIST; 
      *D    ; 
      T     #d_ms_Puls; 
_002: NOP   0; 
NETWORK
TITLE =Puls DINT => TIME; Pause=timBase-Puls
//Bearbeiten der Puls/Pause Zeiten nur, wenn iIst>0, sonst werden bei einem Stop
//(iIst=0) 20sec Pause berechnet, was falsch ist, da der Antrieb wegen Taktung 
//anhält.
      U(    ; 
      U(    ; 
      L     #iIST; 
      L     0; 
      >I    ; 
      )     ; 
      SPBNB _003; 
      L     #d_ms_Puls; 
      T     #timPULS; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
_003: U     BIE; 
      )     ; 
      SPBNB _004; 
      L     #dTime; 
      L     #d_ms_Puls; 
      -D    ; 
      T     #timPAUSE; 
_004: NOP   0; 
NETWORK
TITLE =Anzeigeausgänge Puls/Pause

      U(    ; 
      U(    ; 
      L     #iIST; 
      L     0; 
      >I    ; 
      )     ; 
      SPBNB _005; 
      L     #timPULS; 
      T     #DSP_PULS; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
_005: U     BIE; 
      )     ; 
      SPBNB _006; 
      L     #timPAUSE; 
      T     #DSP_PAUSE; 
_006: NOP   0; 
NETWORK
TITLE =Puls-Paus-Timer mit MultiTimer

      U     #CMD_TAKT; 
      =     L     36.0; 
      BLD   103; 
      U     #RESET; 
      =     L     36.1; 
      BLD   103; 
      CALL #mi_MultiTimer (
           IN                       := L     36.0,
           RESET                    := L     36.1,
           timT1                    := #timPULS,
           timT2                    := #timPAUSE,
           cfgMODE                  := 1,
           Q                        := #Q_PulsPause,
           DSP_T1                   := #DSP_Multi_T1,
           DSP_T2                   := #DSP_Multi_T2);
      NOP   0; 
NETWORK
TITLE =Bei takten iMin ausgeben, sonst iIST

      U(    ; 
      U     #CMD_TAKT; 
      SPBNB _007; 
      L     #iMin; 
      T     #iSpeed; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
_007: U     BIE; 
      )     ; 
      NOT   ; 
      SPBNB _008; 
      L     #iIST; 
      T     #iSpeed; 
_008: NOP   0; 
NETWORK
TITLE =Taktausgang

      O     #Q_PulsPause; 
      ON    #CMD_TAKT; 
      =     #xTAKT; 
NETWORK
TITLE =FB-ENO = TAKT

      U     #xTAKT; 
      SAVE  ; 
END_FUNCTION_BLOCK

FUNCTION_BLOCK "Zwangsumschaltung"
TITLE =Systemumschaltung
//Umschaltung zwischen 2 redundanten Systemen. Z.B. 2 Pumpen, wobei 1 System 
//immer als Ersatz vorhanden ist. Zwangsumschaltung 1x täglich nach Zeit
FAMILY : 'S.Maag'
VERSION : 0.1


VAR_INPUT
  IN_START : BOOL ;	
  READY_1 : BOOL ;	
  READY_2 : BOOL ;	
  HOUR_1to2 : INT ;	
  MIN_1to2 : INT ;	
  HOUR_2to1 : INT ;	
  MIN_2to1 : INT ;	
  timOVERLAP : TIME ;	//Überlappungzeit bei Umschaltung
END_VAR
VAR_OUTPUT
  OUT_START_1 : BOOL ;	
  OUT_START_2 : BOOL ;	
END_VAR
VAR
  HM : BOOL ;	
  SWTCH_to_2 : BOOL ;	
  EVENT : BOOL ;	
  OVERLAP : BOOL ;	
  Q_TON_OVERLAP : BOOL ;	
  TON_OVERLAP : "TON";	
END_VAR
VAR_TEMP
  DATE_TIME : DATE_AND_TIME ;	
  RET_VAL_READ_CLK : INT ;	
  m_STD : INT ;	
  m_MIN : INT ;	
  HM_Q_TON_OVERLAP : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =Zeit in temporäreren Variablenbereich einlesen

      CALL "READ_CLK" (
           RET_VAL                  := #RET_VAL_READ_CLK,
           CDT                      := #DATE_TIME);
      NOP   0; 
NETWORK
TITLE =Stunden, Minuten und Sekunden aus DATE_AND_TIME extrahieren
//Das DATE_AND_TIME Format benötigt 8 Byte im BCD-Format
//Der Wertebereich geht von DT#1990-1-1-0:0:0.0 bis DT#2089-12-31-23:59:59.999 
//
//BYTE 0:  Jahr
//BYTE 1:  Monat
//BYTE 2:  Tag
//BYTE 3:  Stunde
//BYTE 4:  Minute
//BYTE 5:  Sekunde
//BYTE 6:  100er und 10er Stelle von Millisekunden
//BYTE 7:  Bit 4..7: 1er  Stelle von Millisekunden
//BYTE 7:  Bit 0..3: Wochentag (1=Sonntag, 2=Montag, ..., 7=Samstag)
      L     P##DATE_TIME; 
      LAR1  ; 

      L     B [AR1,P#3.0]; // Stunde
      BTI   ; 
      T     #m_STD; 

      L     B [AR1,P#4.0]; // Minute
      BTI   ; 
      T     #m_MIN; 

// Zeit prüfen und Event erzeugen
      L     #HOUR_1to2; 
      L     #m_STD; 
      <>I   ; // Stunde stimmt nicht, dann Ende
      SPB   END; 

      L     #MIN_1to2; 
      L     #m_MIN; 
      <>I   ; // Minute stimmt nicht
      R     #HM; // HM wieder löschen
      SPB   END; 

      U     #HM; 
      SPB   END; 
      S     #HM; 
      S     #EVENT; 

      UN    #SWTCH_to_2; 
      =     #SWTCH_to_2; 

END:  NOP   0; 


NETWORK
TITLE =Zeit Überlappung mit Durchschaltung bei T:=0ms
//Sonderbehandlung IEC-Zeit, da Zeit mit T:=0 nicht anläuft
      U(    ; 
      U     #EVENT; 
      =     L     15.0; 
      BLD   103; 
      CALL #TON_OVERLAP (
           IN                       := L     15.0,
           PT                       := #timOVERLAP,
           Q                        := #HM_Q_TON_OVERLAP);

      U     BIE; 
      )     ; 
      U     #HM_Q_TON_OVERLAP; 
      O     ; 
      U     #EVENT; 
      U(    ; 
      L     #timOVERLAP; 
      L     T#0MS; 
      ==D   ; 
      )     ; 
      =     #Q_TON_OVERLAP; 
      R     #EVENT; 
NETWORK
TITLE =Overlap

      U     #EVENT; 
      UN    #Q_TON_OVERLAP; 
      =     #OVERLAP; 
NETWORK
TITLE =Start System 1



      U     #IN_START; 
      U     #READY_1; 
      U(    ; 
      ON    #SWTCH_to_2; 
      O     ; 
      U     #SWTCH_to_2; 
      UN    #READY_2; 
      O     ; 
      U     #OUT_START_1; 
      U     #OVERLAP; 
      )     ; 
      =     #OUT_START_1; 
NETWORK
TITLE =Start System 2

      U     #IN_START; 
      U     #READY_2; 
      U(    ; 
      O     #SWTCH_to_2; 
      O     ; 
      UN    #SWTCH_to_2; 
      UN    #READY_1; 
      O     ; 
      U     #OUT_START_2; 
      U     #OVERLAP; 
      )     ; 
      =     #OUT_START_2; 
END_FUNCTION_BLOCK

FUNCTION_BLOCK "cLevelMeter"
TITLE =Stufenschalter für 4 Geräte
AUTHOR : 'S.Maag'
VERSION : 0.1


VAR_INPUT
  rSOLL : REAL ;	
  rS1_OFF : REAL ;	
  rS1_ON : REAL ;	
  rS2_OFF : REAL ;	
  rS2_ON : REAL ;	
  rS3_OFF : REAL ;	
  rS3_ON : REAL ;	
  rS4_OFF : REAL ;	
  rS4_ON : REAL ;	
END_VAR
VAR_OUTPUT
  Q1 : BOOL ;	//Device 1
  Q2 : BOOL ;	//Device 2 
  Q3 : BOOL ;	//Device 3
  Q4 : BOOL ;	//Device 4
END_VAR
BEGIN
NETWORK
TITLE =



NETWORK
TITLE =Stufe 1: Hystereseschalter

      U(    ; 
      L     #rSOLL; 
      L     #rS1_ON; 
      >=R   ; 
      )     ; 
      S     #Q1; 
      U(    ; 
      L     #rSOLL; 
      L     #rS1_OFF; 
      <=R   ; 
      )     ; 
      R     #Q1; 
      NOP   0; 
NETWORK
TITLE =Stufe 2: Hystereseschalter

      U(    ; 
      L     #rSOLL; 
      L     #rS2_ON; 
      >=R   ; 
      )     ; 
      S     #Q2; 
      U(    ; 
      L     #rSOLL; 
      L     #rS2_OFF; 
      <=R   ; 
      )     ; 
      R     #Q2; 
      NOP   0; 
NETWORK
TITLE =Stufe 3: Hystereseschalter

      U(    ; 
      L     #rSOLL; 
      L     #rS3_ON; 
      >=R   ; 
      )     ; 
      S     #Q3; 
      U(    ; 
      L     #rSOLL; 
      L     #rS3_OFF; 
      <=R   ; 
      )     ; 
      R     #Q3; 
      NOP   0; 
NETWORK
TITLE =Stufe 4: Hystereseschalter

      U(    ; 
      L     #rSOLL; 
      L     #rS4_ON; 
      >=R   ; 
      )     ; 
      S     #Q4; 
      U(    ; 
      L     #rSOLL; 
      L     #rS4_OFF; 
      <=R   ; 
      )     ; 
      R     #Q4; 
      NOP   0; 
END_FUNCTION_BLOCK

(*$PDIAG <?xml version='1.0' encoding='UTF-8'?>
<PDIAGDATA>
<Unit Block="FB1136" Type="14" Num="1136" TypeBType="0" TypeBNum="0">
<At id="1001">"m7b_ZylSensorCtrl"</At>
<At id="1003">19.09.2008 11:40:15</At>
<At id="1004">10.12.2020 20:10:02</At>
<At id="6109D">FB1136</At>
<At id="8006109D">FB1136</At>
</Unit>
</PDIAGDATA> *)
